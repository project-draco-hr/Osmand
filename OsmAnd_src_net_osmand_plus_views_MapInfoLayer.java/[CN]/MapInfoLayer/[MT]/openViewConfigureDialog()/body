{
  final OsmandSettings settings=view.getSettings();
  final ArrayList<Object> list=new ArrayList<Object>();
  list.add(map.getString(R.string.map_widget_reset));
  list.add(map.getString(R.string.map_widget_top_stack));
  list.addAll(mapInfoControls.getTop());
  list.add(map.getString(R.string.map_widget_right_stack));
  list.addAll(mapInfoControls.getRight());
  list.add(map.getString(R.string.map_widget_left_stack));
  list.addAll(mapInfoControls.getLeft());
  list.add(map.getString(R.string.map_widget_appearance));
  list.addAll(mapInfoControls.getAppearanceWidgets());
  Builder b=new AlertDialog.Builder(map);
  final ApplicationMode mode=settings.getApplicationMode();
  ListAdapter listAdapter=new ArrayAdapter<Object>(map,R.layout.layers_list_activity_item,R.id.title,list){
    @Override public View getView(    final int position,    View convertView,    ViewGroup parent){
      View v=convertView;
      if (v == null) {
        v=map.getLayoutInflater().inflate(R.layout.layers_list_activity_item,null);
      }
      final TextView tv=(TextView)v.findViewById(R.id.title);
      final CheckBox ch=((CheckBox)v.findViewById(R.id.check_item));
      Object o=list.get(position);
      if (o instanceof MapInfoControlRegInfo) {
        final MapInfoControlRegInfo mi=(MapInfoControlRegInfo)o;
        String s=mi.visibleCollapsed(mode) ? " - " : "  ";
        tv.setText(s + map.getString(mi.messageId) + s);
        if (mi.drawable != 0) {
          tv.setPadding((int)(12 * scaleCoefficient),0,0,0);
          tv.setCompoundDrawablesWithIntrinsicBounds(mi.drawable,0,0,0);
        }
 else {
          tv.setCompoundDrawablesWithIntrinsicBounds(0,0,0,0);
          tv.setPadding((int)(30 * scaleCoefficient),0,0,0);
        }
        boolean check=mi.visibleCollapsed(mode) || mi.visible(mode);
        ch.setOnCheckedChangeListener(null);
        ch.setChecked(check);
        ch.setOnCheckedChangeListener(new OnCheckedChangeListener(){
          @Override public void onCheckedChanged(          CompoundButton buttonView,          boolean isChecked){
            if (!isChecked) {
              if (mi.visible(mode) && mi.collapseEnabled(mode)) {
                mapInfoControls.changeVisibility(mi,true,true);
                ch.setChecked(true);
              }
 else {
                mapInfoControls.changeVisibility(mi,false,false);
              }
            }
 else {
              mapInfoControls.changeVisibility(mi,true,false);
            }
            String s=mi.visibleCollapsed(mode) ? " - " : "  ";
            tv.setText(s + map.getString(mi.messageId) + s);
            recreateControls();
          }
        }
);
        ch.setVisibility(View.VISIBLE);
      }
 else {
        tv.setText(o.toString());
        tv.setCompoundDrawablesWithIntrinsicBounds(0,0,0,0);
        tv.setPadding((int)(5 * scaleCoefficient),0,0,0);
        ch.setVisibility(View.INVISIBLE);
      }
      return v;
    }
  }
;
  b.setAdapter(listAdapter,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int position){
      Object o=list.get(position);
      if (o instanceof MapInfoControlRegInfo) {
        final MapInfoControlRegInfo mi=(MapInfoControlRegInfo)o;
        boolean check=mi.visibleCollapsed(mode) || mi.visible(mode);
        if (check) {
          mapInfoControls.changeVisibility(mi,false,false);
        }
 else {
          mapInfoControls.changeVisibility(mi,true,false);
        }
        recreateControls();
      }
 else       if (o.toString().equals(map.getString(R.string.map_widget_reset))) {
        mapInfoControls.resetToDefault();
        recreateControls();
      }
    }
  }
);
  final AlertDialog dlg=b.create();
  dlg.setCanceledOnTouchOutside(true);
  dlg.show();
}
