{
  final RoutingHelper routingHelper=routeLayer.getHelper();
  final NextTurnInfoControl nextTurnInfo=new NextTurnInfoControl(map,paintSmallText,paintSmallSubText,true){
    @Override public boolean updateInfo(){
      boolean visible=false;
      if (routeLayer != null && routingHelper.isRouterEnabled() && routingHelper.isFollowingMode()) {
        boolean uturnWhenPossible=routingHelper.makeUturnWhenPossible();
        int d;
        if (uturnWhenPossible) {
          d=routingHelper.getDistanceToNextRouteDirection();
        }
 else {
          d=routingHelper.getDistanceToNextNextRouteDirection();
        }
        if (d >= 0 && !showMiniMap) {
          visible=true;
          RouteDirectionInfo next=uturnWhenPossible ? routingHelper.getNextRouteDirectionInfo() : routingHelper.getNextNextRouteDirectionInfo();
          if (next == null) {
            if (turnType != null) {
              turnType=null;
              invalidate();
            }
          }
 else           if (!Algoritms.objectEquals(turnType,next.getTurnType())) {
            turnType=next.getTurnType();
            TurnPathHelper.calcTurnPath(pathForTurn,turnType,pathTransform);
            invalidate();
          }
          if (distChanged(d,nextTurnDirection)) {
            invalidate();
            nextTurnDirection=d;
          }
          int imminent=uturnWhenPossible ? routingHelper.getNextTurnImminent() : routingHelper.getNextNextTurnImminent();
          if (turnImminent != imminent) {
            turnImminent=imminent;
            invalidate();
          }
        }
      }
      updateVisibility(visible);
      return true;
    }
  }
;
  nextTurnInfo.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      view.refreshMap();
    }
  }
);
  return nextTurnInfo;
}
