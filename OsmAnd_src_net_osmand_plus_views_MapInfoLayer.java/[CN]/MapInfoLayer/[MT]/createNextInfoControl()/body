{
  final RoutingHelper routingHelper=routeLayer.getHelper();
  final NextTurnInfoControl nextTurnInfo=new NextTurnInfoControl(map,paintText,paintSubText,false){
    NextDirectionInfo calc1=new NextDirectionInfo();
    TurnType straight=TurnType.valueOf(TurnType.C,true);
    @Override public boolean updateInfo(){
      boolean visible=false;
      if (routeLayer != null && routingHelper.isRouteCalculated()) {
        boolean follow=routingHelper.isFollowingMode();
        makeUturnWhenPossible=routingHelper.makeUturnWhenPossible() && follow;
        if (makeUturnWhenPossible) {
          visible=true;
          turnImminent=1;
          turnType=TurnType.valueOf(TurnType.TU,view.getSettings().LEFT_SIDE_NAVIGATION.get());
          TurnPathHelper.calcTurnPath(pathForTurn,turnType,pathTransform);
          invalidate();
        }
 else {
          boolean showStraight=false;
          NextDirectionInfo r=null;
          if (follow) {
            r=routingHelper.getNextRouteDirectionInfo(calc1,true);
          }
 else {
            int di=map.getMapLayers().getRouteInfoLayer().getDirectionInfo();
            if (di >= 0 && map.getMapLayers().getRouteInfoLayer().isVisible()) {
              RouteDirectionInfo next=routingHelper.getRouteDirections().get(di);
              r=new NextDirectionInfo();
              r.directionInfo=next;
              r.distanceTo=0;
              r.imminent=1;
            }
          }
          if (r != null && r.distanceTo > 0) {
            visible=true;
            if (r.directionInfo == null) {
              if (turnType != null) {
                turnType=null;
                invalidate();
              }
            }
 else             if (!Algoritms.objectEquals(turnType,showStraight ? straight : r.directionInfo.getTurnType())) {
              turnType=showStraight ? straight : r.directionInfo.getTurnType();
              TurnPathHelper.calcTurnPath(pathForTurn,turnType,pathTransform);
              if (turnType.getExitOut() > 0) {
                exitOut=turnType.getExitOut() + "";
              }
 else {
                exitOut=null;
              }
              requestLayout();
              invalidate();
            }
            if (distChanged(r.distanceTo,nextTurnDirection)) {
              invalidate();
              requestLayout();
              nextTurnDirection=r.distanceTo;
            }
            if (turnImminent != r.imminent) {
              turnImminent=r.imminent;
              invalidate();
            }
          }
        }
      }
      updateVisibility(visible);
      return true;
    }
  }
;
  nextTurnInfo.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      nextTurnInfo.requestLayout();
      view.refreshMap();
    }
  }
);
  nextTurnInfo.setVisibility(View.GONE);
  return nextTurnInfo;
}
