{
  double cBottomLatitude=dataBox.bottom;
  double cTopLatitude=dataBox.top;
  double cLeftLongitude=dataBox.left;
  double cRightLongitude=dataBox.right;
  log.info(String.format("BLat=%s, TLat=%s, LLong=%s, RLong=%s, zoom=%s",cBottomLatitude,cTopLatitude,cLeftLongitude,cRightLongitude,zoom));
  long now=System.currentTimeMillis();
  if (files.isEmpty()) {
    cObjectsBox=dataBox;
    cObjects=new ArrayList<BinaryMapDataObject>();
    return true;
  }
  try {
    int count=0;
    ArrayList<BinaryMapDataObject> tempList=new ArrayList<BinaryMapDataObject>();
    System.gc();
    TLongSet ids=new TLongHashSet();
    Map<TagValuePair,List<BinaryMapDataObject>> multiPolygons=new LinkedHashMap<TagValuePair,List<BinaryMapDataObject>>();
    int leftX=MapUtils.get31TileNumberX(cLeftLongitude);
    int rightX=MapUtils.get31TileNumberX(cRightLongitude);
    int bottomY=MapUtils.get31TileNumberY(cBottomLatitude);
    int topY=MapUtils.get31TileNumberY(cTopLatitude);
    searchRequest=BinaryMapIndexReader.buildSearchRequest(leftX,rightX,topY,bottomY,zoom);
    if (zoom < 15) {
      searchRequest.setSearchFilter(new BinaryMapIndexReader.SearchFilter(){
        TIntByteMap map=MapRenderingTypes.getObjectTypeMinZoom();
        @Override public boolean accept(        TIntArrayList types){
          for (int j=0; j < types.size(); j++) {
            int type=types.get(j);
            if ((type & 3) == MapRenderingTypes.POINT_TYPE) {
              type&=0x7ffc;
            }
 else {
              type&=0xffc;
            }
            byte b=map.get(type);
            if (b != 0 && b <= zoom) {
              return true;
            }
          }
          return false;
        }
      }
);
    }
    for (    BinaryMapIndexReader c : files.values()) {
      List<BinaryMapDataObject> res=c.searchMapIndex(searchRequest);
      if (checkWhetherInterrupted()) {
        return false;
      }
      for (      BinaryMapDataObject r : res) {
        if (PerformanceFlags.checkForDuplicateObjectIds) {
          if (ids.contains(r.getId())) {
            continue;
          }
          ids.add(r.getId());
        }
        count++;
        for (int i=0; i < r.getTypes().length; i++) {
          if ((r.getTypes()[i] & 0x3) == MapRenderingTypes.MULTY_POLYGON_TYPE) {
            int type=MapRenderingTypes.getMainObjectType(r.getTypes()[i]);
            int subtype=MapRenderingTypes.getObjectSubType(r.getTypes()[i]);
            TagValuePair pair=r.getMapIndex().decodeType(type,subtype);
            if (pair != null) {
              pair=new TagValuePair(pair.tag,pair.value,r.getTypes()[i]);
              if (!multiPolygons.containsKey(pair)) {
                multiPolygons.put(pair,new ArrayList<BinaryMapDataObject>());
              }
              multiPolygons.get(pair).add(r);
            }
          }
        }
        if (checkWhetherInterrupted()) {
          return false;
        }
        tempList.add(r);
      }
    }
    List<MultyPolygon> pMulti=proccessMultiPolygons(multiPolygons,leftX,rightX,bottomY,topY,zoom);
    tempList.addAll(pMulti);
    log.info(String.format("Search has been done in %s ms. %s results were found.",System.currentTimeMillis() - now,count));
    cObjects=tempList;
    cObjectsBox=dataBox;
  }
 catch (  IOException e) {
    log.debug("Search failed",e);
    return false;
  }
  return true;
}
