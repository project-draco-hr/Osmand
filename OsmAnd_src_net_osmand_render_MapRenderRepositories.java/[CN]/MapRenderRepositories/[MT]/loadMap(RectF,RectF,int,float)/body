{
  boolean inside=insideBox(boundsTileRect.top,boundsTileRect.left,boundsTileRect.bottom,boundsTileRect.right,zoom);
  cRotate=rotate < 0 ? rotate + 360 : rotate;
  if (!inside) {
    cTopY=boundsTileRect.top;
    cLeftX=boundsTileRect.left;
    cRightX=boundsTileRect.right;
    cBottomY=boundsTileRect.bottom;
    double cBottomLatitude=MapUtils.getLatitudeFromTile(zoom,cBottomY);
    double cTopLatitude=MapUtils.getLatitudeFromTile(zoom,cTopY);
    double cLeftLongitude=MapUtils.getLongitudeFromTile(zoom,cLeftX);
    double cRightLongitude=MapUtils.getLongitudeFromTile(zoom,cRightX);
    cZoom=zoom;
    log.info(String.format("BLat=%s, TLat=%s, LLong=%s, RLong=%s, zoom=%s",cBottomLatitude,cTopLatitude,cLeftLongitude,cRightLongitude,cZoom));
    long now=System.currentTimeMillis();
    if (connections.isEmpty()) {
      cObjects=new ArrayList<MapRenderObject>();
      return;
    }
    try {
      int count=0;
      cObjects=new ArrayList<MapRenderObject>();
      System.gc();
      Set<Long> ids=new LinkedHashSet<Long>();
      Map<Integer,List<MapRenderObject>> multiPolygons=new LinkedHashMap<Integer,List<MapRenderObject>>();
      for (      Connection c : connections.keySet()) {
        RectF r=connections.get(c);
        boolean intersects=r.top >= cBottomLatitude && r.left <= cRightLongitude && r.right >= cLeftLongitude && r.bottom <= cTopLatitude;
        if (!intersects) {
          continue;
        }
        PreparedStatement statement=null;
        if (zoom >= 15) {
          statement=pZoom0.get(c);
        }
 else         if (zoom >= 10) {
          statement=pZoom1.get(c);
        }
 else         if (zoom >= 6) {
          statement=pZoom2.get(c);
        }
        statement.setDouble(1,cBottomLatitude);
        statement.setDouble(2,cTopLatitude);
        statement.setDouble(3,cLeftLongitude);
        statement.setDouble(4,cRightLongitude);
        ResultSet result=statement.executeQuery();
        try {
          while (result.next()) {
            long id=result.getLong(1);
            if (PerformanceFlags.checkForDuplicateObjectIds) {
              if (ids.contains(id)) {
                continue;
              }
              ids.add(id);
            }
            int type=result.getInt(4);
            MapRenderObject obj=new MapRenderObject(id);
            obj.setData(result.getBytes(2));
            obj.setName(result.getString(3));
            obj.setType(type);
            count++;
            if ((type & 0x3) == 0) {
              if (!multiPolygons.containsKey(type)) {
                multiPolygons.put(type,new ArrayList<MapRenderObject>());
              }
              multiPolygons.get(type).add(obj);
            }
 else {
              cObjects.add(obj);
            }
          }
        }
  finally {
          result.close();
        }
      }
      int leftX=MapUtils.get31TileNumberX(cLeftLongitude);
      int rightX=MapUtils.get31TileNumberX(cRightLongitude);
      int bottomY=MapUtils.get31TileNumberY(cBottomLatitude);
      int topY=MapUtils.get31TileNumberY(cTopLatitude);
      proccessMultiPolygons(multiPolygons,leftX,rightX,bottomY,topY);
      log.info(String.format("Search has been done in %s ms. %s results were found.",System.currentTimeMillis() - now,count));
    }
 catch (    java.sql.SQLException e) {
      log.debug("Search failed",e);
    }
  }
  RectF newLoc=new RectF((float)MapUtils.getLongitudeFromTile(zoom,tileRect.left),(float)MapUtils.getLatitudeFromTile(zoom,tileRect.top),(float)MapUtils.getLongitudeFromTile(zoom,tileRect.right),(float)MapUtils.getLatitudeFromTile(zoom,tileRect.bottom));
  int width=(int)calcDiffPixelX(cRotate,tileRect.right - tileRect.left,tileRect.bottom - tileRect.top);
  int height=(int)calcDiffPixelY(cRotate,tileRect.right - tileRect.left,tileRect.bottom - tileRect.top);
  Bitmap bmp=renderer.generateNewBitmap(width,height,tileRect.left,tileRect.top,cObjects,cZoom,cRotate);
  Bitmap oldBmp=this.bmp;
  this.bmp=bmp;
  cachedWaysLoc=newLoc;
  cachedRotate=cRotate;
  if (oldBmp != null) {
    oldBmp.recycle();
  }
}
