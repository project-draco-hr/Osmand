{
  MultyPolygon pl=new MultyPolygon();
  pl.setType(type << 1);
  for (int km=0; km < 2; km++) {
    List<MapRenderObject> list=km == 0 ? directList : inverselist;
    for (    MapRenderObject o : list) {
      int len=o.getPointsLength();
      if (len < 2) {
        continue;
      }
      List<Long> coordinates=new ArrayList<Long>();
      if (o.getName() != null) {
        pl.setName(o.getName());
      }
      int px=o.getPoint31XTile(km == 0 ? 0 : len - 1);
      int py=o.getPoint31YTile(km == 0 ? 0 : len - 1);
      int x=px;
      int y=py;
      boolean pinside=leftX <= x && x <= rightX && y >= topY && y <= bottomY;
      if (pinside) {
        coordinates.add((((long)x) << 32) | ((long)y));
      }
      for (int i=1; i < len; i++) {
        x=o.getPoint31XTile(km == 0 ? i : len - i - 1);
        y=o.getPoint31YTile(km == 0 ? i : len - i - 1);
        boolean inside=leftX <= x && x <= rightX && y >= topY && y <= bottomY;
        calculateLineCoordinates(inside,x,y,pinside,px,py,leftX,rightX,bottomY,topY,coordinates);
        if (pinside && !inside) {
          processMultipolygonLine(completedRings,incompletedRings,coordinates);
          coordinates=new ArrayList<Long>();
        }
        px=x;
        py=y;
        pinside=inside;
      }
      processMultipolygonLine(completedRings,incompletedRings,coordinates);
    }
  }
  if (incompletedRings.size() > 0) {
    unifyIncompletedRings(incompletedRings,completedRings,leftX,rightX,bottomY,topY);
  }
  long[][] lns=new long[completedRings.size()][];
  for (int i=0; i < completedRings.size(); i++) {
    List<Long> ring=completedRings.get(i);
    lns[i]=new long[ring.size()];
    for (int j=0; j < lns[i].length; j++) {
      lns[i][j]=ring.get(j);
    }
  }
  pl.setLines(lns);
  return pl;
}
