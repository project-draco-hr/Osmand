{
  MergeTurnLaneTurn active=new MergeTurnLaneTurn(currentSegment);
  MergeTurnLaneTurn target=new MergeTurnLaneTurn(nextSegment);
  if (active.activeLen < 2) {
    return;
  }
  if (target.activeStartIndex == -1) {
    return;
  }
  boolean changed=false;
  if (target.isActiveTurnMostLeft()) {
    if (target.activeLen <= active.activeLen) {
      active.activeEndIndex-=(active.activeLen - target.activeLen);
      changed=true;
    }
  }
 else   if (target.isActiveTurnMostRight()) {
    if (target.activeLen < active.activeLen) {
      active.activeStartIndex+=(active.activeLen - target.activeLen);
      changed=true;
    }
  }
 else {
    if (target.activeLen < active.activeLen) {
      float ratio=(active.activeLen - target.activeLen) / 2f;
      active.activeEndIndex=(int)Math.ceil(active.activeEndIndex - ratio);
      active.activeStartIndex=(int)Math.floor(active.activeStartIndex + ratio);
      changed=true;
    }
  }
  if (!changed) {
    return;
  }
  for (int i=0; i < active.disabledLanes.length; i++) {
    if (i >= active.activeStartIndex && i <= active.activeEndIndex) {
      active.disabledLanes[i]|=1;
    }
  }
  TurnType currentTurn=currentSegment.getTurnType();
  currentTurn.setLanes(active.disabledLanes);
  int turn=inferTurnFromLanes(active.disabledLanes);
  if (turn != 0 && turn != currentTurn.getValue()) {
    TurnType newTurnType=TurnType.valueOf(turn,leftSide);
    newTurnType.setLanes(active.disabledLanes);
    newTurnType.setSkipToSpeak(currentTurn.isSkipToSpeak());
    currentSegment.setTurnType(newTurnType);
  }
}
