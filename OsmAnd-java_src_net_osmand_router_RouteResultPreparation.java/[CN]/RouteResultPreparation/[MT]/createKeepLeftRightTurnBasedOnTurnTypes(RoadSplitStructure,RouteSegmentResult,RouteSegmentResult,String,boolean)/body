{
  TurnType t=TurnType.valueOf(TurnType.C,leftSide);
  int[] rawLanes=calculateRawTurnLanes(turnLanes,TurnType.C);
  if (rs.keepLeft || rs.keepRight) {
    String[] splitLaneOptions=turnLanes.split("\\|",-1);
    int activeBeginIndex=findActiveIndex(rawLanes,splitLaneOptions,rs.leftLanes,true,rs.leftLanesInfo,rs.roadsOnLeft,rs.addRoadsOnLeft);
    int activeEndIndex=findActiveIndex(rawLanes,splitLaneOptions,rs.rightLanes,false,rs.rightLanesInfo,rs.roadsOnRight,rs.addRoadsOnRight);
    if (activeBeginIndex == -1 || activeEndIndex == -1 || activeBeginIndex > activeEndIndex) {
      return createSimpleKeepLeftRightTurn(leftSide,prevSegm,currentSegm,rs);
    }
    for (int k=0; k < rawLanes.length; k++) {
      if (k >= activeBeginIndex && k <= activeEndIndex) {
        rawLanes[k]|=1;
      }
    }
    int tp=inferSlightTurnFromLanes(rawLanes,rs);
    if (tp != t.getValue() && tp != 0) {
      t=TurnType.valueOf(tp,leftSide);
    }
  }
 else {
    boolean possiblyLeftTurn=rs.roadsOnLeft == 0;
    boolean possiblyRightTurn=rs.roadsOnRight == 0;
    t.setPossibleLeftTurn(possiblyLeftTurn);
    t.setPossibleRightTurn(possiblyRightTurn);
    for (int k=0; k < rawLanes.length; k++) {
      int turn=TurnType.getPrimaryTurn(rawLanes[k]);
      int sturn=TurnType.getSecondaryTurn(rawLanes[k]);
      boolean active=false;
      if ((TurnType.isRightTurn(sturn) && possiblyRightTurn) || (TurnType.isLeftTurn(sturn) && possiblyLeftTurn)) {
        active=true;
      }
 else       if ((TurnType.isRightTurn(turn) && possiblyRightTurn) || (TurnType.isLeftTurn(turn) && possiblyLeftTurn)) {
        active=true;
      }
 else       if (turn == TurnType.C) {
        active=true;
      }
      if (active) {
        rawLanes[k]|=1;
      }
    }
  }
  t.setSkipToSpeak(!rs.speak);
  t.setLanes(rawLanes);
  return t;
}
