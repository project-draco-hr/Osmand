{
  int[] lanes=null;
  boolean kl=false;
  boolean kr=false;
  List<RouteSegmentResult> attachedRoutes=currentSegm.getAttachedRoutes(currentSegm.getStartPointIndex());
  int ls=prevSegm.getObject().getLanes();
  if (ls >= 0 && prevSegm.getObject().getOneway() == 0) {
    ls=(ls + 1) / 2;
  }
  int left=0;
  int right=0;
  boolean speak=false;
  int speakPriority=Math.max(highwaySpeakPriority(prevSegm.getObject().getHighway()),highwaySpeakPriority(currentSegm.getObject().getHighway()));
  boolean otherRoutesExist=false;
  if (attachedRoutes != null) {
    for (    RouteSegmentResult attached : attachedRoutes) {
      double ex=MapUtils.degreesDiff(attached.getBearingBegin(),currentSegm.getBearingBegin());
      double mpi=Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(),attached.getBearingBegin()));
      int rsSpeakPriority=highwaySpeakPriority(attached.getObject().getHighway());
      if (rsSpeakPriority != MAX_SPEAK_PRIORITY || speakPriority == MAX_SPEAK_PRIORITY) {
        if ((ex < TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex >= 0) {
          kl=true;
          int lns=countLanes(attached);
          if (lns <= 0) {
            right+=1;
          }
 else {
            right+=lns;
          }
          speak=speak || rsSpeakPriority <= speakPriority;
        }
 else         if ((ex > -TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex <= 0) {
          kr=true;
          int lns=countLanes(attached);
          if (lns <= 0) {
            left+=1;
          }
 else {
            left+=lns;
          }
          speak=speak || rsSpeakPriority <= speakPriority;
        }
 else         if (mpi >= TURN_DEGREE_MIN) {
          otherRoutesExist=true;
        }
      }
    }
  }
  if (kr && left == 0) {
    left=1;
  }
 else   if (kl && right == 0) {
    right=1;
  }
  int current=countLanes(currentSegm);
  if (current <= 0) {
    current=1;
  }
  lanes=new int[current + left + right];
  ls=current + left + right;
  for (int it=0; it < ls; it++) {
    if (it < left || it >= left + current) {
      lanes[it]=0;
    }
 else {
      lanes[it]=1;
    }
  }
  if ((current <= left + right) && (left > 1 || right > 1)) {
    speak=true;
  }
  double devation=Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(),currentSegm.getBearingBegin()));
  boolean makeSlightTurn=devation > 5 && (!isMotorway(prevSegm) || !isMotorway(currentSegm));
  if (kl && kr) {
    t=TurnType.valueOf(TurnType.C,leftSide);
    t.setSkipToSpeak(!speak);
  }
 else   if (kl) {
    t=TurnType.valueOf(makeSlightTurn ? TurnType.TSLL : TurnType.KL,leftSide);
    t.setSkipToSpeak(!speak);
  }
 else   if (kr) {
    t=TurnType.valueOf(makeSlightTurn ? TurnType.TSLR : TurnType.KR,leftSide);
    t.setSkipToSpeak(!speak);
  }
 else   if (otherRoutesExist && getTurnLanesString(prevSegm) != null) {
    t=TurnType.valueOf(TurnType.C,leftSide);
    t.setSkipToSpeak(true);
    int prevLanes=prevSegm.getObject().getLanes();
    if (prevSegm.getObject().getOneway() == 0) {
      prevLanes=countLanes(prevSegm,prevLanes);
    }
    if (prevLanes <= 0) {
      prevLanes=1;
    }
    t.setLanes(new int[prevLanes]);
    t=attachTurnLanesData(leftSide,prevSegm,t);
    for (int i=0; i < t.getLanes().length; i++) {
      if (TurnType.getPrimaryTurn(t.getLanes()[i]) == TurnType.C) {
        t.getLanes()[i]|=1;
      }
    }
    return t;
  }
  if (t != null && lanes != null) {
    t.setLanes(lanes);
    t=attachTurnLanesData(leftSide,prevSegm,t);
  }
  return t;
}
