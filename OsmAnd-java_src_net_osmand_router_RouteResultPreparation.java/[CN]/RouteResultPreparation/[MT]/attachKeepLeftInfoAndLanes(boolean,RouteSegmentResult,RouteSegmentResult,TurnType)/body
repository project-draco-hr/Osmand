{
  boolean kl=false;
  boolean kr=false;
  List<RouteSegmentResult> attachedRoutes=currentSegm.getAttachedRoutes(currentSegm.getStartPointIndex());
  int ls=prevSegm.getObject().getLanes();
  if (ls >= 0 && prevSegm.getObject().getOneway() == 0) {
    ls=(ls + 1) / 2;
  }
  int left=0;
  int right=0;
  boolean speak=false;
  int speakPriority=Math.max(highwaySpeakPriority(prevSegm.getObject().getHighway()),highwaySpeakPriority(currentSegm.getObject().getHighway()));
  boolean otherRoutesExist=false;
  if (attachedRoutes != null) {
    for (    RouteSegmentResult attached : attachedRoutes) {
      double ex=MapUtils.degreesDiff(attached.getBearingBegin(),currentSegm.getBearingBegin());
      double mpi=Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(),attached.getBearingBegin()));
      int rsSpeakPriority=highwaySpeakPriority(attached.getObject().getHighway());
      if (rsSpeakPriority != MAX_SPEAK_PRIORITY || speakPriority == MAX_SPEAK_PRIORITY) {
        if ((ex < TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex >= 0) {
          kl=true;
          right+=countLanesMinOne(attached);
          speak=speak || rsSpeakPriority <= speakPriority;
        }
 else         if ((ex > -TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex <= 0) {
          kr=true;
          left+=countLanesMinOne(attached);
          speak=speak || rsSpeakPriority <= speakPriority;
        }
 else         if (mpi >= TURN_DEGREE_MIN) {
          otherRoutesExist=true;
        }
      }
    }
  }
  if (kr && left == 0) {
    left=1;
  }
 else   if (kl && right == 0) {
    right=1;
  }
  int current=countLanesMinOne(currentSegm);
  int[] lanes=new int[current + left + right];
  ls=current + left + right;
  for (int it=0; it < ls; it++) {
    if (it < left || it >= left + current) {
      lanes[it]=0;
    }
 else {
      lanes[it]=1;
    }
  }
  if ((current <= left + right) && (left > 1 || right > 1)) {
    speak=true;
  }
  double devation=Math.abs(MapUtils.degreesDiff(prevSegm.getBearingEnd(),currentSegm.getBearingBegin()));
  boolean makeSlightTurn=devation > 5 && (!isMotorway(prevSegm) || !isMotorway(currentSegm));
  if (kl && kr) {
    t=TurnType.valueOf(TurnType.C,leftSide);
    t.setSkipToSpeak(!speak);
  }
 else   if (kl) {
    t=TurnType.valueOf(makeSlightTurn ? TurnType.TSLL : TurnType.KL,leftSide);
    t.setSkipToSpeak(!speak);
  }
 else   if (kr) {
    t=TurnType.valueOf(makeSlightTurn ? TurnType.TSLR : TurnType.KR,leftSide);
    t.setSkipToSpeak(!speak);
  }
 else   if (otherRoutesExist && getTurnLanesString(prevSegm) != null) {
    t=TurnType.valueOf(TurnType.C,leftSide);
    t.setSkipToSpeak(true);
    int prevLanes=countLanesMinOne(prevSegm);
    t.setLanes(attachTurnLanesData(prevSegm,new int[prevLanes]));
    for (int i=0; i < t.getLanes().length; i++) {
      if (TurnType.getPrimaryTurn(t.getLanes()[i]) == TurnType.C) {
        t.getLanes()[i]|=1;
      }
    }
    return t;
  }
  if (t != null && lanes != null) {
    int[] calcLanes=attachTurnLanesData(prevSegm,lanes);
    if (calcLanes != lanes) {
      int tp=inferTurnFromLanes(calcLanes);
      if (tp != 0 && tp != t.getValue()) {
        TurnType derivedTurnType=TurnType.valueOf(tp,leftSide);
        derivedTurnType.setLanes(calcLanes);
        derivedTurnType.setSkipToSpeak(t.isSkipToSpeak());
        for (int i=0; i < calcLanes.length; i++) {
          if (TurnType.getSecondaryTurn(calcLanes[i]) == tp) {
            derivedTurnType.setSecondaryTurn(i,TurnType.getPrimaryTurn(calcLanes[i]));
            derivedTurnType.setPrimaryTurn(i,tp);
          }
        }
      }
    }
    t.setLanes(calcLanes);
  }
  return t;
}
