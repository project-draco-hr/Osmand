{
  if (isLocationVisible(lastKnownLocation)) {
    int locationX=view.getMapXForPoint(lastKnownLocation.getLongitude());
    int locationY=view.getMapYForPoint(lastKnownLocation.getLatitude());
    int radius=MapUtils.getLengthXFromMeters(view.getFloatZoom(),view.getLatitude(),view.getLongitude(),lastKnownLocation.getAccuracy(),view.getTileSize(),view.getWidth());
    if (appMode == ApplicationMode.CAR) {
      if (!lastKnownLocation.hasBearing()) {
        canvas.drawCircle(locationX,locationY,RADIUS * 2.5f,location);
        canvas.drawCircle(locationX,locationY,RADIUS * 2.5f,bearingOver);
      }
    }
 else {
      canvas.drawCircle(locationX,locationY,RADIUS,location);
      canvas.drawCircle(locationX,locationY,RADIUS,bearingOver);
    }
    if (radius > RADIUS) {
      canvas.drawCircle(locationX,locationY,radius,area);
    }
    if (heading != null) {
      canvas.drawArc(getHeadingRect(locationX,locationY),heading - HEADING_ANGLE / 2 - 90,HEADING_ANGLE,true,headingPaint);
    }
    if (lastKnownLocation.hasBearing()) {
      float bearing=lastKnownLocation.getBearing();
      int radiusBearing=30;
      if (lastKnownLocation.hasSpeed()) {
        radiusBearing=Math.max(MapUtils.getLengthXFromMeters(view.getFloatZoom(),view.getLatitude(),view.getLongitude(),lastKnownLocation.getSpeed(),view.getTileSize(),view.getWidth()) * 2,radiusBearing);
      }
      radiusBearing+=RADIUS / 2;
      pathForDirection.reset();
      pathForDirection.moveTo(0,0);
      pathForDirection.lineTo((float)RADIUS,1f);
      pathForDirection.lineTo((float)-RADIUS,1f);
      pathForDirection.lineTo(0,0);
      Matrix m=new Matrix();
      m.reset();
      if (appMode == ApplicationMode.CAR) {
        m.postScale(2.5f,radiusBearing * 1.5f);
        m.postTranslate(0,-radiusBearing / 2);
      }
 else       if (appMode == ApplicationMode.BICYCLE) {
        m.postScale(2f,radiusBearing);
        m.postTranslate(0,-radiusBearing / 2);
      }
 else {
        m.postScale(1,radiusBearing * 0.5f);
        m.postTranslate(0,-radiusBearing);
      }
      m.postTranslate(locationX,locationY);
      m.postRotate(bearing,locationX,locationY);
      pathForDirection.transform(m);
      canvas.drawPath(pathForDirection,this.bearing);
      canvas.drawPath(pathForDirection,this.bearingOver);
    }
  }
}
