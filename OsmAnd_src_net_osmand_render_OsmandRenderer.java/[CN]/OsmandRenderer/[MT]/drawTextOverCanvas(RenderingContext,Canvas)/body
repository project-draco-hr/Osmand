{
  List<RectF> boundsNotPathIntersect=new ArrayList<RectF>();
  List<RectF> boundsPathIntersect=new ArrayList<RectF>();
  int size=rc.textToDraw.size();
  next:   for (int i=0; i < size; i++) {
    TextDrawInfo text=rc.textToDraw.get(i);
    if (text.text != null) {
      RectF bounds=new RectF();
      paintText.setTextSize(text.textSize);
      paintText.setFakeBoldText(text.bold);
      float mes=paintText.measureText(text.text);
      if (text.drawOnPath == null || (text.pathRotate > 45 && text.pathRotate < 135) || (text.pathRotate > 225 && text.pathRotate < 315)) {
        bounds.set(text.centerX - mes / 2,text.centerY - 3 * text.textSize / 2,text.centerX + mes / 2,text.centerY + 3 * text.textSize / 2);
      }
 else {
        bounds.set(text.centerX - 3 * text.textSize / 2,text.centerY - mes / 2,text.centerX + 3 * text.textSize / 2,text.centerY + mes / 2);
      }
      List<RectF> boundsIntersect=text.drawOnPath == null ? boundsNotPathIntersect : boundsPathIntersect;
      final int diff=3;
      final int diff2=15;
      for (int j=0; j < boundsIntersect.size(); j++) {
        RectF b=boundsIntersect.get(j);
        float x=Math.min(bounds.right,b.right) - Math.max(b.left,bounds.left);
        float y=Math.min(bounds.bottom,b.bottom) - Math.max(b.top,bounds.top);
        if ((x > diff && y > diff2) || (x > diff2 && y > diff)) {
          continue next;
        }
      }
      boundsIntersect.add(bounds);
      if (text.textShadow > 0 && text.shield) {
        paintText.setColor(Color.WHITE);
        paintText.setTextSize(text.textSize + text.textShadow * 2);
        if (text.drawOnPath != null) {
          cv.drawTextOnPath(text.text,text.drawOnPath,0,text.vOffset,paintText);
        }
 else {
          cv.drawText(text.text,text.centerX,text.centerY,paintText);
        }
        paintText.setTextSize(text.textSize);
      }
      paintText.setColor(text.textColor);
      if (text.drawOnPath != null) {
        cv.drawTextOnPath(text.text,text.drawOnPath,0,text.vOffset,paintText);
      }
 else       if (text.shield) {
        bounds.set(text.centerX - mes / 2 - 4,text.centerY - text.textSize,text.centerX + mes / 2 + 4,text.centerY + text.textSize / 2);
        paintShield.setStyle(Style.STROKE);
        paintShield.setColor(Color.WHITE);
        paintShield.setStrokeWidth(3);
        cv.drawOval(bounds,paintShield);
        paintShield.setStyle(Style.FILL);
        Color.colorToHSV(paintText.getColor(),hsv);
        hsv[2]*=0.85;
        paintShield.setColor(Color.HSVToColor(hsv));
        cv.drawOval(bounds,paintShield);
        paintText.setFakeBoldText(true);
        paintText.setColor(Color.WHITE);
        cv.drawText(text.text,text.centerX,text.centerY + 3,paintText);
      }
 else {
        if (text.textWrap == 0) {
          text.textWrap=40;
        }
        if (text.text.length() > text.textWrap) {
          int start=0;
          int end=text.text.length();
          int lastSpace=-1;
          int line=0;
          int pos=0;
          int limit=0;
          while (pos < end) {
            lastSpace=-1;
            limit+=text.textWrap;
            while (pos < limit && pos < end) {
              if (!Character.isLetterOrDigit(text.text.charAt(pos))) {
                lastSpace=pos;
              }
              pos++;
            }
            if (lastSpace == -1) {
              cv.drawText(text.text.substring(start,pos),text.centerX,text.centerY + line * (text.textSize + 2),paintText);
              start=pos;
            }
 else {
              cv.drawText(text.text.substring(start,lastSpace),text.centerX,text.centerY + line * (text.textSize + 2),paintText);
              start=lastSpace + 1;
              limit+=(start - pos) - 1;
            }
            line++;
          }
        }
 else {
          cv.drawText(text.text,text.centerX,text.centerY,paintText);
        }
      }
    }
  }
}
