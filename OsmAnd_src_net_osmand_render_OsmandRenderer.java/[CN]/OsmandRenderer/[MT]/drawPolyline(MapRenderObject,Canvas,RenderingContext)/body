{
  int type=MapRenderingTypes.getObjectType(obj.getType());
  int subtype=MapRenderingTypes.getPolylineSubType(obj.getType());
  PolylineRenderer.renderPolyline(type,subtype,obj.getType(),rc,this);
  if (rc.strokeWidth == 0) {
    return;
  }
  int length=obj.getPointsLength();
  if (length < 2) {
    return;
  }
  Path path=null;
  float pathRotate=0;
  float xLength=0;
  float yLength=0;
  boolean inverse=false;
  float xPrev=0;
  float yPrev=0;
  float xMid=0;
  float yMid=0;
  int middle=obj.getPointsLength() / 2;
  for (int i=0; i < length; i++) {
    PointF p=calcPoint(obj,i,rc);
    if (i == 0 || i == length - 1) {
      xMid+=p.x;
      yMid+=p.y;
    }
    if (path == null) {
      path=new Path();
      path.moveTo(p.x,p.y);
    }
 else {
      xLength+=p.x - xPrev;
      yLength+=p.y - yPrev;
      if (i == middle) {
        double rot=-Math.atan2(p.x - xPrev,p.y - yPrev) * 180 / Math.PI;
        if (rot < 0) {
          rot+=360;
        }
        if (rot < 180) {
          rot+=180;
          inverse=true;
        }
        pathRotate=(float)rot;
      }
      path.lineTo(p.x,p.y);
    }
    xPrev=p.x;
    yPrev=p.y;
  }
  if (path != null) {
    paintStroke.setPathEffect(rc.pathEffect);
    if (paintStroke.getShader() != null) {
      paintStroke.setShader(null);
    }
    paintStroke.setShadowLayer(rc.shadowLayer,0,0,rc.shadowColor);
    paintStroke.setColor(rc.color);
    paintStroke.setStrokeWidth(rc.strokeWidth);
    canvas.drawPath(path,paintStroke);
    if (rc.secondStrokeWidth > 0) {
      paintStroke.setPathEffect(rc.secondEffect);
      paintStroke.setShader(null);
      if (rc.shadowLayer != 0) {
        paintStroke.setShadowLayer(0,0,0,0);
      }
      paintStroke.setColor(rc.secondColor);
      paintStroke.setStrokeWidth(rc.secondStrokeWidth);
      canvas.drawPath(path,paintStroke);
    }
    if (type == MapRenderingTypes.HIGHWAY && rc.zoom >= 16 && MapRenderingTypes.isOneWayWay(obj.getType())) {
      if (rc.shadowLayer != 0) {
        paintStroke.setShadowLayer(0,0,0,0);
      }
      drawOneWayDirections(canvas,path);
    }
    if (obj.getName() != null && rc.showText) {
      float w=rc.strokeWidth + 3;
      if (w < 10) {
        w=10;
      }
      paintText.setTextSize(w);
      if (paintText.measureText(obj.getName()) < Math.max(Math.abs(xLength),Math.abs(yLength))) {
        if (inverse) {
          path.rewind();
          boolean st=true;
          for (int i=obj.getPointsLength() - 1; i >= 0; i--) {
            PointF p=calcPoint(obj,i,rc);
            if (st) {
              st=false;
              path.moveTo(p.x,p.y);
            }
 else {
              path.lineTo(p.x,p.y);
            }
          }
        }
        TextDrawInfo text=new TextDrawInfo();
        text.text=obj.getName();
        text.centerX=xMid / 2;
        text.centerY=yMid / 2;
        text.pathRotate=pathRotate;
        text.drawOnPath=path;
        text.textColor=Color.BLACK;
        text.textSize=w;
        text.vOffset=rc.strokeWidth / 2 - 1;
        rc.textToDraw.add(text);
      }
    }
  }
}
