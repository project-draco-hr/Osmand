{
  List<RectF> boundsNotPathIntersect=new ArrayList<RectF>();
  List<RectF> boundsPathIntersect=new ArrayList<RectF>();
  int size=rc.textToDraw.size();
  Comparator<RectF> c=new Comparator<RectF>(){
    @Override public int compare(    RectF object1,    RectF object2){
      return Float.compare(object1.left,object2.left);
    }
  }
;
  next:   for (int i=0; i < size; i++) {
    TextDrawInfo text=rc.textToDraw.get(i);
    if (text.text != null) {
      int d=text.text.indexOf(MapRenderingTypes.DELIM_CHAR);
      if (d > 0) {
        text.text=text.text.substring(0,d);
      }
      if (useEnglishNames) {
        text.text=Junidecode.unidecode(text.text);
      }
      RectF bounds=new RectF();
      paintText.setTextSize(text.textSize * dm.density);
      paintText.setFakeBoldText(text.bold);
      float mes=paintText.measureText(text.text);
      if (text.drawOnPath == null || (text.pathRotate > 45 && text.pathRotate < 135) || (text.pathRotate > 225 && text.pathRotate < 315)) {
        bounds.set(text.centerX - mes / 2,text.centerY - 3 * text.textSize / 2,text.centerX + mes / 2,text.centerY + 3 * text.textSize / 2);
      }
 else {
        bounds.set(text.centerX - 3 * text.textSize,text.centerY - mes,text.centerX + 3 * text.textSize,text.centerY + mes);
      }
      if (text.minDistance > 0) {
        bounds.set(bounds.left - text.minDistance / 2,bounds.top - text.minDistance / 2,bounds.right + text.minDistance / 2,bounds.bottom + text.minDistance / 2);
      }
      List<RectF> boundsIntersect=text.drawOnPath == null || findAllTextIntersections ? boundsNotPathIntersect : boundsPathIntersect;
      if (boundsIntersect.isEmpty()) {
        boundsIntersect.add(bounds);
      }
 else {
        final int diff=(int)(3 * dm.density);
        final int diff2=(int)(15 * dm.density);
        int index=Collections.binarySearch(boundsIntersect,bounds,c);
        if (index < 0) {
          index=-(index + 1);
        }
        int e=index;
        while (e < boundsIntersect.size()) {
          if (boundsIntersect.get(e).left < bounds.right) {
            e++;
          }
 else {
            break;
          }
        }
        int st=index - 1;
        while (st >= 0) {
          if (boundsIntersect.get(st).right > bounds.left) {
            st--;
          }
 else {
            break;
          }
        }
        if (st < 0) {
          st=0;
        }
        for (int j=st; j < e; j++) {
          RectF b=boundsIntersect.get(j);
          float x=Math.min(bounds.right,b.right) - Math.max(b.left,bounds.left);
          float y=Math.min(bounds.bottom,b.bottom) - Math.max(b.top,bounds.top);
          if ((x > diff && y > diff2) || (x > diff2 && y > diff)) {
            continue next;
          }
        }
        if (text.minDistance > 0) {
          bounds.set(bounds.left + text.minDistance / 2,bounds.top + text.minDistance / 2,bounds.right - text.minDistance / 2,bounds.bottom - text.minDistance / 2);
        }
        boundsIntersect.add(index,bounds);
      }
      paintText.setColor(text.textColor);
      if (text.drawOnPath != null) {
        cv.drawTextOnPath(text.text,text.drawOnPath,0,text.vOffset,paintText);
      }
 else {
        if (text.textWrap == 0) {
          text.textWrap=40;
        }
        if (text.shieldRes != 0) {
          if (cachedIcons.get(text.shieldRes) == null) {
            cachedIcons.put(text.shieldRes,BitmapFactory.decodeResource(context.getResources(),text.shieldRes));
          }
          Bitmap ico=cachedIcons.get(text.shieldRes);
          if (ico != null) {
            cv.drawBitmap(ico,text.centerX - ico.getWidth() / 2 - 0.5f * dm.density,text.centerY - text.textSize - 2 * dm.density,paintIcon);
          }
        }
        if (text.text.length() > text.textWrap) {
          int start=0;
          int end=text.text.length();
          int lastSpace=-1;
          int line=0;
          int pos=0;
          int limit=0;
          while (pos < end) {
            lastSpace=-1;
            limit+=text.textWrap;
            while (pos < limit && pos < end) {
              if (!Character.isLetterOrDigit(text.text.charAt(pos))) {
                lastSpace=pos;
              }
              pos++;
            }
            if (lastSpace == -1) {
              cv.drawText(text.text.substring(start,pos),text.centerX,text.centerY + line * (text.textSize + 2),paintText);
              start=pos;
            }
 else {
              cv.drawText(text.text.substring(start,lastSpace),text.centerX,text.centerY + line * (text.textSize + 2),paintText);
              start=lastSpace + 1;
              limit+=(start - pos) - 1;
            }
            line++;
          }
        }
 else {
          cv.drawText(text.text,text.centerX,text.centerY,paintText);
        }
      }
    }
  }
}
