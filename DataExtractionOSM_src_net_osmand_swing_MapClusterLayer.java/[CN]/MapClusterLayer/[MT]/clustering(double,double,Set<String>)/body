{
  List<Way> res=new ArrayList<Way>();
  File[] files=DataExtractionSettings.getSettings().getDefaultRoutingFile();
  BinaryMapIndexReader[] rs=new BinaryMapIndexReader[files.length];
  for (int i=0; i < files.length; i++) {
    RandomAccessFile raf=new RandomAccessFile(files[i],"r");
    rs[i]=new BinaryMapIndexReader(raf,true);
  }
  BinaryRoutePlanner router=new BinaryRoutePlanner(rs);
  RoutingContext ctx=new RoutingContext();
  RouteSegment st=router.findRouteSegment(lat,lon,ctx);
  if (st != null) {
    BinaryMapDataObject road=st.getRoad();
    TagValuePair pair=road.getTagValue(0);
    System.out.println("ROAD TO START " + pair.tag + " "+ pair.value+ " "+ road.getName()+ " "+ (road.getId() >> 3));
  }
  final DataTileManager<Way> points=new DataTileManager<Way>();
  points.setZoom(11);
  map.setPoints(points);
  ctx.setVisitor(new RouteSegmentVisitor(){
    private List<RouteSegment> cache=new ArrayList<RouteSegment>();
    @Override public void visitSegment(    RouteSegment s){
      if (!ANIMATE_CLUSTERING) {
        return;
      }
      cache.add(s);
      if (cache.size() < SIZE_OF_ROUTES_TO_ANIMATE) {
        return;
      }
      for (      RouteSegment segment : cache) {
        Way way=new Way(-1);
        for (int i=0; i < segment.getRoad().getPointsLength(); i++) {
          net.osmand.osm.Node n=new net.osmand.osm.Node(MapUtils.get31LatitudeY(segment.getRoad().getPoint31YTile(i)),MapUtils.get31LongitudeX(segment.getRoad().getPoint31XTile(i)),-1);
          way.addNode(n);
        }
        LatLon n=way.getLatLon();
        points.registerObject(n.getLatitude(),n.getLongitude(),way);
      }
      cache.clear();
      try {
        SwingUtilities.invokeAndWait(new Runnable(){
          @Override public void run(){
            map.prepareImage();
          }
        }
);
      }
 catch (      InterruptedException e1) {
      }
catch (      InvocationTargetException e) {
        e.printStackTrace();
      }
    }
  }
);
  searchCluster(ctx,st,router,res,roads);
  if (ANIMATE_CLUSTERING) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e1) {
    }
  }
  return res;
}
