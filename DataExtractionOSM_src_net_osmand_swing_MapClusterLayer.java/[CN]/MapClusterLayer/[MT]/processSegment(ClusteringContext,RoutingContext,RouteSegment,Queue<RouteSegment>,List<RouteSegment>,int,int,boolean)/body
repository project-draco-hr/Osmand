{
  int d=1;
  boolean directionAllowed=true;
  int prev=segment.getSegmentStart();
  while (directionAllowed) {
    int segmentEnd=segment.getSegmentStart() + (direction ? d : -d);
    d++;
    if (segmentEnd < 0 || segmentEnd >= segment.getRoad().getPointsLength()) {
      directionAllowed=false;
      continue;
    }
    int x=segment.getRoad().getPoint31XTile(segmentEnd);
    int y=segment.getRoad().getPoint31YTile(segmentEnd);
    int tX=x >> cCtx.zm;
    int tY=y >> cCtx.zm;
    cCtx.segmentsProcessed++;
    if (notClusterAtAll(cCtx,segment.getRoad())) {
      cCtx.outOfTile++;
      addSegmentResult(result,segment,prev,segmentEnd);
      return;
    }
    if (isMajorHighway(cCtx,segment.getRoad().getHighway()) && (Math.abs(tX - tileX) > cCtx.TILE_BOUNDARIES || Math.abs(tY - tileY) < cCtx.TILE_BOUNDARIES)) {
      cCtx.outOfDistance++;
      addSegmentResult(result,segment,prev,segmentEnd);
      return;
    }
 else     if (Math.abs(tX - tileX) > cCtx.LOCAL_TILE_BOUNDARIES || Math.abs(tY - tileY) > cCtx.LOCAL_TILE_BOUNDARIES) {
      cCtx.outOfDistance++;
      addSegmentResult(result,segment,prev,segmentEnd);
      return;
    }
    RouteSegment next=ctx.loadRouteSegment(x,y,0);
    while (next != null) {
      queue.add(next);
      next=next.getNext();
    }
    prev=segmentEnd;
  }
}
