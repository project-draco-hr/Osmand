{
  List<Way> res=new ArrayList<Way>();
  List<BinaryMapIndexReader> rs=new ArrayList<BinaryMapIndexReader>();
  for (  File f : new File(DataExtractionSettings.getSettings().getBinaryFilesDir()).listFiles()) {
    if (f.getName().endsWith(".obf")) {
      RandomAccessFile raf=new RandomAccessFile(f,"r");
      rs.add(new BinaryMapIndexReader(raf,false));
    }
  }
  BinaryRoutePlanner router=new BinaryRoutePlanner(NativeSwingRendering.getDefaultFromSettings(),rs.toArray(new BinaryMapIndexReader[rs.size()]));
  Builder builder=RoutingConfiguration.getDefault();
  RoutingConfiguration config=builder.build("car");
  config.NUMBER_OF_DESIRABLE_TILES_IN_MEMORY=300;
  RoutingContext ctx=new RoutingContext(config);
  RouteSegment st=router.findRouteSegment(lat,lon,ctx);
  if (st != null) {
    RouteDataObject road=st.getRoad();
    String highway=getHighway(road);
    log.info("ROAD TO START " + highway + " "+ +road.id);
  }
  final DataTileManager<Way> points=new DataTileManager<Way>();
  points.setZoom(11);
  map.setPoints(points);
  ctx.setVisitor(new RouteSegmentVisitor(){
    private List<RouteSegment> cache=new ArrayList<RouteSegment>();
    @Override public void visitSegment(    RouteSegment s,    boolean poll){
      if (!ANIMATE_CLUSTERING) {
        return;
      }
      cache.add(s);
      if (cache.size() < SIZE_OF_ROUTES_TO_ANIMATE) {
        return;
      }
      for (      RouteSegment segment : cache) {
        Way way=new Way(-1);
        for (int i=0; i < segment.getRoad().getPointsLength(); i++) {
          net.osmand.osm.Node n=new net.osmand.osm.Node(MapUtils.get31LatitudeY(segment.getRoad().getPoint31YTile(i)),MapUtils.get31LongitudeX(segment.getRoad().getPoint31XTile(i)),-1);
          way.addNode(n);
        }
        LatLon n=way.getLatLon();
        points.registerObject(n.getLatitude(),n.getLongitude(),way);
      }
      cache.clear();
      try {
        SwingUtilities.invokeAndWait(new Runnable(){
          @Override public void run(){
            map.prepareImage();
          }
        }
);
      }
 catch (      InterruptedException e1) {
      }
catch (      InvocationTargetException e) {
        e.printStackTrace();
      }
    }
  }
);
  searchCluster(ctx,st,router,res);
  if (ANIMATE_CLUSTERING) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e1) {
    }
  }
  return res;
}
