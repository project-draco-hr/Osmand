{
  Queue<RouteSegment> queue=new LinkedList<RouteSegment>();
  TLongHashSet visitedIds=new TLongHashSet();
  queue.add(st);
  RouteDataObject startRoad=st.getRoad();
  long lstart=(((long)startRoad.getPoint31XTile(st.getSegmentStart())) << 31) + (long)startRoad.getPoint31YTile(st.getSegmentStart());
  int zlimit=13;
  int zm=31 - zlimit;
  int tileX=startRoad.getPoint31XTile(st.getSegmentStart()) >> zm;
  int tileY=startRoad.getPoint31YTile(st.getSegmentStart()) >> zm;
  RouteSegment next=ctx.getRoutingTile((int)lstart >> 31,(int)(lstart - (lstart >> 31) << 31)).getSegment(lstart,ctx);
  while (next != null) {
    if (next.getRoad().getId() != st.getRoad().getId()) {
      queue.add(next);
    }
    next=next.getNext();
  }
  int outOfTile=0;
  int segmentsProcessed=0;
  float minRatio=1f;
  TLongHashSet onTheMap=new TLongHashSet();
  nextSegment:   while (!queue.isEmpty()) {
    RouteSegment segment=queue.poll();
    RouteDataObject road=segment.getRoad();
    segmentsProcessed++;
    if (visitedIds.contains(calculateId(segment,segment.getSegmentStart()))) {
      continue;
    }
    if (segmentsProcessed > 50) {
      minRatio=Math.min(minRatio,(float)(queue.size() + outOfTile) / segmentsProcessed);
    }
    visitedIds.add(calculateId(segment,segment.getSegmentStart()));
    Way w=new Way(-1);
    res.add(w);
    int xst=road.getPoint31XTile(segment.getSegmentStart());
    int yst=road.getPoint31YTile(segment.getSegmentStart());
    w.addNode(new Node(MapUtils.get31LatitudeY(yst),MapUtils.get31LongitudeX(xst),-1));
    boolean minusAllowed=true;
    boolean plusAllowed=true;
    int d=1;
    while (minusAllowed || plusAllowed) {
      int segmentEnd=segment.getSegmentStart() + d;
      int currentD=d;
      if (!minusAllowed && d > 0) {
        d++;
      }
 else       if (!plusAllowed && d < 0) {
        d--;
      }
 else {
        if (d <= 0) {
          d=-d + 1;
        }
 else {
          d=-d;
        }
      }
      if (segmentEnd < 0) {
        minusAllowed=false;
        continue;
      }
      if (segmentEnd >= road.getPointsLength()) {
        plusAllowed=false;
        continue;
      }
      if (visitedIds.contains(calculateId(segment,segmentEnd))) {
        if (currentD > 0) {
          plusAllowed=false;
        }
 else {
          minusAllowed=false;
        }
        continue;
      }
      visitedIds.add(calculateId(segment,segmentEnd));
      int x=road.getPoint31XTile(segmentEnd);
      int y=road.getPoint31YTile(segmentEnd);
      if (segmentEnd > segment.getSegmentStart()) {
        w.addNode(new Node(MapUtils.get31LatitudeY(y),MapUtils.get31LongitudeX(x),-1));
      }
 else {
        w.addNode(new Node(MapUtils.get31LatitudeY(y),MapUtils.get31LongitudeX(x),-1),0);
      }
      router.loadRoutes(ctx,x,y);
      long l=(((long)x) << 31) + (long)y;
      next=ctx.getRoutingTile(x,y).getSegment(l,ctx);
      RouteSegment toAdd=segment;
      if (!onTheMap.contains(toAdd.getRoad().getId())) {
        onTheMap.add(toAdd.getRoad().getId());
        ctx.getVisitor().visitSegment(toAdd,true);
      }
      while (next != null) {
        if (!visitedIds.contains(calculateId(next,next.getSegmentStart()))) {
          int tX=next.getRoad().getPoint31XTile(next.getSegmentStart()) >> zm;
          int tY=next.getRoad().getPoint31YTile(next.getSegmentStart()) >> zm;
          String highway=next.getRoad().getHighway();
          if (tX == tileX && tY == tileY) {
            queue.add(next);
          }
 else {
            double r=1;
            if (!isMajorHighway(highway) && Math.abs(tX - tileX) < (2 * r) && Math.abs(tY - tileY) < (2 * r)) {
              queue.add(next);
            }
 else {
              outOfTile++;
            }
          }
        }
        next=next.getNext();
      }
    }
  }
  System.out.println("Current ratio " + ((float)outOfTile / segmentsProcessed) + " min ratio "+ minRatio);
  System.out.println("Processed " + segmentsProcessed + " and borders are "+ outOfTile);
  return null;
}
