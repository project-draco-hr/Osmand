{
  List<RouteSegment> result=new ArrayList<BinaryRoutePlanner.RouteSegment>();
  TLongHashSet visitedIds=new TLongHashSet();
  RouteDataObject startRoad=st.getRoad();
  final int stx=startRoad.getPoint31XTile(st.getSegmentStart());
  final int sty=startRoad.getPoint31YTile(st.getSegmentStart());
  int tileX=startRoad.getPoint31XTile(st.getSegmentStart()) >> cCtx.zm;
  int tileY=startRoad.getPoint31YTile(st.getSegmentStart()) >> cCtx.zm;
  Queue<RouteSegment> queue=new PriorityQueue<RouteSegment>(50,new Comparator<RouteSegment>(){
    @Override public int compare(    RouteSegment o1,    RouteSegment o2){
      double d1=MapUtils.squareDist31TileMetric(stx,sty,o1.getRoad().getPoint31XTile(o1.getSegmentStart()),o1.getRoad().getPoint31YTile(o1.getSegmentStart()));
      double d2=MapUtils.squareDist31TileMetric(stx,sty,o2.getRoad().getPoint31XTile(o2.getSegmentStart()),o2.getRoad().getPoint31YTile(o2.getSegmentStart()));
      return Double.compare(d1,d2);
    }
  }
);
  queue.add(st);
  while (!queue.isEmpty()) {
    RouteSegment segment=queue.poll();
    if (visitedIds.contains(calculateId(segment))) {
      continue;
    }
    visitedIds.add(calculateId(segment));
    if (ctx.getVisitor() != null) {
      ctx.getVisitor().visitSegment(segment,-1,true);
    }
    cCtx.roadProcessed++;
    if (cCtx.roadProcessed > 50) {
      float ratio=(float)(queue.size() + cCtx.outOfTile + cCtx.outOfDistance) / cCtx.segmentsProcessed;
      if (ratio < cCtx.minRatio) {
        cCtx.minRatio=ratio;
        cCtx.roadMinProcessed=cCtx.roadProcessed;
      }
    }
    processSegment(cCtx,ctx,segment,queue,result,tileX,tileY,true);
    processSegment(cCtx,ctx,segment,queue,result,tileX,tileY,false);
  }
  System.out.println("Current ratio " + ((float)(queue.size() + cCtx.outOfTile + cCtx.outOfDistance) / cCtx.segmentsProcessed) + " min ratio "+ cCtx.minRatio+ " min segments procesed "+ cCtx.roadMinProcessed);
  String res="Processed " + cCtx.roadProcessed + " / "+ cCtx.segmentsProcessed+ " and borders are "+ (cCtx.outOfTile + cCtx.outOfDistance)+ " out because of distance "+ cCtx.outOfDistance;
  log.info(res);
  return result;
}
