{
  int tileC=tileX << ZOOM_LOAD_TILES + tileY;
  if (ctx.loadedTiles.contains(tileC)) {
    return;
  }
  SearchRequest<BinaryMapDataObject> request=new SearchRequest<BinaryMapDataObject>();
  request.left=tileX << (31 - ZOOM_LOAD_TILES);
  request.right=(tileX + 1) << (31 - ZOOM_LOAD_TILES);
  request.top=tileY << (31 - ZOOM_LOAD_TILES);
  request.bottom=(tileY + 1) << (31 - ZOOM_LOAD_TILES);
  request.zoom=15;
  request.setSearchFilter(new BinaryMapIndexReader.SearchFilter(){
    @Override public boolean accept(    TIntArrayList types,    MapIndex index){
      for (int j=0; j < types.size(); j++) {
        int wholeType=types.get(j);
        TagValuePair pair=index.decodeType(wholeType);
        if (pair != null) {
          int t=wholeType & 3;
          if (t == MapRenderingTypes.POINT_TYPE) {
            if (ctx.router.acceptPoint(pair)) {
              return true;
            }
          }
 else           if (t == MapRenderingTypes.POLYLINE_TYPE) {
            if (ctx.router.acceptLine(pair)) {
              return true;
            }
          }
        }
      }
      return false;
    }
  }
);
  map.searchMapIndex(request);
  for (  BinaryMapDataObject o : request.searchResults) {
    if (ctx.idObjects.containsKey(o.getId())) {
      continue;
    }
    ctx.idObjects.put(o.getId(),o);
    for (int j=0; j < o.getPointsLength(); j++) {
      long l=(((long)o.getPoint31XTile(j)) << 31) + (long)o.getPoint31YTile(j);
      RouteSegment segment=new RouteSegment();
      segment.road=o;
      segment.segmentEnd=segment.segmentStart=j;
      if (ctx.routes.get(l) != null) {
        segment.next=ctx.routes.get(l);
      }
      ctx.routes.put(l,segment);
    }
  }
  ctx.loadedTiles.add(tileC);
}
