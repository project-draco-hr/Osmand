{
  List<RouteSegmentResult> result=new ArrayList<RouteSegmentResult>();
  long now=System.currentTimeMillis();
  PriorityQueue<RouteSegment> graphSegments=new PriorityQueue<RouteSegment>(50,new Comparator<RouteSegment>(){
    @Override public int compare(    RouteSegment o1,    RouteSegment o2){
      return Double.compare(o1.distanceFromStart + o1.distanceToEnd,o2.distanceFromStart + o2.distanceToEnd);
    }
  }
);
  TLongHashSet visitedPoints=new TLongHashSet();
  graphSegments.add(start);
  RouteSegment endRoute=null;
  int endX=end.road.getPoint31XTile(end.segmentEnd);
  int endY=end.road.getPoint31YTile(end.segmentEnd);
  int startX=start.road.getPoint31XTile(start.segmentStart);
  int startY=start.road.getPoint31YTile(start.segmentStart);
  start.distanceToEnd=squareRootDist(startX,startY,endX,endY) / 10;
  while (!graphSegments.isEmpty() && endRoute == null) {
    RouteSegment segment=graphSegments.poll();
    BinaryMapDataObject road=segment.road;
    boolean oneway=ctx.router.isOneWay(road.getHighwayAttributes());
    int middle=segment.segmentEnd;
    boolean minus=true;
    boolean plus=true;
    int d=0;
    int middlex=road.getPoint31XTile(middle);
    int middley=road.getPoint31YTile(middle);
    double trafficSignalsTime=0;
    while (endRoute == null && ((!oneway && minus) || plus)) {
      int j=middle + d;
      if (oneway) {
        d++;
      }
 else {
        if (d <= 0) {
          d=-d + 1;
        }
 else {
          d=-d;
        }
      }
      if (j < 0) {
        minus=false;
        continue;
      }
      if (j >= road.getPointsLength()) {
        plus=false;
        continue;
      }
      if (end.road.id == road.id && end.segmentStart == j) {
        endRoute=segment;
        break;
      }
      long l=(((long)road.getPoint31XTile(j)) << 31) + (long)road.getPoint31YTile(j);
      if (visitedPoints.contains(l)) {
        continue;
      }
      loadRoutes(ctx,(road.getPoint31XTile(j) >> (31 - ZOOM_LOAD_TILES)),(road.getPoint31YTile(j) >> (31 - ZOOM_LOAD_TILES)));
      RouteSegment next=ctx.routes.get(l);
      if (next != null) {
        visitedPoints.add(l);
        if (d != 0) {
          RouteSegment trafficSignalsTest=next;
          while (trafficSignalsTest != null) {
            if ((trafficSignalsTest.road.getTypes()[0] & 3) == MapRenderingTypes.POINT_TYPE) {
              TagValuePair pair=trafficSignalsTest.road.getTagValue(0);
              if (pair != null && pair.tag.equals("highway") && pair.value.equals("traffic_signals")) {
                trafficSignalsTime+=25;
              }
            }
            trafficSignalsTest=trafficSignalsTest.next;
          }
        }
      }
      while (next != null) {
        if (next.road.id != road.id) {
          next.parentRoute=segment;
          next.parentSegmentEnd=j;
          int x=road.getPoint31XTile(j);
          int y=road.getPoint31YTile(j);
          double speed=ctx.router.defineSpeed(road);
          if (speed == 0) {
            speed=ctx.router.getMinDefaultSpeed();
          }
          next.distanceFromStart=segment.distanceFromStart + squareRootDist(x,y,middlex,middley) / speed;
          if (j < road.getPointsLength() - 1) {
            next.distanceFromStart+=30;
          }
          next.distanceFromStart+=trafficSignalsTime;
          next.distanceToEnd=squareRootDist(x,y,endX,endY) / 30;
          graphSegments.add(next);
        }
        next=next.next;
      }
    }
  }
  int parentSegmentEnd=endRoute != null && endRoute.segmentStart <= end.segmentStart ? end.segmentEnd : end.segmentStart;
  RouteSegment segment=endRoute;
  while (segment != null) {
    RouteSegmentResult res=new RouteSegmentResult();
    res.object=segment.road;
    res.endPointIndex=parentSegmentEnd;
    res.startPointIndex=segment.segmentStart;
    parentSegmentEnd=segment.parentSegmentEnd;
    System.out.println(segment.road.name + " time to go " + (segment.distanceFromStart / 60)+ " estimate time "+ (segment.distanceToEnd / 60));
    segment=segment.parentRoute;
    if (res.startPointIndex != res.endPointIndex) {
      result.add(0,res);
      if (segment == null && res.startPointIndex > res.endPointIndex) {
        res.startPointIndex=start.segmentEnd;
      }
    }
    res.startPoint=convertPoint(res.object,res.startPointIndex);
    res.endPoint=convertPoint(res.object,res.endPointIndex);
  }
  ctx.timeToCalculate=(int)(System.currentTimeMillis() - now);
  System.out.println("Time to calculate : " + ctx.timeToCalculate + ", time to load : "+ ctx.timeToLoad+ ", loaded tiles : "+ ctx.loadedTiles.size());
  return result;
}
