{
  List<RouteSegmentResult> result=new ArrayList<RouteSegmentResult>();
  ctx.timeToLoad=0;
  long now=System.nanoTime();
  PriorityQueue<RouteSegment> graphSegments=new PriorityQueue<RouteSegment>(50,new Comparator<RouteSegment>(){
    @Override public int compare(    RouteSegment o1,    RouteSegment o2){
      return Double.compare(o1.distanceFromStart + o1.distanceToEnd,o2.distanceFromStart + o2.distanceToEnd);
    }
  }
);
  ArrayList<RouteSegment> segmentsToVisitPrescricted=new ArrayList<RouteSegment>(5);
  ArrayList<RouteSegment> segmentsToVisitNotForbidden=new ArrayList<RouteSegment>(5);
  TLongHashSet visitedSegments=new TLongHashSet();
  int endX=end.road.getPoint31XTile(end.segmentEnd);
  int endY=end.road.getPoint31YTile(end.segmentEnd);
  int startX=start.road.getPoint31XTile(start.segmentStart);
  int startY=start.road.getPoint31YTile(start.segmentStart);
  start.distanceToEnd=squareRootDist(startX,startY,endX,endY) / ctx.router.getMaxDefaultSpeed();
  graphSegments.add(start);
  long ls=(((long)startX) << 31) + (long)startY;
  RouteSegment startNbs=ctx.routes.get(ls);
  while (startNbs != null) {
    if (startNbs.road.id != start.road.id) {
      startNbs.parentRoute=start;
      startNbs.parentSegmentEnd=start.segmentStart;
      startNbs.distanceToEnd=start.distanceToEnd;
      long nt=(startNbs.road.id << 8l) + startNbs.segmentStart;
      visitedSegments.add(nt);
      graphSegments.add(startNbs);
    }
    startNbs=startNbs.next;
  }
  RouteSegment finalRoute=null;
  while (!graphSegments.isEmpty() && finalRoute == null) {
    RouteSegment segment=graphSegments.poll();
    BinaryMapDataObject road=segment.road;
    int middle=segment.segmentStart;
    int middlex=road.getPoint31XTile(middle);
    int middley=road.getPoint31YTile(middle);
    int d=1;
    boolean oneway=ctx.router.isOneWay(road.getHighwayAttributes());
    boolean minus=true;
    boolean plus=true;
    if (end.road.id == road.id && end.segmentStart == middle) {
      finalRoute=segment;
    }
    double obstaclesTime=0;
    while (finalRoute == null && ((!oneway && minus) || plus)) {
      int j=middle + d;
      if (oneway) {
        d++;
      }
 else {
        if (d <= 0) {
          d=-d + 1;
        }
 else {
          d=-d;
        }
      }
      if (j < 0) {
        minus=false;
        continue;
      }
      if (j >= road.getPointsLength()) {
        plus=false;
        continue;
      }
      if (end.road.id == road.id && end.segmentStart == j) {
        finalRoute=segment;
        break;
      }
      long l=(((long)road.getPoint31XTile(j)) << 31) + (long)road.getPoint31YTile(j);
      loadRoutes(ctx,(road.getPoint31XTile(j) >> (31 - ZOOM_LOAD_TILES)),(road.getPoint31YTile(j) >> (31 - ZOOM_LOAD_TILES)));
      RouteSegment next=ctx.routes.get(l);
      if (next != null) {
        segmentsToVisitPrescricted.clear();
        segmentsToVisitNotForbidden.clear();
        boolean exclusiveRestriction=false;
        if (d != 0) {
          RouteSegment possibleObstacle=next;
          while (possibleObstacle != null) {
            ctx.router.defineObstacle(possibleObstacle.road,possibleObstacle.segmentStart);
            possibleObstacle=possibleObstacle.next;
          }
        }
        while (next != null) {
          long nt=(next.road.id << 8l) + next.segmentStart;
          if (next.road.id != road.id && !visitedSegments.contains(nt)) {
            int type=-1;
            for (int i=0; i < road.getRestrictionCount(); i++) {
              if (road.getRestriction(i) == next.road.id) {
                type=road.getRestrictionType(i);
                break;
              }
            }
            if (type == -1 && exclusiveRestriction) {
            }
 else             if (type == MapRenderingTypes.RESTRICTION_NO_LEFT_TURN || type == MapRenderingTypes.RESTRICTION_NO_RIGHT_TURN || type == MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON || type == MapRenderingTypes.RESTRICTION_NO_U_TURN) {
            }
 else {
              next.parentRoute=segment;
              next.parentSegmentEnd=j;
              int x=road.getPoint31XTile(j);
              int y=road.getPoint31YTile(j);
              double speed=ctx.router.defineSpeed(road);
              if (speed == 0) {
                speed=ctx.router.getMinDefaultSpeed();
              }
              next.distanceFromStart=segment.distanceFromStart + squareRootDist(x,y,middlex,middley) / speed;
              next.distanceFromStart+=ctx.router.calculateTurnTime(middley,middlex,x,y,segment,next,j);
              next.distanceFromStart+=obstaclesTime;
              next.distanceToEnd=squareRootDist(x,y,endX,endY) / ctx.router.getMaxDefaultSpeed();
              if (type == -1) {
                segmentsToVisitNotForbidden.add(next);
              }
 else {
                exclusiveRestriction=true;
                segmentsToVisitNotForbidden.clear();
                segmentsToVisitPrescricted.add(next);
              }
            }
          }
          next=next.next;
        }
        for (        RouteSegment s : segmentsToVisitNotForbidden) {
          long nt=(s.road.id << 8l) + s.segmentStart;
          visitedSegments.add(nt);
          graphSegments.add(s);
        }
        for (        RouteSegment s : segmentsToVisitPrescricted) {
          long nt=(s.road.id << 8l) + s.segmentStart;
          visitedSegments.add(nt);
          graphSegments.add(s);
        }
      }
    }
  }
  int parentSegmentEnd=finalRoute != null && finalRoute.segmentStart <= end.segmentStart ? end.segmentEnd : end.segmentStart;
  RouteSegment segment=finalRoute;
  while (segment != null) {
    RouteSegmentResult res=new RouteSegmentResult();
    res.object=segment.road;
    res.endPointIndex=parentSegmentEnd;
    res.startPointIndex=segment.segmentStart;
    parentSegmentEnd=segment.parentSegmentEnd;
    segment=segment.parentRoute;
    if (segment == null && res.startPointIndex >= res.endPointIndex) {
      res.startPointIndex=start.segmentEnd;
    }
    if (res.startPointIndex != res.endPointIndex) {
      result.add(0,res);
    }
    res.startPoint=convertPoint(res.object,res.startPointIndex);
    res.endPoint=convertPoint(res.object,res.endPointIndex);
  }
  ctx.timeToCalculate=(System.nanoTime() - now);
  log.info("Time to calculate : " + ctx.timeToCalculate / 1e6 + ", time to load : " + ctx.timeToLoad / 1e6 + ", loaded tiles : " + ctx.loadedTiles.size());
  return result;
}
