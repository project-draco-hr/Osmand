{
  ctx.timeToLoad=0;
  ctx.visitedSegments=0;
  long startNanoTime=System.nanoTime();
  Comparator<RouteSegment> segmentsComparator=new Comparator<RouteSegment>(){
    @Override public int compare(    RouteSegment o1,    RouteSegment o2){
      return roadPriorityComparator(o1.distanceFromStart,o1.distanceToEnd,o2.distanceFromStart,o2.distanceToEnd);
    }
  }
;
  PriorityQueue<RouteSegment> graphSegments=new PriorityQueue<RouteSegment>(50,segmentsComparator);
  ArrayList<RouteSegment> segmentsToVisitPrescricted=new ArrayList<RouteSegment>(5);
  ArrayList<RouteSegment> segmentsToVisitNotForbidden=new ArrayList<RouteSegment>(5);
  TLongHashSet visitedSegments=new TLongHashSet();
  int endX=end.road.getPoint31XTile(end.segmentEnd);
  int endY=end.road.getPoint31YTile(end.segmentEnd);
  int startX=start.road.getPoint31XTile(start.segmentStart);
  int startY=start.road.getPoint31YTile(start.segmentStart);
  start.distanceToEnd=squareRootDist(startX,startY,endX,endY) / ctx.router.getMaxDefaultSpeed();
  graphSegments.add(start);
  long ls=(((long)startX) << 31) + (long)startY;
  loadRoutes(ctx,(startX >> (31 - ZOOM_LOAD_TILES)),(startY >> (31 - ZOOM_LOAD_TILES)));
  RouteSegment startNbs=ctx.routes.get(ls);
  while (startNbs != null) {
    if (startNbs.road.id != start.road.id) {
      startNbs.parentRoute=start;
      startNbs.parentSegmentEnd=start.segmentStart;
      startNbs.distanceToEnd=start.distanceToEnd;
      long nt=(startNbs.road.id << 8l) + startNbs.segmentStart;
      visitedSegments.add(nt);
      graphSegments.add(startNbs);
    }
    startNbs=startNbs.next;
  }
  RouteSegment finalRoute=null;
  while (!graphSegments.isEmpty() && finalRoute == null) {
    RouteSegment segment=graphSegments.poll();
    BinaryMapDataObject road=segment.road;
    ctx.visitedSegments++;
    if (ctx.visitor != null) {
      ctx.visitor.visitSegment(segment);
    }
    int middle=segment.segmentStart;
    int middlex=road.getPoint31XTile(middle);
    int middley=road.getPoint31YTile(middle);
    int d=1;
    boolean oneway=ctx.router.isOneWay(road.getHighwayAttributes());
    boolean minus=true;
    boolean plus=true;
    if (end.road.id == road.id && end.segmentStart == middle) {
      finalRoute=segment;
    }
    double obstaclesTime=0;
    while (finalRoute == null && ((!oneway && minus) || plus)) {
      int j=middle + d;
      if (oneway) {
        d++;
      }
 else {
        if (d <= 0) {
          d=-d + 1;
        }
 else {
          d=-d;
        }
      }
      if (j < 0) {
        minus=false;
        continue;
      }
      if (j >= road.getPointsLength()) {
        plus=false;
        continue;
      }
      if (end.road.id == road.id && end.segmentStart == j) {
        finalRoute=segment;
        break;
      }
      long l=(((long)road.getPoint31XTile(j)) << 31) + (long)road.getPoint31YTile(j);
      loadRoutes(ctx,(road.getPoint31XTile(j) >> (31 - ZOOM_LOAD_TILES)),(road.getPoint31YTile(j) >> (31 - ZOOM_LOAD_TILES)));
      long nt=(road.id << 8l) + segment.segmentStart;
      visitedSegments.add(nt);
      RouteSegment next=ctx.routes.get(l);
      if (next != null) {
        segmentsToVisitPrescricted.clear();
        segmentsToVisitNotForbidden.clear();
        boolean exclusiveRestriction=false;
        if (d != 0) {
          RouteSegment possibleObstacle=next;
          while (possibleObstacle != null) {
            ctx.router.defineObstacle(possibleObstacle.road,possibleObstacle.segmentStart);
            possibleObstacle=possibleObstacle.next;
          }
        }
        while (next != null) {
          long nts=(next.road.id << 8l) + next.segmentStart;
          if (!visitedSegments.contains(nts)) {
            int type=-1;
            for (int i=0; i < road.getRestrictionCount(); i++) {
              if (road.getRestriction(i) == next.road.id) {
                type=road.getRestrictionType(i);
                break;
              }
            }
            if (type == -1 && exclusiveRestriction) {
            }
 else             if (type == MapRenderingTypes.RESTRICTION_NO_LEFT_TURN || type == MapRenderingTypes.RESTRICTION_NO_RIGHT_TURN || type == MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON || type == MapRenderingTypes.RESTRICTION_NO_U_TURN) {
            }
 else {
              int x=road.getPoint31XTile(j);
              int y=road.getPoint31YTile(j);
              double speed=ctx.router.defineSpeed(road);
              if (speed == 0) {
                speed=ctx.router.getMinDefaultSpeed();
              }
              double distanceFromStart=segment.distanceFromStart + squareRootDist(x,y,middlex,middley) / speed;
              distanceFromStart+=ctx.router.calculateTurnTime(middley,middlex,x,y,segment,next,j);
              distanceFromStart+=obstaclesTime;
              double distanceToEnd=squareRootDist(x,y,endX,endY) / ctx.router.getMaxDefaultSpeed();
              if (next.parentRoute == null || roadPriorityComparator(next.distanceFromStart,next.distanceToEnd,distanceFromStart,distanceToEnd) > 0) {
                next.distanceFromStart=distanceFromStart;
                next.distanceToEnd=distanceToEnd;
                if (next.parentRoute != null) {
                  graphSegments.remove(next);
                }
                next.parentRoute=segment;
                next.parentSegmentEnd=j;
                if (type == -1) {
                  segmentsToVisitNotForbidden.add(next);
                }
 else {
                  exclusiveRestriction=true;
                  segmentsToVisitNotForbidden.clear();
                  segmentsToVisitPrescricted.add(next);
                }
              }
            }
          }
          next=next.next;
        }
        for (        RouteSegment s : segmentsToVisitNotForbidden) {
          graphSegments.add(s);
        }
        for (        RouteSegment s : segmentsToVisitPrescricted) {
          graphSegments.add(s);
        }
      }
    }
  }
  return prepareResult(ctx,start,end,startNanoTime,finalRoute);
}
