{
  List<RouteSegmentResult> result=new ArrayList<RouteSegmentResult>();
  long now=System.currentTimeMillis();
  ArrayList<RouteSegment> addedRoutesWORestrictions=new ArrayList<RouteSegment>(5);
  ArrayList<RouteSegment> addedRoutesOthers=new ArrayList<RouteSegment>(5);
  PriorityQueue<RouteSegment> graphSegments=new PriorityQueue<RouteSegment>(50,new Comparator<RouteSegment>(){
    @Override public int compare(    RouteSegment o1,    RouteSegment o2){
      return Double.compare(o1.distanceFromStart + o1.distanceToEnd,o2.distanceFromStart + o2.distanceToEnd);
    }
  }
);
  TLongHashSet visitedPoints=new TLongHashSet();
  graphSegments.add(start);
  RouteSegment endRoute=null;
  int endX=end.road.getPoint31XTile(end.segmentEnd);
  int endY=end.road.getPoint31YTile(end.segmentEnd);
  int startX=start.road.getPoint31XTile(start.segmentStart);
  int startY=start.road.getPoint31YTile(start.segmentStart);
  start.distanceToEnd=squareRootDist(startX,startY,endX,endY) / 10;
  RouteSegment gotoStart=ctx.routes.get((startX << 31l) + (long)startY);
  while (gotoStart != null) {
    if (gotoStart.road.id != start.road.id) {
      gotoStart.distanceToEnd=start.distanceToEnd;
      long nt=(gotoStart.road.id << 8l) + gotoStart.segmentStart;
      visitedPoints.add(nt);
      graphSegments.add(gotoStart);
    }
    gotoStart=gotoStart.next;
  }
  while (!graphSegments.isEmpty() && endRoute == null) {
    RouteSegment segment=graphSegments.poll();
    BinaryMapDataObject road=segment.road;
    boolean oneway=ctx.router.isOneWay(road.getHighwayAttributes());
    int middle=segment.segmentStart;
    boolean minus=true;
    boolean plus=true;
    int d=1;
    int middlex=road.getPoint31XTile(middle);
    int middley=road.getPoint31YTile(middle);
    double trafficSignalsTime=0;
    while (endRoute == null && ((!oneway && minus) || plus)) {
      int j=middle + d;
      if (oneway) {
        d++;
      }
 else {
        if (d <= 0) {
          d=-d + 1;
        }
 else {
          d=-d;
        }
      }
      if (j < 0) {
        minus=false;
        continue;
      }
      if (j >= road.getPointsLength()) {
        plus=false;
        continue;
      }
      if (end.road.id == road.id && Math.abs(end.segmentStart - j) <= 1) {
        endRoute=segment;
        break;
      }
      long l=(((long)road.getPoint31XTile(j)) << 31) + (long)road.getPoint31YTile(j);
      loadRoutes(ctx,(road.getPoint31XTile(j) >> (31 - ZOOM_LOAD_TILES)),(road.getPoint31YTile(j) >> (31 - ZOOM_LOAD_TILES)));
      RouteSegment next=ctx.routes.get(l);
      if (next != null) {
        if (d != 0) {
          RouteSegment trafficSignalsTest=next;
          while (trafficSignalsTest != null) {
            if ((trafficSignalsTest.road.getTypes()[0] & 3) == MapRenderingTypes.POINT_TYPE) {
              TagValuePair pair=trafficSignalsTest.road.getTagValue(0);
              if (pair != null && pair.tag.equals("highway") && pair.value.equals("traffic_signals")) {
                trafficSignalsTime+=25;
              }
            }
            trafficSignalsTest=trafficSignalsTest.next;
          }
        }
      }
      addedRoutesWORestrictions.clear();
      addedRoutesOthers.clear();
      boolean exclusiveRestriction=false;
      while (next != null) {
        long nt=(next.road.id << 8l) + next.segmentStart;
        if (!visitedPoints.contains(nt) && next.road.id >> 3 != road.id >> 3) {
          int type=-1;
          for (int i=0; i < road.getRestrictionCount(); i++) {
            if (road.getRestriction(i) == next.road.id) {
              type=road.getRestrictionType(i);
              break;
            }
          }
          if (type == -1 && exclusiveRestriction) {
          }
 else           if (type == MapRenderingTypes.RESTRICTION_NO_LEFT_TURN || type == MapRenderingTypes.RESTRICTION_NO_RIGHT_TURN || type == MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON || type == MapRenderingTypes.RESTRICTION_NO_U_TURN) {
          }
 else {
            next.parentRoute=segment;
            next.parentSegmentEnd=j;
            int x=road.getPoint31XTile(j);
            int y=road.getPoint31YTile(j);
            double speed=ctx.router.defineSpeed(road);
            if (speed == 0) {
              speed=ctx.router.getMinDefaultSpeed();
            }
            next.distanceFromStart=segment.distanceFromStart + squareRootDist(x,y,middlex,middley) / speed;
            if (j < road.getPointsLength() - 1 || next.segmentStart != 0) {
              next.distanceFromStart+=30;
            }
            next.distanceFromStart+=trafficSignalsTime;
            next.distanceToEnd=squareRootDist(x,y,endX,endY) / 30;
            if (type == -1) {
              addedRoutesOthers.add(next);
            }
 else {
              exclusiveRestriction=true;
              addedRoutesOthers.clear();
              addedRoutesWORestrictions.add(next);
            }
          }
        }
        next=next.next;
      }
      for (      RouteSegment s : addedRoutesOthers) {
        long nt=(s.road.id << 8l) + s.segmentStart;
        visitedPoints.add(nt);
        graphSegments.add(s);
      }
      for (      RouteSegment s : addedRoutesWORestrictions) {
        long nt=(s.road.id << 8l) + s.segmentStart;
        visitedPoints.add(nt);
        graphSegments.add(s);
      }
    }
  }
  int parentSegmentEnd=endRoute != null && endRoute.segmentStart <= end.segmentStart ? end.segmentEnd : end.segmentStart;
  RouteSegment segment=endRoute;
  while (segment != null) {
    RouteSegmentResult res=new RouteSegmentResult();
    res.object=segment.road;
    res.endPointIndex=parentSegmentEnd;
    res.startPointIndex=segment.segmentStart;
    parentSegmentEnd=segment.parentSegmentEnd;
    System.out.println(segment.road.name + " time to go " + (segment.distanceFromStart / 60)+ " estimate time "+ (segment.distanceToEnd / 60));
    segment=segment.parentRoute;
    if (res.startPointIndex != res.endPointIndex) {
      result.add(0,res);
      if (segment == null && res.startPointIndex > res.endPointIndex) {
        res.startPointIndex=start.segmentEnd;
      }
    }
    res.startPoint=convertPoint(res.object,res.startPointIndex);
    res.endPoint=convertPoint(res.object,res.endPointIndex);
  }
  ctx.timeToCalculate=(int)(System.currentTimeMillis() - now);
  System.out.println("Time to calculate : " + ctx.timeToCalculate + ", time to load : "+ ctx.timeToLoad+ ", loaded tiles : "+ ctx.loadedTiles.size());
  return result;
}
