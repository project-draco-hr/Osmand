{
  String ref=rel.getTag(OSMTagKey.REF);
  String route=rel.getTag(OSMTagKey.ROUTE);
  String operator=rel.getTag(OSMTagKey.OPERATOR);
  if (route == null || ref == null) {
    return null;
  }
  if (!acceptedRoutes.contains(route)) {
    return null;
  }
  TransportRoute r=new TransportRoute(rel,ref);
  r.setOperator(operator);
  r.setType(route);
  if (operator != null) {
    route=operator + " : " + route;
  }
  final Map<TransportStop,Integer> forwardStops=new LinkedHashMap<TransportStop,Integer>();
  final Map<TransportStop,Integer> backwardStops=new LinkedHashMap<TransportStop,Integer>();
  int currentStop=0;
  int forwardStop=0;
  int backwardStop=0;
  for (  Entry<Entity,String> e : rel.getMemberEntities().entrySet()) {
    if (e.getValue().contains("stop")) {
      if (e.getKey() instanceof Node) {
        TransportStop stop=new TransportStop(e.getKey());
        boolean forward=e.getValue().contains("forward");
        boolean backward=e.getValue().contains("backward");
        currentStop++;
        if (forward || !backward) {
          forwardStop++;
        }
        if (backward) {
          backwardStop++;
        }
        boolean common=!forward && !backward;
        int index=-1;
        int i=e.getValue().length() - 1;
        int accum=1;
        while (i >= 0 && Character.isDigit(e.getValue().charAt(i))) {
          if (index < 0) {
            index=0;
          }
          index=accum * Character.getNumericValue(e.getValue().charAt(i)) + index;
          accum*=10;
          i--;
        }
        if (index < 0) {
          index=forward ? forwardStop : (backward ? backwardStop : currentStop);
        }
        if (forward || common) {
          forwardStops.put(stop,index);
          r.getForwardStops().add(stop);
        }
        if (backward || common) {
          if (common) {
            backwardStops.put(stop,-index);
          }
 else {
            backwardStops.put(stop,index);
          }
          r.getBackwardStops().add(stop);
        }
      }
    }
 else     if (e.getKey() instanceof Way) {
      r.addWay((Way)e.getKey());
    }
  }
  if (forwardStops.isEmpty() && backwardStops.isEmpty()) {
    return null;
  }
  Collections.sort(r.getForwardStops(),new Comparator<TransportStop>(){
    @Override public int compare(    TransportStop o1,    TransportStop o2){
      return forwardStops.get(o1) - forwardStops.get(o2);
    }
  }
);
  for (  TransportStop s : new ArrayList<TransportStop>(backwardStops.keySet())) {
    if (backwardStops.get(s) < 0) {
      backwardStops.put(s,backwardStops.size() + backwardStops.get(s) - 1);
    }
  }
  Collections.sort(r.getBackwardStops(),new Comparator<TransportStop>(){
    @Override public int compare(    TransportStop o1,    TransportStop o2){
      return backwardStops.get(o1) - backwardStops.get(o2);
    }
  }
);
  return r;
}
