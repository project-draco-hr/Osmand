' ogr2osm beta\n \n (c) Iv\xc3\xa1n S\xc3\xa1nchez Ortega, 2009 \n <ivan@sanchezortega.es>\n\n\n This piece of crap^H^H^H^Hsoftware is supposed to take just about any vector file \n as an input thanks to the magic of the OGR libraries, and then output a pretty OSM XML\n file with that data.\n\n The cool part is that it will detect way segments shared between several ways, so\n it will build relations outof thin air. This simplifies the structure of boundaries, for\n example.\n\n It is also able to translate attributes to tags, though there is only one such translation\n scheme by now. In order to translate your own datasets, you should have some basic\n understanding of python programming. See the files in the translation/ directory.\n \n An outstanding issue is that elevation in 2.5D features (that can be generated by\n reprojecting) is ignored completely.\n \n Usage: specify a filename to be converted (its extension will be changed to .osm), and the\n the projection the source data is in. You can specify the source projection by using either\n an EPSG code or a Proj.4 string.\n \n If the projection is not specified, ogr2osm will try to fetch it from the source data. If\n there is no projection information in the source data, this will assume EPSG:4326 (WGS84\n latitude-longitude).\n \n python ogr2osm.py [options] [filename]\n\t\n Options:\t\n   -e, --epsg=...       EPSG code, forcing the source data projection\n   -p, --proj4=...      PROJ4 string, forcing the source data projection\n   -v, --verbose        Shows some seemingly random characters dancing in the screen \n\t                    for every feature that\'s being worked on.\n   -h, --help           Show this message\n   -d, --debug-tags     Outputs the tags for every feature parsed\n   -a, --attribute-stats Outputs a summary of the different tags / attributes encountered\n   -t, --translation=... Select the attribute-tags translation method. \n\t                    See the translations/ diredtory for valid values.\n   -o, --output=...     Set destination .osm file name and location.\n\t\n (-e and -p are mutually exclusive. If both are specified, only the last one will be\n taken into account)\n\n For example, if the shapefile foobar.shp has projection EPSG:23030, do:\n\n python ogr2osm.py foobar.shp -e 23030\n\n This will do an in-the-fly reprojection from EPSG:23030 to EPSG:4326, and write a file\n called "foobar.osm"\n \n\n#####################################################################################\n#   "THE BEER-WARE LICENSE":                                                        #\n#   <ivan@sanchezortega.es> wrote this file. As long as you retain this notice you  #\n#   can do whatever you want with this stuff. If we meet some day, and you think    #\n#   this stuff is worth it, you can buy me a beer in return.                        #\n#####################################################################################\n'
import sys
import os
import getopt
from SimpleXMLWriter import XMLWriter
try:
    from osgeo import ogr
except:
    import ogr
try:
    from osgeo import osr
except:
    import osr
from ogr import wkbPoint
from ogr import wkbLineString
from ogr import wkbPolygon
from ogr import wkbMultiPoint
from ogr import wkbMultiLineString
from ogr import wkbMultiPolygon
from ogr import wkbGeometryCollection
from ogr import wkbUnknown
from ogr import wkbNone
from ogr import wkbPoint25D
from ogr import wkbLineString25D
from ogr import wkbPolygon25D
from ogr import wkbMultiPoint25D
from ogr import wkbMultiLineString25D
from ogr import wkbMultiPolygon25D
from ogr import wkbGeometryCollection25D
sourceEPSG = 4326
sourceProj4 = None
detectProjection = True
useEPSG = False
useProj4 = False
showProgress = False
debugTags = False
attributeStats = False
translationMethod = None
output = None
try:
    (opts, args) = getopt.getopt(sys.argv[1:], 'e:p:hvdat:o:', ['epsg=', 'proj4=', 'help', 'verbose', 'debug-tags', 'attribute-stats', 'translation=', 'output='])
except getopt.GetoptError:
    print __doc__
    sys.exit(2)
for (opt, arg) in opts:
    if (opt in ('-h', '--help')):
        print __doc__
        sys.exit()
    elif (opt in ('-p', '--proj4')):
        sourceProj4 = arg
        useProj4 = True
        useEPSG = False
        detectProjection = False
    elif (opt in ('-e', '--epsg')):
        try:
            sourceEPSG = int(arg)
        except:
            print "Error: EPSG code must be numeric (e.g. '4326' instead of 'epsg:4326')"
            sys.exit(1)
        detectProjection = False
        useEPSG = True
        useProj4 = False
    elif (opt in ('-v', '--verbose')):
        showProgress = True
    elif (opt in ('-d', '--debug-tags')):
        debugTags = True
    elif (opt in ('-a', '--attribute-stats')):
        attributeStats = True
        attributeStatsTable = {}
    elif (opt in ('-t', '--translation')):
        translationMethod = arg
    elif (opt in ('-o', '--output')):
        output = arg
    else:
        print ('Unknown option ' + opt)
print (opts, args)
file = args[0]
fileExtension = file.split('.')[(-1)].lower()
if (fileExtension == 'shp'):
    driver = ogr.GetDriverByName('ESRI Shapefile')
elif ((fileExtension == 'tab') or (fileExtension == 'mid') or (fileExtension == 'mif')):
    driver = ogr.GetDriverByName('MapInfo File')
elif (fileExtension == 'gpx'):
    driver = ogr.GetDriverByName('GPX')
elif (fileExtension == 'dgn'):
    driver = ogr.GetDriverByName('DGN')
elif (fileExtension == 'gml'):
    driver = ogr.GetDriverByName('GML')
elif (fileExtension == 'csv'):
    driver = ogr.GetDriverByName('CSV')
elif (fileExtension == 'sqlite'):
    driver = ogr.GetDriverByName('SQLite')
elif (fileExtension == 'kml'):
    driver = ogr.GetDriverByName('KML')
else:
    print (('Error: extension ' + fileExtension) + ' is invalid or not implemented yet.')
if (output is None):
    slashPosition = file.rfind('/')
    if (slashPosition != (-1)):
        outputFile = file[(slashPosition + 1):]
    else:
        outputFile = file
    outputFile = (outputFile[:(- len(fileExtension))] + 'osm')
else:
    outputFile = output
dataSource = driver.Open(file, 0)
if (dataSource is None):
    print ('Could not open ' + file)
    sys.exit(1)
print 
print ((((('Preparing to convert file ' + file) + ' (extension is ') + fileExtension) + ') into ') + outputFile)
if detectProjection:
    print 'Will try to detect projection from source metadata, or fall back to EPSG:4326'
elif useEPSG:
    print ('Will assume that source data is in EPSG:' + str(sourceEPSG))
elif useProj4:
    print ('Will assume that source data has the Proj.4 string: ' + sourceProj4)
if showProgress:
    print 'Verbose mode is on. Get ready to see lots of dots.'
if debugTags:
    print 'Tag debugging is on. Get ready to see lots of stuff.'
nodeIDsByXY = {}
nodeTags = {}
nodeCoords = {}
nodeRefs = {}
segmentNodes = {}
segmentIDByNodes = {}
segmentRefs = {}
areaRings = {}
areaTags = {}
lineSegments = {}
lineTags = {}
if translationMethod:
    try:
        sys.path.append((os.getcwd() + '/translations'))
        module = __import__(translationMethod)
        translateAttributes = module.translateAttributes
        translateAttributes([])
    except:
        print (('Could not load translation method ' + translationMethod) + '. Check the translations/ directory for valid values.')
        sys.exit((-1))
    print (('Successfully loaded ' + translationMethod) + ' translation method.')
else:
    translateAttributes = (lambda attrs: attrs)
elementIdCounter = (-1)
nodeCount = 0
segmentCount = 0
lineCount = 0
areaCount = 0
segmentJoinCount = 0
print 
print 'Parsing features'
for i in range(dataSource.GetLayerCount()):
    layer = dataSource.GetLayer(i)
    layer.ResetReading()
    spatialRef = None
    if detectProjection:
        spatialRef = layer.GetSpatialRef()
        if (spatialRef != None):
            print 'Detected projection metadata:'
            print spatialRef
        else:
            print 'No projection metadata, falling back to EPSG:4326'
    elif useEPSG:
        spatialRef = osr.SpatialReference()
        spatialRef.ImportFromEPSG(sourceEPSG)
    elif useProj4:
        spatialRef = osr.SpatialReference()
        spatialRef.ImportFromProj4(sourceProj4)
    if (spatialRef == None):
        reproject = (lambda geometry: None)
    else:
        destSpatialRef = osr.SpatialReference()
        destSpatialRef.ImportFromEPSG(4326)
        coordTrans = osr.CoordinateTransformation(spatialRef, destSpatialRef)
        reproject = (lambda geometry: geometry.Transform(coordTrans))
    featureDefinition = layer.GetLayerDefn()
    fieldNames = []
    fieldCount = featureDefinition.GetFieldCount()
    for j in range(fieldCount):
        fieldNames.append(featureDefinition.GetFieldDefn(j).GetNameRef())
        if attributeStats:
            attributeStatsTable.update({featureDefinition.GetFieldDefn(j).GetNameRef(): {}, })
    print 
    print fieldNames
    print 'Got layer field definitions'
    for j in range(layer.GetFeatureCount()):
        feature = layer.GetNextFeature()
        geometry = feature.GetGeometryRef()
        if (geometry == None):
            continue
        fields = {}
        for k in range((fieldCount - 1)):
            fields[fieldNames[k]] = feature.GetFieldAsString(k)
            if attributeStats:
                try:
                    attributeStatsTable[fieldNames[k]][feature.GetFieldAsString(k)] = (attributeStatsTable[fieldNames[k]][feature.GetFieldAsString(k)] + 1)
                except:
                    attributeStatsTable[fieldNames[k]].update({feature.GetFieldAsString(k): 1, })
        tags = translateAttributes(fields)
        if debugTags:
            print 
            print tags
        reproject(geometry)
        geometryType = geometry.GetGeometryType()
        subGeometries = []
        if ((geometryType == wkbPoint) or (geometryType == wkbLineString) or (geometryType == wkbPolygon)):
            subGeometries = [geometry]
        elif ((geometryType == wkbMultiPoint) or (geometryType == wkbMultiLineString) or (geometryType == wkbMultiPolygon) or (geometryType == wkbGeometryCollection)):
            if showProgress:
                sys.stdout.write('M')
            for k in range(geometry.GetGeometryCount()):
                subGeometries.append(geometry.GetGeometryRef(k))
        elif ((geometryType == wkbPoint25D) or (geometryType == wkbLineString25D) or (geometryType == wkbPolygon25D)):
            if showProgress:
                sys.stdout.write('z')
            subGeometries = [geometry]
        elif ((geometryType == wkbMultiPoint25D) or (geometryType == wkbMultiLineString25D) or (geometryType == wkbMultiPolygon25D) or (geometryType == wkbGeometryCollection25D)):
            if showProgress:
                sys.stdout.write('Mz')
            for k in range(geometry.GetGeometryCount()):
                subGeometries.append(geometry.GetGeometryRef(k))
        elif (geometryType == wkbUnknown):
            print 'Geometry type is wkbUnknown, feature will be ignored\n'
        elif (geometryType == wkbNone):
            print 'Geometry type is wkbNone, feature will be ignored\n'
        else:
            print (('Unknown or unimplemented geometry type :' + str(geometryType)) + ', feature will be ignored\n')
        for geometry in subGeometries:
            if (geometry.GetDimension() == 0):
                if showProgress:
                    sys.stdout.write(',')
                x = geometry.GetX()
                y = geometry.GetY()
                nodeID = addNode(x, y, tags)
            elif (geometry.GetDimension() == 1):
                if showProgress:
                    sys.stdout.write('|')
                lineID = elementIdCounter
                elementIdCounter = (elementIdCounter - 1)
                lineSegments[lineID] = lineStringToSegments(geometry, lineID)
                lineTags[lineID] = tags
                lineCount = (lineCount + 1)
            elif (geometry.GetDimension() == 2):
                if showProgress:
                    sys.stdout.write('O')
                areaID = elementIdCounter
                elementIdCounter = (elementIdCounter - 1)
                rings = []
                for k in range(0, geometry.GetGeometryCount()):
                    if showProgress:
                        sys.stdout.write('r')
                    rings.append(lineStringToSegments(geometry.GetGeometryRef(k), areaID))
                areaRings[areaID] = rings
                areaTags[areaID] = tags
                areaCount = (areaCount + 1)
print 
print ('Nodes: ' + str(nodeCount))
print ('Way segments: ' + str(segmentCount))
print ('Lines: ' + str(lineCount))
print ('Areas: ' + str(areaCount))
print 
print 'Joining segments'
print 
print 'Simplifying line segments'
for line in lineSegments.values():
    for segmentID in line:
        for nodeID in segmentNodes[segmentID]:
            simplifyNode(nodeID)
print 
print 'Simplifying area segments'
for area in areaRings.values():
    for ring in area:
        for segmentID in ring:
            for nodeID in segmentNodes[segmentID]:
                simplifyNode(nodeID)
print 
print 'Simplifying remaining nodes'
for node in nodeRefs.keys():
    simplifyNode(node)
print 
print ('Nodes: ' + str(nodeCount))
print ('Original way segments: ' + str(segmentCount))
print ('Segment join operations: ' + str(segmentJoinCount))
print ('Lines: ' + str(lineCount))
print ('Areas: ' + str(areaCount))
print 
print 'Generating OSM XML...'
print 'Generating nodes.'
w = XMLWriter(open(outputFile, 'w'))
w.start('osm', version='0.6', generator='ogr2osm')
for (nodeID, (x, y)) in nodeCoords.items():
    w.start('node', visible='true', id=str(nodeID), lat=str(y), lon=str(x))
    for (tagKey, tagValue) in nodeTags[nodeID].items():
        if tagValue:
            w.element('tag', k=tagKey, v=tagValue)
    w.end('node')
    if showProgress:
        sys.stdout.write('.')
print 
print 'Generated nodes. On to lines.'
outputtedSegments = {}
for (lineID, lineSegment) in lineSegments.items():
    if showProgress:
        sys.stdout.write((str(len(lineSegment)) + ' '))
    if (len(lineSegment) == 1):
        w.start('way', id=str(lineID), action='modify', visible='true')
        for nodeID in segmentNodes[lineSegment[0]]:
            w.element('nd', ref=str(nodeID))
        for (tagKey, tagValue) in lineTags[lineID].items():
            if tagValue:
                w.element('tag', k=tagKey, v=tagValue)
        w.end('way')
        pass
    else:
        for segmentID in lineSegment:
            if (segmentID not in outputtedSegments):
                w.start('way', id=str(segmentID), action='modify', visible='true')
                for nodeID in segmentNodes[segmentID]:
                    w.element('nd', ref=str(nodeID))
                w.end('way')
        w.start('relation', id=str(lineID), action='modify', visible='true')
        for segmentID in lineSegment:
            w.element('member', type='way', ref=str(segmentID), role='')
        for (tagKey, tagValue) in lineTags[lineID].items():
            if tagValue:
                w.element('tag', k=tagKey, v=tagValue)
        w.end('relation')
print 
print 'Generated lines. On to areas.'
for (areaID, areaRing) in areaRings.items():
    if ((len(areaRing) == 1) and (len(areaRing[0]) == 1)):
        w.start('way', id=str(areaID), action='modify', visible='true')
        for nodeID in segmentNodes[areaRing[0][0]]:
            w.element('nd', ref=str(nodeID))
        for (tagKey, tagValue) in areaTags[areaID].items():
            if tagValue:
                w.element('tag', k=tagKey, v=tagValue)
        w.end('way')
        if showProgress:
            sys.stdout.write('0 ')
    else:
        segmentsUsed = 0
        segmentsUsedInRing = 0
        for ring in areaRing:
            for segmentID in ring:
                if (segmentID not in outputtedSegments):
                    w.start('way', id=str(segmentID), action='modify', visible='true')
                    for nodeID in segmentNodes[segmentID]:
                        w.element('nd', ref=str(nodeID))
                    w.end('way')
        w.start('relation', id=str(areaID), action='modify', visible='true')
        w.element('tag', k='type', v='multipolygon')
        role = 'outer'
        for ring in areaRing:
            for segmentID in ring:
                w.element('member', type='way', ref=str(segmentID), role=role)
                segmentsUsed = (segmentsUsed + 1)
                segmentsUsedInRing = (segmentsUsedInRing + 1)
            role = 'inner'
            segmentsUsedInRing = 0
        for (tagKey, tagValue) in areaTags[areaID].items():
            if tagValue:
                w.element('tag', k=tagKey, v=tagValue)
        w.end('relation')
        if showProgress:
            sys.stdout.write((str(segmentsUsed) + ' '))
if attributeStats:
    print 
    for (attribute, stats) in attributeStatsTable.items():
        print (('All values for attribute ' + attribute) + ':')
        print stats
print 
print 'All done. Enjoy your data!'
w.end('osm')
