{
  restrictionsUse.clear();
  mapLowLevelBinaryStat.executeBatch();
  mapLowLevelBinaryStat.close();
  pStatements.remove(mapLowLevelBinaryStat);
  mapLowLevelBinaryStat=null;
  mapConnection.commit();
  PreparedStatement startStat=mapConnection.prepareStatement("SELECT id, start_node, end_node, nodes, name, type, addType FROM low_level_map_objects" + " WHERE start_node = ? AND level = ?");
  PreparedStatement endStat=mapConnection.prepareStatement("SELECT id, start_node, end_node, nodes, name, type, addType FROM low_level_map_objects" + " WHERE end_node = ? AND level = ?");
  Statement selectStatement=mapConnection.createStatement();
  ResultSet rs=selectStatement.executeQuery("SELECT id, start_node, end_node, nodes, name, type, addType, level FROM low_level_map_objects");
  TLongHashSet visitedWays=new TLongHashSet();
  ArrayList<Float> list=new ArrayList<Float>(100);
  TIntArrayList temp=new TIntArrayList();
  TIntArrayList tempAdd=new TIntArrayList();
  while (rs.next()) {
    if (lowLevelWays != -1) {
      progress.progress(1);
    }
    long id=rs.getLong(1);
    if (visitedWays.contains(id)) {
      continue;
    }
    visitedWays.add(id);
    int level=rs.getInt(8);
    int zoom=mapZooms.getLevel(level).getMaxZoom();
    long startNode=rs.getLong(2);
    long endNode=rs.getLong(3);
    String name=rs.getString(5);
    parseAndSort(typeUse,rs.getBytes(6));
    parseAndSort(addtypeUse,rs.getBytes(7));
    loadNodes(rs.getBytes(4),list);
    ArrayList<Float> wayNodes=new ArrayList<Float>(list);
    boolean combined=true;
    while (combined) {
      combined=false;
      endStat.setLong(1,startNode);
      endStat.setShort(2,(short)level);
      ResultSet fs=endStat.executeQuery();
      while (fs.next() && !combined) {
        if (!visitedWays.contains(fs.getLong(1))) {
          parseAndSort(temp,rs.getBytes(6));
          parseAndSort(tempAdd,rs.getBytes(7));
          if (temp.equals(typeUse) && tempAdd.equals(addtypeUse)) {
            combined=true;
            long lid=fs.getLong(1);
            startNode=fs.getLong(2);
            visitedWays.add(lid);
            loadNodes(fs.getBytes(4),list);
            if (!Algoritms.objectEquals(rs.getString(5),name)) {
              name=null;
            }
            ArrayList<Float> li=new ArrayList<Float>(list);
            wayNodes.remove(0);
            wayNodes.remove(0);
            li.addAll(wayNodes);
            wayNodes=li;
          }
        }
      }
      fs.close();
    }
    combined=true;
    while (combined) {
      combined=false;
      startStat.setLong(1,endNode);
      startStat.setShort(2,(short)level);
      ResultSet fs=startStat.executeQuery();
      while (fs.next() && !combined) {
        if (!visitedWays.contains(fs.getLong(1))) {
          parseAndSort(temp,rs.getBytes(6));
          parseAndSort(tempAdd,rs.getBytes(7));
          if (temp.equals(typeUse) && tempAdd.equals(addtypeUse)) {
            combined=true;
            long lid=fs.getLong(1);
            if (!Algoritms.objectEquals(rs.getString(5),name)) {
              name=null;
            }
            endNode=fs.getLong(3);
            visitedWays.add(lid);
            loadNodes(fs.getBytes(4),list);
            for (int i=2; i < list.size(); i++) {
              wayNodes.add(list.get(i));
            }
          }
        }
      }
      fs.close();
    }
    List<Node> wNodes=new ArrayList<Node>();
    int wNsize=wayNodes.size();
    for (int i=0; i < wNsize; i+=2) {
      wNodes.add(new Node(wayNodes.get(i),wayNodes.get(i + 1),i == 0 ? startNode : endNode));
    }
    boolean skip=false;
    boolean cycle=startNode == endNode;
    if (cycle) {
      skip=checkForSmallAreas(wNodes,zoom + Math.min(zoomWaySmothness / 2,3),3,4);
    }
 else {
      if (!typeUse.contains(renderingTypes.getCoastlineRuleType().getInternalId())) {
        skip=checkForSmallAreas(wNodes,zoom + Math.min(zoomWaySmothness / 2,3),2,8);
      }
    }
    if (!skip) {
      List<Node> res=new ArrayList<Node>();
      MapAlgorithms.simplifyDouglasPeucker(wNodes,zoom - 1 + 8 + zoomWaySmothness,3,res);
      if (res.size() > 0) {
        namesUse.clear();
        if (name != null && name.length() > 0) {
          namesUse.put(renderingTypes.getNameRuleType(),name);
        }
        insertBinaryMapRenderObjectIndex(mapTree[level],res,null,namesUse,id,false,typeUse,addtypeUse,false);
      }
    }
  }
}
