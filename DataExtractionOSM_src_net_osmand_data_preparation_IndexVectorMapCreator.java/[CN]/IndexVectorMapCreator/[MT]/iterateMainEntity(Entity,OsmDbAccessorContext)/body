{
  if (e instanceof Way || e instanceof Node) {
    ctx.loadEntityData(e);
    for (int level=0; level < mapZooms.size(); level++) {
      boolean area=renderingTypes.encodeEntityWithType(e,mapZooms.getLevel(level).getMaxZoom(),false,typeUse,addtypeUse,namesUse,tempNameUse);
      if (typeUse.isEmpty()) {
        continue;
      }
      Map<Long,Set<Integer>> multiPolygonsWays=this.multiPolygonsWays[level];
      boolean hasMulti=e instanceof Way && multiPolygonsWays.containsKey(e.getId());
      if (hasMulti) {
        Set<Integer> set=multiPolygonsWays.get(e.getId());
        typeUse.removeAll(set);
      }
      if (typeUse.isEmpty()) {
        continue;
      }
      long id=convertBaseIdToGeneratedId(e.getId(),level);
      boolean skip=false;
      if (e instanceof Way) {
        id|=1;
        int zoomToSimplify=mapZooms.getLevel(level).getMaxZoom() - 1;
        if (zoomToSimplify < 15) {
          e=simplifyWay((Way)e,id,hasMulti,zoomToSimplify,eName,type,level);
          skip=e == null;
        }
      }
      if (!skip) {
        insertBinaryMapRenderObjectIndex(rtree,e,eName,id,type,typeUse,highwayAttributes,restrictionsUse,inverse,point,true);
      }
    }
  }
}
