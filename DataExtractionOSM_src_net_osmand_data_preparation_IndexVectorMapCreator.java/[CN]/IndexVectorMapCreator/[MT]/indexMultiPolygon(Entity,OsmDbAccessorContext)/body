{
  if (!(e instanceof Relation) || !"multipolygon".equals(e.getTag(OSMTagKey.TYPE)) || e.getTag(OSMTagKey.ADMIN_LEVEL) != null)   return;
  ctx.loadEntityRelation((Relation)e);
  Map<Entity,String> entities=((Relation)e).getMemberEntities();
  Multipolygon original=new Multipolygon(e.getId());
  for (  Entity es : entities.keySet()) {
    if (es instanceof Way) {
      boolean inner="inner".equals(entities.get(es));
      if (inner) {
        original.addInnerWay((Way)es);
      }
 else {
        original.addOuterWay((Way)es);
      }
    }
  }
  if (!original.hasOpenedPolygons()) {
    logMapDataWarn.warn("Multipolygon has unclosed parts: Multipoligon id=" + e.getId());
  }
  renderingTypes.encodeEntityWithType(e,mapZooms.getLevel(0).getMaxZoom(),typeUse,addtypeUse,namesUse,tempNameUse);
  if (typeUse.size() == 0)   return;
  if (!original.areRingsComplete()) {
    logMapDataWarn.warn("In multipolygon  " + e.getId() + " there are incompleted ways");
  }
  List<Multipolygon> multipolygons=original.splitPerOuterRing(logMapDataWarn);
  for (  Multipolygon m : multipolygons) {
    List<List<Node>> innerWays=new ArrayList<List<Node>>();
    for (    Ring r : m.getInnerRings()) {
      innerWays.add(r.getBorder().getNodes());
    }
    long baseId=notUsedId--;
    nextZoom:     for (int level=0; level < mapZooms.size(); level++) {
      renderingTypes.encodeEntityWithType(e,mapZooms.getLevel(level).getMaxZoom(),typeUse,addtypeUse,namesUse,tempNameUse);
      if (typeUse.isEmpty()) {
        continue;
      }
      long id=convertBaseIdToGeneratedId(baseId,level);
      List<Node> outerWay=m.getOuterNodes();
      int zoomToSimplify=mapZooms.getLevel(level).getMaxZoom() - 1;
      if (zoomToSimplify < 15) {
        outerWay=simplifyCycleWay(outerWay,zoomToSimplify,zoomWaySmothness);
        if (outerWay == null) {
          continue nextZoom;
        }
        List<List<Node>> newinnerWays=new ArrayList<List<Node>>();
        for (        List<Node> ls : innerWays) {
          ls=simplifyCycleWay(ls,zoomToSimplify,zoomWaySmothness);
          if (ls != null) {
            newinnerWays.add(ls);
          }
        }
        innerWays=newinnerWays;
      }
      insertBinaryMapRenderObjectIndex(mapTree[level],outerWay,innerWays,namesUse,id,true,typeUse,addtypeUse,true);
    }
  }
}
