{
  final int paddingLeft=getPaddingLeft();
  int childTop;
  int childLeft;
  final int width=right - left;
  int childRight=width - getPaddingRight();
  int childSpace=width - paddingLeft - getPaddingRight();
  final int count=getVirtualChildCount();
  final int majorGravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final int minorGravity=mGravity & GravityCompat.RELATIVE_HORIZONTAL_GRAVITY_MASK;
switch (majorGravity) {
case Gravity.BOTTOM:
    childTop=getPaddingTop() + bottom - top - mTotalLength;
  break;
case Gravity.CENTER_VERTICAL:
childTop=getPaddingTop() + (bottom - top - mTotalLength) / 2;
break;
case Gravity.TOP:
default :
childTop=getPaddingTop();
break;
}
for (int i=0; i < count; i++) {
final View child=getVirtualChildAt(i);
if (child == null) {
childTop+=measureNullChild(i);
}
 else if (child.getVisibility() != GONE) {
final int childWidth=child.getMeasuredWidth();
final int childHeight=child.getMeasuredHeight();
final LinearLayoutCompat.LayoutParams lp=(LinearLayoutCompat.LayoutParams)child.getLayoutParams();
int gravity=lp.gravity;
if (gravity < 0) {
gravity=minorGravity;
}
final int layoutDirection=ViewCompat.getLayoutDirection(this);
final int absoluteGravity=GravityCompat.getAbsoluteGravity(gravity,layoutDirection);
switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
case Gravity.CENTER_HORIZONTAL:
childLeft=paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin;
break;
case Gravity.RIGHT:
childLeft=childRight - childWidth - lp.rightMargin;
break;
case Gravity.LEFT:
default :
childLeft=paddingLeft + lp.leftMargin;
break;
}
if (hasDividerBeforeChildAt(i)) {
childTop+=mDividerHeight;
}
childTop+=lp.topMargin;
setChildFrame(child,childLeft,childTop + getLocationOffset(child),childWidth,childHeight);
childTop+=childHeight + lp.bottomMargin + getNextLocationOffset(child);
i+=getChildrenSkipCount(child,i);
}
}
}
