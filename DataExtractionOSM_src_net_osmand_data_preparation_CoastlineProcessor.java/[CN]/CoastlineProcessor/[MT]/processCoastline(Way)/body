{
  renderingTypes.getCoastlineRuleType().updateFreq();
  MapZoomPair p=mapZooms.getLevels().get(mapZooms.getLevels().size() - 1);
{
    int z=(p.getMinZoom() + p.getMaxZoom()) / 2;
    List<Node> ns=e.getNodes();
    if (ns.size() < 2) {
      return;
    }
    int i=1;
    Node prevNode=ns.get(0);
    int px31=MapUtils.get31TileNumberX(prevNode.getLongitude());
    int py31=MapUtils.get31TileNumberY(prevNode.getLatitude());
    while (i < ns.size()) {
      Way w=new Way(-1000);
      w.addNode(prevNode);
      int tilex=px31 >> (31 - z);
      int tiley=py31 >> (31 - z);
      boolean sameTile=true;
      wayConstruct:       while (sameTile && i < ns.size()) {
        Node next=ns.get(i);
        int ntilex=(int)MapUtils.getTileNumberX(z,next.getLongitude());
        int ntiley=(int)MapUtils.getTileNumberY(z,next.getLatitude());
        if (ntilex == tilex && tiley == ntiley) {
          sameTile=true;
          w.addNode(next);
          prevNode=next;
          px31=MapUtils.get31TileNumberX(prevNode.getLongitude());
          py31=MapUtils.get31TileNumberY(prevNode.getLatitude());
          i++;
        }
 else {
          int nx31=MapUtils.get31TileNumberX(next.getLongitude());
          int ny31=MapUtils.get31TileNumberY(next.getLatitude());
          int leftX=(tilex << (31 - z)) - 1;
          int rightX=(tilex + 1) << (31 - z);
          if (rightX < 0) {
            rightX=Integer.MAX_VALUE;
          }
          int topY=(tiley << (31 - z)) - 1;
          int bottomY=(tiley + 1) << (31 - z);
          if (bottomY < 0) {
            bottomY=Integer.MAX_VALUE;
          }
          long inter=MapAlgorithms.calculateIntersection(px31,py31,nx31,ny31,leftX,rightX,bottomY,topY);
          int cy31=(int)inter;
          int cx31=(int)(inter >> 32l);
          prevNode=new Node(MapUtils.get31LatitudeY(cy31),MapUtils.get31LongitudeX(cx31),-1000);
          px31=cx31;
          py31=cy31;
          w.addNode(prevNode);
          break wayConstruct;
        }
      }
      SimplisticQuadTree quad=quadTree.getOrCreateSubTree(tilex,tiley,z);
      if (quad == null) {
        if (logMapDataWarn != null) {
          logMapDataWarn.error("Tile " + tilex + " / "+ tiley+ " at "+ z+ " can not be found");
        }
 else {
          System.err.println("Tile " + tilex + " / "+ tiley+ " at "+ z+ " can not be found");
        }
      }
      quad.addCoastline(w);
    }
  }
}
