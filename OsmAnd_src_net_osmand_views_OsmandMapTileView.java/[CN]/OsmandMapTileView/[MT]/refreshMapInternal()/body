{
  if (handler.hasMessages(1)) {
    return;
  }
  if (OsmandSettings.isUsingInternetToDownloadTiles(getContext())) {
    MapTileDownloader.getInstance().refuseAllPreviousRequests();
  }
  float ftileSize=getTileSize();
  int tileSize=map == null ? 256 : map.getTileSize();
  float tileX=getXTile();
  float tileY=getYTile();
  float w=getCenterPointX();
  float h=getCenterPointY();
  SurfaceHolder holder=getHolder();
synchronized (holder) {
    int nzoom=(int)zoom;
    Canvas canvas=holder.lockCanvas();
    if (canvas != null) {
      canvas.save();
      boundsRect.set(0,0,getWidth(),getHeight());
      canvas.drawRect(boundsRect,paintWhiteFill);
      canvas.rotate(rotate,w,h);
      try {
        if (showMapTiles) {
          ResourceManager mgr=getApplication().getResourceManager();
          boolean useInternet=OsmandSettings.isUsingInternetToDownloadTiles(getContext()) && map.couldBeDownloadedFromInternet();
          int maxLevel=Math.min(OsmandSettings.getMaximumLevelToDownloadTile(getContext()),map.getMaximumZoomSupported());
          calculateTileRectangle(boundsRect,w,h,tileX,tileY,tilesRect);
          int left=(int)FloatMath.floor(tilesRect.left);
          int top=(int)FloatMath.floor(tilesRect.top);
          int width=(int)(FloatMath.ceil(tilesRect.right) - left);
          int height=(int)(FloatMath.ceil(tilesRect.bottom) - top);
          for (int i=0; i < width; i++) {
            for (int j=0; j < height; j++) {
              float x1=(i + left - tileX) * ftileSize + w;
              float y1=(j + top - tileY) * ftileSize + h;
              String ordImgTile=mgr.calculateTileId(map,left + i,top + j,nzoom);
              boolean imgExist=mgr.tileExistOnFileSystem(ordImgTile,map,left + i,top + j,nzoom);
              Bitmap bmp=null;
              boolean originalBeLoaded=useInternet && nzoom <= maxLevel;
              if (imgExist || originalBeLoaded) {
                bmp=mgr.getTileImageForMapAsync(ordImgTile,map,left + i,top + j,nzoom,useInternet);
              }
              if (bmp == null) {
                int div=2;
                String imgTile2=mgr.calculateTileId(map,(left + i) / 2,(top + j) / 2,nzoom - 1);
                String imgTile4=mgr.calculateTileId(map,(left + i) / 4,(top + j) / 4,nzoom - 2);
                if (originalBeLoaded || imgExist) {
                  bmp=mgr.getTileImageFromCache(imgTile2);
                  div=2;
                  if (bmp == null) {
                    bmp=mgr.getTileImageFromCache(imgTile4);
                    div=4;
                  }
                }
                if (!originalBeLoaded && !imgExist) {
                  if (mgr.tileExistOnFileSystem(imgTile2,map,(left + i) / 2,(top + j) / 2,nzoom - 1) || (useInternet && nzoom - 1 <= maxLevel)) {
                    bmp=mgr.getTileImageForMapAsync(imgTile2,map,(left + i) / 2,(top + j) / 2,nzoom - 1,useInternet);
                    div=2;
                  }
 else                   if (mgr.tileExistOnFileSystem(imgTile4,map,(left + i) / 4,(top + j) / 4,nzoom - 2) || (useInternet && nzoom - 2 <= maxLevel)) {
                    bmp=mgr.getTileImageForMapAsync(imgTile4,map,(left + i) / 4,(top + j) / 4,nzoom - 2,useInternet);
                    div=4;
                  }
                }
                if (bmp == null) {
                  drawEmptyTile(canvas,x1,y1,ftileSize);
                }
 else {
                  int xZoom=((left + i) % div) * tileSize / div;
                  int yZoom=((top + j) % div) * tileSize / div;
                  ;
                  bitmapToZoom.set(xZoom,yZoom,xZoom + tileSize / div,yZoom + tileSize / div);
                  bitmapToDraw.set(x1,y1,x1 + ftileSize,y1 + ftileSize);
                  canvas.drawBitmap(bmp,bitmapToZoom,bitmapToDraw,paintBitmap);
                }
              }
 else {
                bitmapToZoom.set(0,0,map.getTileSize(),map.getTileSize());
                bitmapToDraw.set(x1,y1,x1 + ftileSize,y1 + ftileSize);
                canvas.drawBitmap(bmp,bitmapToZoom,bitmapToDraw,paintBitmap);
              }
            }
          }
        }
        drawOverMap(canvas);
      }
  finally {
        holder.unlockCanvasAndPost(canvas);
      }
    }
  }
}
