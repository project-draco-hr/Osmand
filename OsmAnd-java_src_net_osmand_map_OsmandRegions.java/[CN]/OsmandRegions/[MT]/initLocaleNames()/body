{
  final Map<String,String> parentRelations=new LinkedHashMap<String,String>();
  final ResultMatcher<BinaryMapDataObject> resultMatcher=new ResultMatcher<BinaryMapDataObject>(){
    @Override public boolean publish(    BinaryMapDataObject object){
      initTypes(object);
      int[] types=object.getTypes();
      for (int i=0; i < types.length; i++) {
        TagValuePair tp=object.getMapIndex().decodeType(types[i]);
        if ("boundary".equals(tp.value)) {
          return false;
        }
      }
      RegionData rd=new RegionData();
      rd.downloadsId=mapIndexFields.get(mapIndexFields.downloadNameType,object);
      rd.regionFullName=mapIndexFields.get(mapIndexFields.fullNameType,object);
      rd.regionParentFullName=mapIndexFields.get(mapIndexFields.parentFullName,object);
      if (!Algorithms.isEmpty(rd.regionParentFullName)) {
        parentRelations.put(rd.regionFullName,rd.regionParentFullName);
      }
      rd.regionName=mapIndexFields.get(mapIndexFields.nameType,object);
      rd.regionNameLocale=mapIndexFields.get(mapIndexFields.nameLocaleType,object);
      rd.regionNameEn=mapIndexFields.get(mapIndexFields.nameEnType,object);
      rd.regionLang=mapIndexFields.get(mapIndexFields.langType,object);
      rd.regionLeftHandDriving=mapIndexFields.get(mapIndexFields.leftHandDrivingType,object);
      rd.regionMetric=mapIndexFields.get(mapIndexFields.metricType,object);
      rd.regionRoadSigns=mapIndexFields.get(mapIndexFields.roadSignsType,object);
      String roadSigns=getRoadSigns(object);
      if (!Algorithms.isEmpty(roadSigns)) {
        fullNamesToRoadSigns.put(fullName,roadSigns);
      }
      rd.searchText=getSearchIndex(object);
      fullNamesToLowercaseIndex.put(fullName,ind.toString());
      String downloadName=getDownloadName(object);
      if (downloadName != null) {
        fullNamesToDownloadNames.put(fullName,downloadName);
        downloadNamesToFullNames.put(downloadName,fullName);
        if (isDownloadOfType(object,MAP_TYPE)) {
          fullMapNamesToDownloadNames.put(fullName,downloadName);
        }
      }
      return false;
    }
    private String getSearchIndex(    BinaryMapDataObject object){
      MapIndex mi=object.getMapIndex();
      TIntObjectIterator<String> it=object.getObjectNames().iterator();
      StringBuilder ind=new StringBuilder();
      while (it.hasNext()) {
        it.advance();
        TagValuePair tp=mi.decodeType(it.key());
        if (tp.tag.startsWith("name") || tp.tag.equals("key_name")) {
          final String vl=it.value().toLowerCase();
          if (ind.indexOf(vl) == -1) {
            ind.append(" ").append(vl);
          }
        }
      }
      return ind.toString();
    }
    @Override public boolean isCancelled(){
      return false;
    }
  }
;
  iterateOverAllObjects(resultMatcher);
  for (  Map.Entry<String,String> e : parentRelations.entrySet()) {
    String fullName=e.getKey();
    String parentFullName=e.getValue();
    String parentParentFulName=parentRelations.get(parentFullName);
    if (!Algorithms.isEmpty(parentFullName) && !Algorithms.isEmpty(parentParentFulName)) {
      if (parentParentFulName.contains("russia") || parentParentFulName.contains("japan")) {
        parentFullName=parentParentFulName;
      }
      String locPrefix=fullNamesToLocaleNames.get(parentFullName);
      String locName=fullNamesToLocaleNames.get(fullName);
      if (locPrefix == null || locName == null) {
        throw new IllegalStateException("There is no prefix registered for " + fullName + " ("+ parentFullName+ ") ");
      }
      fullNamesToLocaleNames.put(fullName,locPrefix + " " + locName);
      fullNamesNoParentToLocaleNames.put(fullName,locName);
    }
  }
}
