{
  final Map<String,String> downloadNames=new LinkedHashMap<String,String>();
  final Map<String,String> parentRelations=new LinkedHashMap<String,String>();
  final ResultMatcher<BinaryMapDataObject> resultMatcher=new ResultMatcher<BinaryMapDataObject>(){
    @Override public boolean publish(    BinaryMapDataObject object){
      initTypes(object);
      String downloadName=getDownloadName(object);
      String parentFullName=getParentFullName(object);
      String fullName=getFullName(object);
      if (!Algorithms.isEmpty(parentFullName)) {
        parentRelations.put(fullName,parentFullName);
      }
      if (downloadName == null) {
        return false;
      }
      downloadName=downloadName.toLowerCase();
      downloadNames.put(fullName,downloadName);
      String locName=getLocaleName(object);
      if (locName != null && locName.length() > 0) {
        downloadNamesToLocaleNames.put(downloadName,locName);
      }
      MapIndex mi=object.getMapIndex();
      TIntObjectIterator<String> it=object.getObjectNames().iterator();
      StringBuilder ind=new StringBuilder();
      while (it.hasNext()) {
        it.advance();
        TagValuePair tp=mi.decodeType(it.key());
        if (tp.tag.startsWith("name") || tp.tag.equals("key_name")) {
          final String vl=it.value().toLowerCase();
          if (ind.indexOf(vl) == -1) {
            ind.append(" ").append(vl);
          }
        }
      }
      downloadNamesToLowercaseIndex.put(downloadName,ind.toString());
      return false;
    }
    @Override public boolean isCancelled(){
      return false;
    }
  }
;
  iterateOverAllObjects(resultMatcher);
  for (  Map.Entry<String,String> e : downloadNames.entrySet()) {
    String fullName=e.getKey();
    String downloadName=e.getValue();
    String parentFullName=parentRelations.get(fullName);
    if (!Algorithms.isEmpty(parentFullName) && !Algorithms.isEmpty(parentRelations.get(parentFullName))) {
      String parentDW=downloadNames.get(parentFullName);
      String locPrefix=downloadNamesToLocaleNames.get(parentDW);
      String locName=downloadNamesToLocaleNames.get(downloadName);
      if (locPrefix == null || locName == null) {
        throw new IllegalStateException("There is no prefix registered for " + downloadName + " ("+ parentFullName+ ") ");
      }
      downloadNamesToLocaleNames.put(downloadName,locPrefix + " " + locName);
      String index=downloadNamesToLowercaseIndex.get(downloadName);
      String prindex=downloadNamesToLowercaseIndex.get(parentDW);
      downloadNamesToLowercaseIndex.put(downloadName,index + " " + prindex);
    }
  }
}
