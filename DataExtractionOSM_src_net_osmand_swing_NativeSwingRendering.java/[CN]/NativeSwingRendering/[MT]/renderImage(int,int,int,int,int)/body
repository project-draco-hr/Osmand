{
  long time=-System.currentTimeMillis();
  RenderingContext rctx=new RenderingContext(){
    @Override protected byte[] getIconRawData(    String data){
      return _R.getIconData(data);
    }
  }
;
  rctx.nightMode="true".equals(renderingProps.get("nightMode"));
  RenderingRuleSearchRequest request=new RenderingRuleSearchRequest(storage);
  request.setBooleanFilter(request.ALL.R_NIGHT_MODE,rctx.nightMode);
  for (  RenderingRuleProperty customProp : storage.PROPS.getCustomRules()) {
    String res=renderingProps.get(customProp.getAttrName());
    if (!Algoritms.isEmpty(res)) {
      if (customProp.isString()) {
        request.setStringFilter(customProp,res);
      }
 else       if (customProp.isBoolean()) {
        request.setBooleanFilter(customProp,"true".equalsIgnoreCase(res));
      }
 else {
        try {
          request.setIntFilter(customProp,Integer.parseInt(res));
        }
 catch (        NumberFormatException e) {
          e.printStackTrace();
        }
      }
    }
  }
  request.setIntFilter(request.ALL.R_MINZOOM,zoom);
  request.saveState();
  NativeSearchResult res=searchObjectsForRendering(sleft,sright,stop,sbottom,zoom,request,true,rctx,"Nothing found");
  rctx.leftX=(float)(((double)sleft) / MapUtils.getPowZoom(31 - zoom));
  rctx.topY=(float)(((double)stop) / MapUtils.getPowZoom(31 - zoom));
  rctx.width=(int)((sright - sleft) / MapUtils.getPowZoom(31 - zoom - 8));
  rctx.height=(int)((sbottom - stop) / MapUtils.getPowZoom(31 - zoom - 8));
  request.clearState();
  if (request.searchRenderingAttribute(RenderingRuleStorageProperties.A_DEFAULT_COLOR)) {
    rctx.defaultColor=request.getIntPropertyValue(request.ALL.R_ATTR_COLOR_VALUE);
  }
  request.clearState();
  request.setIntFilter(request.ALL.R_MINZOOM,zoom);
  if (request.searchRenderingAttribute(RenderingRuleStorageProperties.A_SHADOW_RENDERING)) {
    rctx.shadowRenderingMode=request.getIntPropertyValue(request.ALL.R_ATTR_INT_VALUE);
    rctx.shadowRenderingColor=request.getIntPropertyValue(request.ALL.R_SHADOW_COLOR);
  }
  rctx.zoom=zoom;
  rctx.tileDivisor=(float)MapUtils.getPowZoom(31 - zoom);
  long search=time + System.currentTimeMillis();
  final RenderingGenerationResult rres=NativeSwingRendering.generateRenderingIndirect(rctx,res.nativeHandler,false,request,true);
  long rendering=time + System.currentTimeMillis() - search;
  InputStream inputStream=new InputStream(){
    int nextInd=0;
    @Override public int read() throws IOException {
      if (nextInd >= rres.bitmapBuffer.capacity()) {
        return -1;
      }
      byte b=rres.bitmapBuffer.get(nextInd++);
      if (b < 0) {
        return b + 256;
      }
 else {
        return b;
      }
    }
  }
;
  Iterator<ImageReader> readers=ImageIO.getImageReadersByFormatName("png");
  ImageReader reader=readers.next();
  reader.setInput(new MemoryCacheImageInputStream(inputStream),true);
  BufferedImage img=reader.read(0);
  long last=time + System.currentTimeMillis() - rendering;
  System.out.println(" TIMES search - " + search + " rendering - "+ rendering+ " unpack - "+ last);
  return img;
}
