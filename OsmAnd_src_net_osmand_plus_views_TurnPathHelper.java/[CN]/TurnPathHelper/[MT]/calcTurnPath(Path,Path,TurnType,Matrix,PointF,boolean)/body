{
  if (turnType == null) {
    return;
  }
  pathForTurn.reset();
  if (outlay != null) {
    outlay.reset();
  }
  int ha=72;
  int wa=72;
  int th=12;
  pathForTurn.moveTo(wa / 2,ha - 1);
  float sarrowL=22;
  float harrowL=(float)Math.sqrt(2) * sarrowL;
  float spartArrowL=(float)((sarrowL - th / Math.sqrt(2)) / 2);
  float hpartArrowL=(float)(harrowL - th) / 2;
  if (TurnType.C == turnType.getValue()) {
    int h=(int)(ha - hpartArrowL - 16);
    pathForTurn.rMoveTo(th,0);
    pathForTurn.rLineTo(0,-h);
    pathForTurn.rLineTo(hpartArrowL,0);
    pathForTurn.rLineTo(-harrowL / 2,-harrowL / 2);
    pathForTurn.rLineTo(-harrowL / 2,harrowL / 2);
    pathForTurn.rLineTo(hpartArrowL,0);
    pathForTurn.rLineTo(0,h);
  }
 else   if (TurnType.TR == turnType.getValue() || TurnType.TL == turnType.getValue()) {
    int b=TurnType.TR == turnType.getValue() ? 1 : -1;
    float quadShiftX=18;
    float quadShiftY=18;
    int wl=10;
    int h=(int)(ha - quadShiftY - harrowL + hpartArrowL - 5);
    int sl=wl + th / 2;
    pathForTurn.rMoveTo(-b * sl,0);
    pathForTurn.rLineTo(0,-h);
    pathForTurn.rQuadTo(0,-quadShiftY,b * quadShiftX,-quadShiftY);
    pathForTurn.rLineTo(b * wl,0);
    pathForTurn.rLineTo(0,hpartArrowL);
    pathForTurn.rLineTo(b * harrowL / 2,-harrowL / 2);
    pathForTurn.rLineTo(-b * harrowL / 2,-harrowL / 2);
    pathForTurn.rLineTo(0,hpartArrowL);
    pathForTurn.rLineTo(-b * wl,0);
    pathForTurn.rQuadTo(-b * (quadShiftX + th),0,-b * (quadShiftX + th),quadShiftY + th);
    pathForTurn.rLineTo(0,h);
  }
 else   if (TurnType.KL == turnType.getValue() || TurnType.KR == turnType.getValue()) {
    int b=TurnType.KR == turnType.getValue() ? 1 : -1;
    float quadShiftX=14;
    float quadShiftY=14;
    th=10;
    spartArrowL=(float)((sarrowL - th / Math.sqrt(2)) / 2);
    hpartArrowL=(float)(harrowL - th) / 2;
    int h=12;
    int lh=15;
    int sl=th / 2;
    pathForTurn.rMoveTo(-b * (sl + 10),0);
    pathForTurn.rLineTo(0,-lh);
    pathForTurn.rQuadTo(0,-quadShiftY,b * quadShiftX,-quadShiftY);
    pathForTurn.rQuadTo(b * quadShiftX,0,b * quadShiftX,-quadShiftY);
    pathForTurn.rLineTo(0,-h);
    pathForTurn.rLineTo(b * hpartArrowL,0);
    pathForTurn.rLineTo(-b * harrowL / 2,-harrowL / 2);
    pathForTurn.rLineTo(-b * harrowL / 2,harrowL / 2);
    pathForTurn.rLineTo(b * hpartArrowL,0);
    pathForTurn.rLineTo(0,h);
    pathForTurn.rQuadTo(0,quadShiftY - th,-b * (quadShiftX - th),quadShiftY - th);
    pathForTurn.rQuadTo(-b * (quadShiftX + th),0,-b * (quadShiftX + th),quadShiftY + th);
    pathForTurn.rLineTo(0,lh);
  }
 else   if (TurnType.TSLR == turnType.getValue() || TurnType.TSLL == turnType.getValue()) {
    int b=TurnType.TSLR == turnType.getValue() ? 1 : -1;
    int h=24;
    int quadShiftY=22;
    float quadShiftX=(float)(quadShiftY / (1 + Math.sqrt(2)));
    float nQuadShiftX=(sarrowL - 2 * spartArrowL) - quadShiftX - th;
    float nQuadShifty=quadShiftY + (sarrowL - 2 * spartArrowL);
    pathForTurn.rMoveTo(-b * 4,0);
    pathForTurn.rLineTo(0,-h);
    pathForTurn.rQuadTo(0,-quadShiftY + quadShiftX,b * quadShiftX,-quadShiftY);
    pathForTurn.rLineTo(b * spartArrowL,spartArrowL);
    pathForTurn.rLineTo(0,-sarrowL);
    pathForTurn.rLineTo(-b * sarrowL,0);
    pathForTurn.rLineTo(b * spartArrowL,spartArrowL);
    pathForTurn.rQuadTo(b * nQuadShiftX,-nQuadShiftX,b * nQuadShiftX,nQuadShifty);
    pathForTurn.rLineTo(0,h);
  }
 else   if (TurnType.TSHR == turnType.getValue() || TurnType.TSHL == turnType.getValue()) {
    int b=TurnType.TSHR == turnType.getValue() ? 1 : -1;
    int h=28;
    float quadShiftX=22;
    int sh=10;
    float quadShiftY=-(float)(quadShiftX / (1 + Math.sqrt(2)));
    float nQuadShiftX=-(sarrowL - 2 * spartArrowL) - quadShiftX - th;
    float nQuadShiftY=-quadShiftY + (sarrowL - 2 * spartArrowL);
    pathForTurn.rMoveTo(-b * sh,0);
    pathForTurn.rLineTo(0,-h);
    pathForTurn.rQuadTo(0,-(quadShiftX - quadShiftY),b * quadShiftX,quadShiftY);
    pathForTurn.rLineTo(-b * spartArrowL,spartArrowL);
    pathForTurn.rLineTo(b * sarrowL,0);
    pathForTurn.rLineTo(0,-sarrowL);
    pathForTurn.rLineTo(-b * spartArrowL,spartArrowL);
    pathForTurn.rCubicTo(b * nQuadShiftX / 2,nQuadShiftX / 2,b * nQuadShiftX,nQuadShiftX / 2,b * nQuadShiftX,nQuadShiftY);
    pathForTurn.rLineTo(0,h);
  }
 else   if (TurnType.TU == turnType.getValue() || TurnType.TRU == turnType.getValue()) {
    int h=40;
    int b=TurnType.TU == turnType.getValue() ? 1 : -1;
    float quadShiftX=10;
    float quadShiftY=10;
    int sm=10;
    pathForTurn.rMoveTo(b * 28,0);
    pathForTurn.rLineTo(0,-h);
    pathForTurn.rQuadTo(0,-(quadShiftY + th),-b * (quadShiftX + th),-(quadShiftY + th));
    pathForTurn.rQuadTo(-b * (quadShiftX + th),0,-b * (quadShiftX + th),(quadShiftY + th));
    pathForTurn.rLineTo(0,sm);
    pathForTurn.rLineTo(-b * hpartArrowL,0);
    pathForTurn.rLineTo(b * harrowL / 2,harrowL / 2);
    pathForTurn.rLineTo(b * harrowL / 2,-harrowL / 2);
    pathForTurn.rLineTo(-b * hpartArrowL,0);
    pathForTurn.rLineTo(0,-sm);
    pathForTurn.rQuadTo(0,-quadShiftX,b * quadShiftX,-quadShiftY);
    pathForTurn.rQuadTo(b * quadShiftX,0,b * quadShiftX,quadShiftY);
    pathForTurn.rLineTo(0,h);
  }
 else   if (TurnType.OFFR == turnType.getValue()) {
    int h=(int)(ha - hpartArrowL - 16);
    pathForTurn.rMoveTo(th,0);
    pathForTurn.rLineTo(0,-h / 4);
    pathForTurn.rLineTo(-th,0);
    pathForTurn.rLineTo(0,h / 4);
    pathForTurn.rLineTo(th,0);
    pathForTurn.rMoveTo(0,-h / 2);
    pathForTurn.rLineTo(0,-h / 4);
    pathForTurn.rLineTo(-th,0);
    pathForTurn.rLineTo(0,h / 4);
    pathForTurn.rLineTo(th,0);
    pathForTurn.rMoveTo(0,-h / 2 + 1);
    pathForTurn.rLineTo(hpartArrowL,0);
    pathForTurn.rLineTo(-harrowL / 2,-harrowL / 2);
    pathForTurn.rLineTo(-harrowL / 2,harrowL / 2);
    pathForTurn.rLineTo(hpartArrowL + th,0);
  }
 else   if (turnType != null && turnType.isRoundAbout() && USE_NEW_RNDB) {
    int out=turnType.getExitOut();
    boolean leftSide=turnType.isLeftSide();
    float radEndOfArrow=44;
    float radInnerCircle=10;
    float radOuterCircle=radInnerCircle + 8;
    float radBottom=radOuterCircle + 10;
    float radStepInter=radOuterCircle + 6;
    float radArrowTriangle1=radOuterCircle + 7;
    float radArrowTriangle2=radOuterCircle + 8;
    float widthStepIn=8;
    float widthStepInter=6;
    float widthArrow=22;
    double dfL=(leftSide ? 1 : -1) * Math.asin(widthStepIn / (2.0 * radBottom));
    double dfAr2=(leftSide ? 1 : -1) * Math.asin(widthArrow / (2.0 * radArrowTriangle2));
    double dfStepInter=(leftSide ? 1 : -1) * Math.asin(widthStepInter / radStepInter);
    double dfAr=Math.asin(radBottom * Math.sin(dfL) / radArrowTriangle1);
    double dfOut=Math.asin(radBottom * Math.sin(dfL) / radOuterCircle);
    double dfStepOut=Math.asin(radStepInter * Math.sin(dfStepInter) / radOuterCircle);
    double dfIn=Math.asin(radBottom * Math.sin(dfL) / radInnerCircle);
    double minDelta=Math.abs(dfIn * 2 / Math.PI * 180) + 2;
    boolean showSteps=SHOW_STEPS && !mini;
    double rot=alignRotation(turnType.getTurnAngle(),leftSide,minDelta,out) / 180 * Math.PI;
    float cx=wa / 2;
    float cy=ha / 2;
    float potentialArrowEndX=(float)(Math.sin(rot) * radEndOfArrow);
    float potentialArrowEndY=(float)(Math.cos(rot) * radEndOfArrow);
    if (potentialArrowEndX > cx) {
      cx=potentialArrowEndX;
    }
 else     if (potentialArrowEndX < -cx) {
      cx=2 * cx + potentialArrowEndX;
    }
    if (potentialArrowEndY > cy) {
      cy=2 * cy - potentialArrowEndY;
    }
 else     if (potentialArrowEndY < -cy) {
      cy=-potentialArrowEndY;
    }
    if (center != null) {
      center.set(cx,cy);
    }
    RectF qrOut=new RectF(cx - radOuterCircle,cy - radOuterCircle,cx + radOuterCircle,cy + radOuterCircle);
    RectF qrIn=new RectF(cx - radInnerCircle,cy - radInnerCircle,cx + radInnerCircle,cy + radInnerCircle);
    if (outlay != null && !mini) {
      outlay.addArc(qrOut,0,360);
      outlay.addArc(qrIn,0,-360);
    }
    pathForTurn.moveTo(getProjX(dfOut,cx,cy,radOuterCircle),getProjY(dfOut,cx,cy,radOuterCircle));
    if (out <= 1) {
      showSteps=false;
    }
    if (showSteps && outlay != null) {
      double totalStepInter=(out - 1) * dfStepOut;
      double st=(rot - 2 * dfOut - totalStepInter) / out;
      if ((rot > 0) != (st > 0)) {
        showSteps=false;
      }
      if (Math.abs(st) < Math.PI / 60) {
        showSteps=false;
      }
      if (showSteps) {
        outlay.moveTo(getProjX(dfOut,cx,cy,radOuterCircle),getProjY(dfOut,cx,cy,radOuterCircle));
        for (int i=0; i < out - 1; i++) {
          outlay.arcTo(qrOut,startArcAngle(dfOut + i * (st + dfStepOut)),sweepArcAngle(st));
          arcLineTo(outlay,dfOut + (i + 1) * (st + dfStepOut) - dfStepOut / 2 - dfStepInter / 2,cx,cy,radStepInter);
          arcLineTo(outlay,dfOut + (i + 1) * (st + dfStepOut) - dfStepOut / 2 + dfStepInter / 2,cx,cy,radStepInter);
          arcLineTo(outlay,dfOut + (i + 1) * (st + dfStepOut),cx,cy,radOuterCircle);
        }
        outlay.arcTo(qrOut,startArcAngle(rot - dfOut - st),sweepArcAngle(st));
        arcLineTo(outlay,rot - dfIn,cx,cy,radInnerCircle);
        outlay.arcTo(qrIn,startArcAngle(rot - dfIn),-sweepArcAngle(rot - dfIn - dfIn));
      }
    }
    pathForTurn.arcTo(qrOut,startArcAngle(dfOut),sweepArcAngle(rot - dfOut - dfOut));
    arcLineTo(pathForTurn,rot - dfAr,cx,cy,radArrowTriangle1);
    arcQuadTo(pathForTurn,rot - dfAr,radArrowTriangle1,rot - dfAr2,radArrowTriangle2,rot,radEndOfArrow,4.5f,cx,cy);
    arcQuadTo(pathForTurn,rot - dfAr2,radArrowTriangle2,rot,radEndOfArrow,rot + dfAr2,radArrowTriangle2,4.5f,cx,cy);
    arcQuadTo(pathForTurn,rot,radEndOfArrow,rot + dfAr2,radArrowTriangle2,rot + dfAr,radArrowTriangle1,4.5f,cx,cy);
    arcLineTo(pathForTurn,rot + dfAr,cx,cy,radArrowTriangle1);
    arcLineTo(pathForTurn,rot + dfIn,cx,cy,radInnerCircle);
    pathForTurn.arcTo(qrIn,startArcAngle(rot + dfIn),sweepArcAngle(-rot - dfIn - dfIn));
    arcLineTo(pathForTurn,-dfL,cx,cy,radBottom);
    arcLineTo(pathForTurn,dfL,cx,cy,radBottom);
  }
 else   if (turnType != null && turnType.isRoundAbout()) {
    float t=turnType.getTurnAngle();
    boolean leftSide=turnType.isLeftSide();
    double minTurn=25;
    if (t >= 170 && t < 215) {
      t=215;
    }
 else     if (t > 155 && t < 170) {
      t=155;
    }
    float sweepAngle=(t - 360) - 180;
    if (sweepAngle < -360) {
      sweepAngle+=360;
    }
    if (leftSide && sweepAngle < 0) {
      sweepAngle+=360;
    }
    float r1=ha / 3f - 1;
    float r2=r1 - 9;
    float angleToRot=leftSide ? -0.3f : 0.3f;
    int cx=wa / 2;
    int cy=ha / 2 - 2;
    if (leftSide) {
      pathForTurn.moveTo(cx - 8,ha - 1);
      pathForTurn.lineTo(cx - 8,cy + r1);
    }
 else {
      pathForTurn.moveTo(cx,ha - 1);
      pathForTurn.lineTo(cx,cy + r1);
    }
    RectF r=new RectF(cx - r1,cy - r1,cx + r1,cy + r1);
    int out=turnType.getExitOut();
    if (out < 1) {
      out=1;
    }
    float prev=90;
    float init=90;
    float step=sweepAngle / out;
    for (int i=1; i <= out; i++) {
      float to=step * i;
      if (i == out) {
        pathForTurn.arcTo(r,prev,to - prev + init);
      }
 else {
        float tsRad=(float)((to - step / 8 + 180) * Math.PI / 180f);
        float tsRad2=(float)((to + step / 8 + 180) * Math.PI / 180f);
        pathForTurn.arcTo(r,prev,to - step / 6 - prev + init);
        pathForTurn.lineTo(cx + (r1 + 10) * (float)Math.sin(tsRad),cy - (r1 + 10) * (float)Math.cos(tsRad));
        pathForTurn.lineTo(cx + (r1 + 10) * (float)Math.sin(tsRad2),cy - (r1 + 10) * (float)Math.cos(tsRad2));
        prev=to + step / 6 + init;
      }
    }
    float angleRad=(float)((180 + sweepAngle) * Math.PI / 180f);
    pathForTurn.lineTo(cx + (r1 + 4) * (float)Math.sin(angleRad),cy - (r1 + 4) * (float)Math.cos(angleRad));
    pathForTurn.lineTo(cx + (r1 + 6) * (float)Math.sin(angleRad + angleToRot / 2),cy - (r1 + 6) * (float)Math.cos(angleRad + angleToRot / 2));
    pathForTurn.lineTo(cx + (r1 + 14) * (float)Math.sin(angleRad - angleToRot / 2),cy - (r1 + 12) * (float)Math.cos(angleRad - angleToRot / 2));
    pathForTurn.lineTo(cx + (r1 + 6) * (float)Math.sin(angleRad - 3 * angleToRot / 2),cy - (r1 + 6) * (float)Math.cos(angleRad - 3 * angleToRot / 2));
    pathForTurn.lineTo(cx + (r1 + 4) * (float)Math.sin(angleRad - angleToRot),cy - (r1 + 4) * (float)Math.cos(angleRad - angleToRot));
    pathForTurn.lineTo(cx + r2 * (float)Math.sin(angleRad - angleToRot),cy - r2 * (float)Math.cos(angleRad - angleToRot));
    r.set(cx - r2,cy - r2,cx + r2,cy + r2);
    pathForTurn.arcTo(r,360 + sweepAngle + 90,-sweepAngle);
    if (leftSide) {
      pathForTurn.lineTo(cx,cy + r2);
      pathForTurn.lineTo(cx,ha - 1);
    }
 else {
      pathForTurn.lineTo(cx - 8,cy + r2);
      pathForTurn.lineTo(cx - 8,ha - 1);
    }
    pathForTurn.close();
  }
  pathForTurn.close();
  if (transform != null) {
    pathForTurn.transform(transform);
  }
}
