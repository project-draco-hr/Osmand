{
  Location locationProjection=currentLocation;
  if (finalLocation == null || currentLocation == null) {
    isDeviatedFromRoute=false;
    return locationProjection;
  }
  float posTolerance=POSITION_TOLERANCE;
  if (currentLocation.hasAccuracy()) {
    posTolerance=POSITION_TOLERANCE / 2 + currentLocation.getAccuracy();
  }
  boolean calculateRoute=false;
synchronized (this) {
    if (route.isEmpty() || (settings.getPointToStart() != null)) {
      calculateRoute=true;
    }
 else {
      boolean finished=updateCurrentRouteStatus(currentLocation,posTolerance);
      if (finished) {
        return null;
      }
      List<Location> routeNodes=route.getImmutableAllLocations();
      int currentRoute=route.currentRoute;
      if (currentRoute > 0) {
        double dist=getOrthogonalDistance(currentLocation,routeNodes.get(currentRoute - 1),routeNodes.get(currentRoute));
        if (dist > 1.7 * posTolerance) {
          log.info("Recalculate route, because correlation  : " + dist);
          calculateRoute=true;
        }
        if (dist > 350) {
          if (isFollowingMode) {
            voiceRouter.announceOffRoute(dist);
            announceBackOnRoute=true;
          }
        }
      }
      Location next=route.getNextRouteLocation();
      boolean wrongMovementDirection=checkWrongMovementDirection(currentLocation,next);
      if (wrongMovementDirection && currentLocation.distanceTo(routeNodes.get(currentRoute)) > 2 * posTolerance) {
        log.info("Recalculate route, because wrong movement direction: " + currentLocation.distanceTo(routeNodes.get(currentRoute)));
        calculateRoute=true;
      }
      boolean uTurnIsNeeded=identifyUTurnIsNeeded(currentLocation,posTolerance);
      if (isFollowingMode) {
        boolean inRecalc=calculateRoute || isRouteBeingCalculated();
        if (!inRecalc && !wrongMovementDirection) {
          voiceRouter.updateStatus(currentLocation,false);
        }
 else         if (isDeviatedFromRoute) {
          voiceRouter.interruptRouteCommands();
        }
      }
      if (currentRoute > 0) {
        locationProjection=new Location(currentLocation);
        Location nextLocation=routeNodes.get(currentRoute);
        LatLon project=getProject(currentLocation,routeNodes.get(currentRoute - 1),routeNodes.get(currentRoute));
        locationProjection.setLatitude(project.getLatitude());
        locationProjection.setLongitude(project.getLongitude());
        float bearingTo=locationProjection.bearingTo(nextLocation);
        locationProjection.setBearing(bearingTo);
      }
    }
    lastFixedLocation=currentLocation;
    lastProjection=locationProjection;
  }
  if (calculateRoute) {
    recalculateRouteInBackground(false,currentLocation,finalLocation,intermediatePoints,currentGPXRoute,previousRoute.isCalculated() ? previousRoute : null,false,!targetPointsChanged);
  }
 else {
    Thread job=currentRunningJob;
    if (job instanceof RouteRecalculationThread) {
      RouteRecalculationThread thread=(RouteRecalculationThread)job;
      if (!thread.isParamsChanged()) {
        thread.stopCalculation();
      }
      if (announceBackOnRoute && isFollowingMode) {
        voiceRouter.announceBackOnRoute();
        announceBackOnRoute=false;
      }
    }
  }
  double projectDist=mode != null && mode.hasFastSpeed() ? posTolerance : posTolerance / 2;
  if (returnUpdatedLocation && locationProjection != null && currentLocation.distanceTo(locationProjection) < projectDist) {
    return locationProjection;
  }
 else {
    return currentLocation;
  }
}
