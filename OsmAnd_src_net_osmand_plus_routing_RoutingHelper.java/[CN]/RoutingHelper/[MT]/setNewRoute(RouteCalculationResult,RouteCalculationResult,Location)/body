{
  final boolean newRoute=!prevRoute.isCalculated();
  if (isFollowingMode) {
    if (lastFixedLocation != null) {
      start=lastFixedLocation;
    }
    boolean wrongMovementDirection=false;
    List<Location> routeNodes=res.getImmutableAllLocations();
    if (routeNodes != null && !routeNodes.isEmpty()) {
      int newCurrentRoute=lookAheadFindMinOrthogonalDistance(start,routeNodes,res.currentRoute,15);
      if (newCurrentRoute + 1 < routeNodes.size()) {
        wrongMovementDirection=checkWrongMovementDirection(start,routeNodes.get(newCurrentRoute + 1));
        if (!wrongMovementDirection) {
          evalWaitInterval=3000;
        }
 else {
          if (evalWaitInterval == 0) {
            evalWaitInterval=3000;
          }
          evalWaitInterval=evalWaitInterval * 3 / 2;
          evalWaitInterval=Math.min(evalWaitInterval,120000);
        }
      }
    }
    if (!wrongMovementDirection || newRoute) {
      voiceRouter.newRouteIsCalculated(newRoute);
    }
  }
  app.runInUIThread(new Runnable(){
    @Override public void run(){
      ValueHolder<Boolean> showToast=new ValueHolder<Boolean>();
      showToast.value=true;
      for (      IRouteInformationListener l : listeners) {
        l.newRouteIsCalculated(newRoute,showToast);
      }
      if (showToast.value) {
        String msg=app.getString(R.string.new_route_calculated_dist) + ": " + OsmAndFormatter.getFormattedDistance(res.getWholeDistance(),app);
        if (res.getRoutingTime() != 0f) {
          msg+=" (" + Algorithms.formatDuration((int)res.getRoutingTime()) + ")";
        }
        app.showToastMessage(msg);
      }
    }
  }
);
  app.getWaypointHelper().setNewRoute(res);
}
