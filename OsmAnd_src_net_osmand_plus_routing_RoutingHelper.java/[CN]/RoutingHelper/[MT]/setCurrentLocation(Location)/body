{
  Location locationProjection=currentLocation;
  if (finalLocation == null || currentLocation == null) {
    makeUturnWhenPossible=false;
    return locationProjection;
  }
  boolean calculateRoute=false;
synchronized (this) {
    if (route.isEmpty()) {
      calculateRoute=true;
    }
 else {
      float posTolerance=POSITION_TOLERANCE;
      if (currentLocation.hasAccuracy()) {
        posTolerance=POSITION_TOLERANCE / 2 + currentLocation.getAccuracy();
      }
      boolean finished=updateCurrentRouteStatus(currentLocation,posTolerance);
      if (finished) {
        return null;
      }
      List<Location> routeNodes=route.getImmutableLocations();
      int currentRoute=route.currentRoute;
      if (currentRoute > 0) {
        double dist=getOrthogonalDistance(currentLocation,routeNodes.get(currentRoute - 1),routeNodes.get(currentRoute));
        if (dist > 1.7 * posTolerance) {
          log.info("Recalculate route, because correlation  : " + dist);
          calculateRoute=true;
        }
      }
      Location next=route.getNextRouteLocation();
      boolean wrongMovementDirection=checkWrongMovementDirection(currentLocation,next);
      if (wrongMovementDirection && currentLocation.distanceTo(routeNodes.get(currentRoute)) > 2 * posTolerance) {
        log.info("Recalculate route, because wrong movement direction: " + currentLocation.distanceTo(routeNodes.get(currentRoute)));
        calculateRoute=true;
      }
      boolean uTurnIsNeeded=identifyUTurnIsNeeded(currentLocation,posTolerance);
      boolean inRecalc=calculateRoute || isRouteBeingCalculated();
      if (!inRecalc && !uTurnIsNeeded) {
        voiceRouter.updateStatus(currentLocation);
      }
 else       if (uTurnIsNeeded) {
        voiceRouter.makeUTStatus();
      }
      if (currentRoute > 0) {
        double dist=getOrthogonalDistance(currentLocation,routeNodes.get(currentRoute - 1),routeNodes.get(currentRoute));
        double projectDist=mode == ApplicationMode.CAR ? posTolerance : posTolerance / 2;
        locationProjection=new Location(locationProjection);
        if (dist < projectDist) {
          Location nextLocation=routeNodes.get(currentRoute);
          LatLon project=getProject(currentLocation,routeNodes.get(currentRoute - 1),routeNodes.get(currentRoute));
          locationProjection.setLatitude(project.getLatitude());
          locationProjection.setLongitude(project.getLongitude());
          if (locationProjection.hasBearing()) {
            float bearingTo=locationProjection.bearingTo(nextLocation);
            locationProjection.setBearing(bearingTo);
          }
        }
      }
    }
    lastFixedLocation=locationProjection;
  }
  if (calculateRoute) {
    recalculateRouteInBackground(lastFixedLocation,finalLocation,currentGPXRoute,route.isCalculated() ? route : null);
  }
  return locationProjection;
}
