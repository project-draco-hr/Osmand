{
  if (finalLocation == null || currentLocation == null) {
    makeUturnWhenPossible=false;
    suppressTurnPrompt=false;
    turnImminent=0;
    return;
  }
  boolean calculateRoute=false;
synchronized (this) {
    if (routeNodes.isEmpty() || routeNodes.size() <= currentRoute) {
      calculateRoute=true;
    }
 else {
      tryMarkPassedRoute(currentLocation);
      if (finishAtLocation(currentLocation)) {
        return;
      }
      if (currentRoute + 1 < routeNodes.size()) {
        float bearingRouteNext=routeNodes.get(currentRoute).bearingTo(routeNodes.get(currentRoute + 1));
        float bearingToRoute=currentLocation.bearingTo(routeNodes.get(currentRoute));
        if (Math.abs(bearingRouteNext - bearingToRoute) > 140 && Math.abs(bearingRouteNext - bearingToRoute) < 220) {
          if (log.isDebugEnabled()) {
            log.debug("Processed point bearingToRoute : " + bearingToRoute + " bearingRouteNext "+ bearingRouteNext);
          }
          updateCurrentRoute(currentRoute + 1);
        }
      }
      if (currentRoute + 2 < routeNodes.size()) {
        float bearingRouteNextNext=routeNodes.get(currentRoute + 1).bearingTo(routeNodes.get(currentRoute + 2));
        float bearingToRouteNext=currentLocation.bearingTo(routeNodes.get(currentRoute + 1));
        if (Math.abs(bearingRouteNextNext - bearingToRouteNext) > 165 && Math.abs(bearingRouteNextNext - bearingToRouteNext) < 195) {
          if (log.isDebugEnabled()) {
            log.debug("Processed point bearingToRouteNext : " + bearingToRouteNext + " bearingRouteNextNext "+ bearingRouteNextNext);
          }
          updateCurrentRoute(currentRoute + 2);
        }
      }
      if (currentRoute > 0) {
        float bearingRoute=routeNodes.get(currentRoute - 1).bearingTo(routeNodes.get(currentRoute));
        float bearingToRoute=currentLocation.bearingTo(routeNodes.get(currentRoute));
        float d=Math.abs(currentLocation.distanceTo(routeNodes.get(currentRoute)) * FloatMath.sin((bearingToRoute - bearingRoute) * 3.14f / 180f));
        if (d > LOCATION_TOLERANCE) {
          log.info("Recalculate route, because correlation  : " + d);
          calculateRoute=true;
        }
      }
      if (!calculateRoute) {
        float d=currentLocation.distanceTo(routeNodes.get(currentRoute));
        if (d > LOCATION_TOLERANCE) {
          if (currentRoute > 0) {
            float f1=currentLocation.distanceTo(routeNodes.get(currentRoute - 1)) + d;
            float c=routeNodes.get(currentRoute - 1).distanceTo(routeNodes.get(currentRoute));
            if (c * 2 < d + f1) {
              log.info("Recalculate route, because too far from points : " + d + " "+ f1+ " >> "+ c);
              calculateRoute=true;
            }
          }
 else {
            log.info("Recalculate route, because too far from start : " + d);
            calculateRoute=true;
          }
        }
      }
      directionDetection(currentLocation);
      if ((suppressTurnPrompt == false && calculateRoute == false) || makeUturnWhenPossible == true) {
        voiceRouter.updateStatus(currentLocation,makeUturnWhenPossible);
      }
    }
  }
  lastFixedLocation=currentLocation;
  if (suppressTurnPrompt && (currentLocation.distanceTo(routeNodes.get(currentRoute)) > 2 * LOCATION_TOLERANCE)) {
    calculateRoute=true;
  }
  if (calculateRoute) {
    recalculateRouteInBackground(lastFixedLocation,finalLocation,currentGPXRoute);
  }
}
