{
  List<Location> routeNodes=route.getImmutableLocations();
  int currentRoute=route.currentRoute;
  while (currentRoute + 1 < routeNodes.size()) {
    double dist=currentLocation.distanceTo(routeNodes.get(currentRoute));
    if (currentRoute > 0) {
      dist=getOrthogonalDistance(currentLocation,routeNodes.get(currentRoute - 1),routeNodes.get(currentRoute));
    }
    boolean processed=false;
    boolean longDistance=dist >= 250;
    int newCurrentRoute=lookAheadFindMinOrthogonalDistance(currentLocation,routeNodes,currentRoute,longDistance ? 15 : 8);
    double newDist=getOrthogonalDistance(currentLocation,routeNodes.get(newCurrentRoute),routeNodes.get(newCurrentRoute + 1));
    if (longDistance) {
      if (newDist < dist) {
        if (log.isDebugEnabled()) {
          log.debug("Processed by distance : (new) " + newDist + " (old) "+ dist);
        }
        processed=true;
      }
    }
 else     if (newDist < dist || newDist < 10) {
      if (dist > posTolerance) {
        processed=true;
        if (log.isDebugEnabled()) {
          log.debug("Processed by distance : " + newDist + " "+ dist);
        }
      }
 else {
        if (currentLocation.hasBearing() || lastFixedLocation != null) {
          float bearingToRoute=currentLocation.bearingTo(routeNodes.get(currentRoute));
          float bearingRouteNext=routeNodes.get(newCurrentRoute).bearingTo(routeNodes.get(newCurrentRoute + 1));
          float bearingMotion=currentLocation.hasBearing() ? currentLocation.getBearing() : lastFixedLocation.bearingTo(currentLocation);
          double diff=Math.abs(MapUtils.degreesDiff(bearingMotion,bearingToRoute));
          double diffToNext=Math.abs(MapUtils.degreesDiff(bearingMotion,bearingRouteNext));
          if (diff > diffToNext) {
            if (log.isDebugEnabled()) {
              log.debug("Processed point bearing deltas : " + diff + " "+ diffToNext);
            }
            processed=true;
          }
        }
      }
    }
    if (processed) {
      route.updateCurrentRoute(newCurrentRoute + 1);
      currentRoute=newCurrentRoute + 1;
    }
 else {
      break;
    }
  }
  if (getLeftDistanceNextIntermediate() < posTolerance * 1.5f) {
    showMessage(context.getString(R.string.arrived_at_intermediate_point));
    voiceRouter.arrivedIntermediatePoint();
  }
  if (intermediatePoints != null && intermediatePoints.size() > 0) {
    while (route.getIntermediatePointsToPass() > settings.getIntermediatePoints().size()) {
      settings.deleteIntermediatePoint(0);
    }
    while (route.getIntermediatePointsToPass() > intermediatePoints.size()) {
      intermediatePoints.remove(0);
    }
  }
  Location lastPoint=routeNodes.get(routeNodes.size() - 1);
  if (currentRoute > routeNodes.size() - 3 && currentLocation.distanceTo(lastPoint) < posTolerance * 1.5) {
    showMessage(context.getString(R.string.arrived_at_destination));
    voiceRouter.arrivedDestinationPoint();
    clearCurrentRoute(null,null);
    return true;
  }
  return false;
}
