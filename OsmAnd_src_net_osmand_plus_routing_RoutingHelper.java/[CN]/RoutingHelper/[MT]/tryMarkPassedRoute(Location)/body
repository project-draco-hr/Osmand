{
  float dist=currentLocation.distanceTo(routeNodes.get(currentRoute));
  while (currentRoute + 1 < routeNodes.size()) {
    float newDist=currentLocation.distanceTo(routeNodes.get(currentRoute + 1));
    boolean processed=false;
    if (newDist < dist) {
      if (newDist > 150) {
        if (currentRoute > 0) {
          float bearing=routeNodes.get(currentRoute - 1).bearingTo(routeNodes.get(currentRoute));
          float bearingMovement=currentLocation.bearingTo(routeNodes.get(currentRoute));
          float d=Math.abs(currentLocation.distanceTo(routeNodes.get(currentRoute)) * FloatMath.sin((bearingMovement - bearing) * 3.14f / 180f));
          if (d > 60) {
            processed=true;
          }
        }
 else {
          processed=true;
        }
        if (processed && log.isDebugEnabled()) {
          log.debug("Processed distance : " + newDist + " "+ dist);
        }
      }
 else {
        if (currentLocation.hasBearing() || lastFixedLocation != null) {
          float bearingToPoint=currentLocation.bearingTo(routeNodes.get(currentRoute));
          float bearingBetweenPoints=routeNodes.get(currentRoute).bearingTo(routeNodes.get(currentRoute + 1));
          float bearing=currentLocation.hasBearing() ? currentLocation.getBearing() : lastFixedLocation.bearingTo(currentLocation);
          if (Math.abs(bearing - bearingToPoint) > Math.abs(bearing - bearingBetweenPoints)) {
            if (log.isDebugEnabled()) {
              log.debug("Processed point bearing : " + Math.abs(currentLocation.getBearing() - bearingToPoint) + " "+ Math.abs(currentLocation.getBearing() - bearingBetweenPoints));
            }
            processed=true;
          }
        }
      }
    }
    if (processed) {
      updateCurrentRoute(currentRoute + 1);
      dist=newDist;
    }
 else {
      break;
    }
  }
}
