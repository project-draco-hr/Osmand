{
  boolean stateChanged=false;
  if ("filter".equals(name)) {
    attrsMap.clear();
    if (stack.size() > 0 && stack.peek() instanceof GroupRules) {
      GroupRules parent=((GroupRules)stack.peek());
      attrsMap.putAll(parent.groupAttributes);
    }
    parseAttributes(attrsMap);
    RenderingRule renderingRule=new RenderingRule(attrsMap,RenderingRulesStorage.this);
    if (stack.size() > 0 && stack.peek() instanceof GroupRules) {
      GroupRules parent=((GroupRules)stack.peek());
      parent.children.add(renderingRule);
    }
 else     if (stack.size() > 0 && stack.peek() instanceof RenderingRule) {
      RenderingRule parent=((RenderingRule)stack.peek());
      parent.addIfElseChildren(renderingRule);
    }
 else {
      registerGlobalRule(renderingRule,state,attrsMap);
    }
    stack.push(renderingRule);
  }
 else   if ("groupFilter".equals(name)) {
    attrsMap.clear();
    parseAttributes(attrsMap);
    RenderingRule renderingRule=new RenderingRule(attrsMap,RenderingRulesStorage.this);
    if (stack.size() > 0 && stack.peek() instanceof GroupRules) {
      GroupRules parent=((GroupRules)stack.peek());
      parent.addGroupFilter(renderingRule);
    }
 else     if (stack.size() > 0 && stack.peek() instanceof RenderingRule) {
      ((RenderingRule)stack.peek()).addIfChildren(renderingRule);
    }
 else {
      throw new XmlPullParserException("Group filter without parent");
    }
    stack.push(renderingRule);
  }
 else   if ("group".equals(name)) {
    GroupRules groupRules=new GroupRules();
    if (stack.size() > 0 && stack.peek() instanceof GroupRules) {
      GroupRules parent=((GroupRules)stack.peek());
      groupRules.groupAttributes.putAll(parent.groupAttributes);
      parent.childrenGroups.add(groupRules);
    }
    parseAttributes(groupRules.groupAttributes);
    stack.push(groupRules);
  }
 else   if ("order".equals(name)) {
    state=ORDER_RULES;
    stateChanged=true;
  }
 else   if ("text".equals(name)) {
    state=TEXT_RULES;
    stateChanged=true;
  }
 else   if ("point".equals(name)) {
    state=POINT_RULES;
    stateChanged=true;
  }
 else   if ("line".equals(name)) {
    state=LINE_RULES;
    stateChanged=true;
  }
 else   if ("polygon".equals(name)) {
    state=POLYGON_RULES;
    stateChanged=true;
  }
 else   if ("renderingAttribute".equals(name)) {
    String attr=parser.getAttributeValue("","name");
    @SuppressWarnings("unchecked") RenderingRule root=new RenderingRule(new HashMap<String,String>(),RenderingRulesStorage.this);
    renderingAttributes.put(attr,root);
    stack.push(root);
  }
 else   if ("renderingProperty".equals(name)) {
    String attr=parser.getAttributeValue("","attr");
    RenderingRuleProperty prop;
    String type=parser.getAttributeValue("","type");
    if ("boolean".equalsIgnoreCase(type)) {
      prop=RenderingRuleProperty.createInputBooleanProperty(attr);
    }
 else     if ("string".equalsIgnoreCase(type)) {
      prop=RenderingRuleProperty.createInputStringProperty(attr);
    }
 else {
      prop=RenderingRuleProperty.createInputIntProperty(attr);
    }
    prop.setDescription(parser.getAttributeValue("","description"));
    prop.setName(parser.getAttributeValue("","name"));
    if (parser.getAttributeValue("","possibleValues") != null) {
      prop.setPossibleValues(parser.getAttributeValue("","possibleValues").split(","));
    }
    PROPS.registerRule(prop);
  }
 else   if ("renderingConstant".equals(name)) {
    if (!renderingConstants.containsKey(parser.getAttributeValue("","name"))) {
      renderingConstants.put(parser.getAttributeValue("","name"),parser.getAttributeValue("","value"));
    }
  }
 else   if ("renderingStyle".equals(name)) {
    String depends=parser.getAttributeValue("","depends");
    if (depends != null && depends.length() > 0) {
      this.dependsStorage=resolver.resolve(depends,resolver);
    }
    if (dependsStorage != null) {
      dictionary=new ArrayList<String>(dependsStorage.dictionary);
      dictionaryMap=new LinkedHashMap<String,Integer>(dependsStorage.dictionaryMap);
      PROPS=new RenderingRuleStorageProperties(dependsStorage.PROPS);
    }
    internalRenderingName=parser.getAttributeValue("","name");
  }
 else   if ("renderer".equals(name)) {
    throw new XmlPullParserException("Rendering style is deprecated and no longer supported.");
  }
 else {
    log.warn("Unknown tag : " + name);
  }
  if (stateChanged) {
    tagValueGlobalRules[state]=new TIntObjectHashMap<RenderingRule>();
  }
}
