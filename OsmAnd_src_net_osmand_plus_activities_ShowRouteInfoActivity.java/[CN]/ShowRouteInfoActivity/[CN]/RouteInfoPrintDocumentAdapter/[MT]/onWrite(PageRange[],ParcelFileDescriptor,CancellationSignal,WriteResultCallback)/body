{
  ArrayList<Integer> writtenPagesArray=new ArrayList<Integer>();
  PDF pdf=null;
  InputStream fontInputStream=null;
  try {
    pdf=new PDF(new BufferedOutputStream(new FileOutputStream(destination.getFileDescriptor())));
    fontInputStream=getAssets().open("fonts/Roboto-Regular.ttf");
    Font font=new Font(pdf,fontInputStream,CodePage.UNICODE,true);
    font.setSize(PDF_FONT_SIZE);
    int totalLinesCount=totalLinesCount();
    int shift=0;
    if (!TextUtils.isEmpty(title)) {
      shift=1;
    }
    for (int i=0; i < totalPages; i++) {
      if (containsPage(pages,i)) {
        Page page=new Page(pdf,pageSize);
        page.setTextStart();
        page.setTextFont(font);
        page.setTextLocation(marginLeft,marginTop);
        page.setTextLeading(PDF_TEXT_LEADING);
        int startLineIndex=i * linesPerPage;
        for (int j=startLineIndex; (j < (startLineIndex + linesPerPage)) && (j < totalLinesCount); j++) {
          if ((j == 0) && (shift > 0)) {
            page.println(title);
          }
 else {
            RouteDirectionInfo model=list.get(j - shift);
            String distance=OsmAndFormatter.getFormattedDistance(model.distance,getMyApplication());
            String description=model.getDescriptionRoute(((OsmandApplication)getApplication()));
            String timeText=getTimeDescription(model);
            page.println(distance + " " + description+ " "+ timeText);
          }
        }
        page.setTextEnd();
        writtenPagesArray.add(i);
      }
    }
  }
 catch (  Exception e) {
    callback.onWriteFailed(e.toString());
    return;
  }
 finally {
    if (pdf != null) {
      try {
        pdf.close();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    if (fontInputStream != null) {
      try {
        fontInputStream.close();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  PageRange[] writtenPages=computeWrittenPages(writtenPagesArray);
  callback.onWriteFinished(writtenPages);
}
