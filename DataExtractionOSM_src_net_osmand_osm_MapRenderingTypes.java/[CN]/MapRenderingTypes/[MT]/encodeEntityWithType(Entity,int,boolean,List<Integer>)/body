{
  if (types == null) {
    types=new LinkedHashMap<String,MapRulType>();
    init(INIT_RULE_TYPES);
  }
  additionalTypes.clear();
  if ("coastline".equals(e.getTag(OSMTagKey.NATURAL))) {
    multipolygon=true;
  }
  boolean point=e instanceof Node;
  boolean polygon=multipolygon;
  if (!point && !polygon) {
    boolean area="yes".equals(e.getTag("area"));
    boolean highway=e.getTag("highway") != null;
    if (highway && !area) {
    }
 else {
      List<Long> ids=((Way)e).getNodeIds();
      if (ids.size() > 1) {
        polygon=((long)ids.get(0) == (long)ids.get(ids.size() - 1));
      }
    }
  }
  Collection<String> tagKeySet=e.getTagKeySet();
  if (tagKeySet.size() > 1 && tagKeySet.contains("building")) {
    LinkedHashSet<String> set=new LinkedHashSet<String>();
    set.add("building");
    set.addAll(tagKeySet);
    tagKeySet=set;
  }
  int pointType=0;
  int polylineType=0;
  int polygonType=0;
  for (int i=0; i < 2; i++) {
    if (i == 1 && !additionalTypes.isEmpty()) {
      break;
    }
    for (    String tag : tagKeySet) {
      if (types.containsKey(tag)) {
        MapRulType rType=types.get(tag);
        String val=i == 1 ? null : e.getTag(tag);
        if (rType.getMinZoom(val) > zoom) {
          continue;
        }
        int pr=point ? rType.getPointRule(val) : (polygon ? rType.getPolygonRule(val) : rType.getPolylineRule(val));
        int typeVal=rType.getType(val,MASK_13) << 2;
        if (pr == POINT_TYPE && pointType == 0) {
          pointType=POINT_TYPE | typeVal;
          additionalTypes.add(pointType);
        }
 else         if (!point && pr == POLYLINE_TYPE) {
          int attr=getLayerAttributes(e) << 12;
          boolean prevPoint=(polylineType == 0 && polygonType == 0);
          polylineType=POLYLINE_TYPE | (typeVal & MASK_12) | attr;
          if (tag.equals("highway") || prevPoint) {
            additionalTypes.add(0,polylineType);
          }
 else {
            additionalTypes.add(polylineType);
          }
        }
 else         if (polygon && (pr == POLYGON_WITH_CENTER_TYPE || pr == POLYGON_TYPE)) {
          boolean prevPoint=(polylineType == 0 && polygonType == 0);
          int attr=getLayerAttributes(e) << 12;
          polygonType=(multipolygon ? MULTY_POLYGON_TYPE : POLYGON_TYPE) | (typeVal & MASK_12) | attr;
          if (prevPoint) {
            additionalTypes.add(0,polygonType);
          }
 else {
            additionalTypes.add(polygonType);
          }
          if (pr == POLYGON_WITH_CENTER_TYPE) {
            pointType=POINT_TYPE | typeVal;
            additionalTypes.add(pointType);
          }
        }
 else         if (polygon && (pr == DEFAULT_POLYGON_BUILDING)) {
          int MAN_MADE=8;
          int SUBTYPE_BUILDING=1;
          if (polygonType == 0 && polylineType == 0) {
            int attr=getLayerAttributes(e) << 12;
            polygonType=(multipolygon ? MULTY_POLYGON_TYPE : POLYGON_TYPE) | (((SUBTYPE_BUILDING << 5) | MAN_MADE) << 2) | attr;
            additionalTypes.add(0,polygonType);
          }
          pointType=POINT_TYPE | typeVal;
          additionalTypes.add(pointType);
        }
      }
    }
  }
  int type=0;
  if (!additionalTypes.isEmpty()) {
    type=additionalTypes.get(0);
    additionalTypes.remove(0);
  }
  return type;
}
