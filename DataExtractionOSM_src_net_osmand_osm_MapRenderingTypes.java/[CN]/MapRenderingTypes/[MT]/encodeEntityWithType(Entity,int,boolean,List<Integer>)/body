{
  if (types == null) {
    types=new LinkedHashMap<String,MapRulType>();
    init();
  }
  addTypes.clear();
  if ("coastline".equals(e.getTag(OSMTagKey.NATURAL))) {
    multipolygon=true;
  }
  boolean point=e instanceof Node;
  boolean polygon=multipolygon;
  if (!point && !polygon) {
    List<Long> ids=((Way)e).getNodeIds();
    if (ids.size() > 1) {
      polygon=((long)ids.get(0) == (long)ids.get(ids.size() - 1));
    }
  }
  Collection<String> tagKeySet=e.getTagKeySet();
  if (tagKeySet.size() > 1 && tagKeySet.contains("building")) {
    LinkedHashSet<String> set=new LinkedHashSet<String>();
    set.add("building");
    set.addAll(tagKeySet);
    tagKeySet=set;
  }
  int pointType=0;
  int polylineType=0;
  int polygonType=0;
  for (int i=0; i < 2; i++) {
    if (i == 1 && !addTypes.isEmpty()) {
      break;
    }
    for (    String tag : tagKeySet) {
      if (types.containsKey(tag)) {
        MapRulType rType=types.get(tag);
        String val=i == 1 ? null : e.getTag(tag);
        if (rType.getLevel(val) < level) {
          continue;
        }
        int pr=point ? rType.getPointRule(val) : (polygon ? rType.getPolygonRule(val) : rType.getPolylineRule(val));
        int typeVal=rType.getType(val,MASK_13) << 2;
        if (pr == POINT_TYPE && pointType == 0) {
          pointType=POINT_TYPE | typeVal;
          addTypes.add(pointType);
        }
 else         if (!point && pr == POLYLINE_TYPE) {
          int attr=getLayerAttributes(e) << 12;
          boolean prevPoint=(polylineType == 0 && polygonType == 0);
          polylineType=POLYLINE_TYPE | (typeVal & MASK_12) | attr;
          if (((polylineType >> 2) & MASK_4) == HIGHWAY || prevPoint) {
            addTypes.add(0,polylineType);
          }
 else {
            addTypes.add(polylineType);
          }
        }
 else         if (polygon && (pr == POLYGON_WITH_CENTER_TYPE || pr == POLYGON_TYPE)) {
          boolean prevPoint=(polylineType == 0 && polygonType == 0);
          int attr=getLayerAttributes(e) << 12;
          polygonType=(multipolygon ? MULTY_POLYGON_TYPE : POLYGON_TYPE) | (typeVal & MASK_12) | attr;
          if (prevPoint) {
            addTypes.add(0,polygonType);
          }
 else {
            addTypes.add(polygonType);
          }
          if (pr == POLYGON_WITH_CENTER_TYPE) {
            pointType=POINT_TYPE | typeVal;
            addTypes.add(pointType);
          }
        }
 else         if (polygon && (pr == DEFAULT_POLYGON_BUILDING)) {
          if (polygonType == 0 && polylineType == 0) {
            polygonType=(multipolygon ? MULTY_POLYGON_TYPE : POLYGON_TYPE) | (((SUBTYPE_BUILDING << 5) | MAN_MADE) << 3);
            addTypes.add(0,polygonType);
          }
          pointType=POINT_TYPE | typeVal;
          addTypes.add(pointType);
        }
      }
    }
  }
  int type=0;
  if (addTypes.isEmpty()) {
    return type;
  }
  boolean twoBytes=true;
  int first=addTypes.get(0);
  addTypes.remove(0);
  if ((first & 3) == POLYLINE_TYPE) {
    int attr=0;
    if (((first >> 2) & MASK_4) == HIGHWAY) {
      twoBytes=false;
      attr=getHighwayAttributes(e) << 16;
    }
    type=attr | (first << 1);
  }
 else {
    type=first << 1;
  }
  if (twoBytes && addTypes.size() > 0) {
    type|=(addTypes.get(0) << 16);
    addTypes.remove(0);
  }
  if (!addTypes.isEmpty()) {
    type|=1;
  }
  return type;
}
