{
  RouteDirectionInfo nf=null;
  double DISTANCE_ACTION=35;
  if (zoom >= 17) {
    DISTANCE_ACTION=15;
  }
 else   if (zoom == 15) {
    DISTANCE_ACTION=70;
  }
 else   if (zoom < 15) {
    DISTANCE_ACTION=110;
  }
  double actionDist=0;
  Location previousAction=null;
  actionPoints.clear();
  int prevFinishPoint=-2;
  for (int i=0; i < routeNodes.size(); i++) {
    Location ls=routeNodes.get(i);
    if (nf != null) {
      int pnt=nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;
      if (pnt < i + cd) {
        nf=null;
      }
    }
    while (nf == null && it.hasNext()) {
      nf=it.next();
      int pnt=nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;
      if (pnt < i + cd) {
        nf=null;
      }
    }
    boolean action=nf != null && (nf.routePointOffset == i + cd || (nf.routePointOffset <= i + cd && i + cd <= nf.routeEndPointOffset));
    if (!action && previousAction == null) {
      continue;
    }
    boolean visible=leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude() && ls.getLatitude() <= topLatitude;
    if (!action) {
      if (previousAction != null) {
        float dist=ls.distanceTo(previousAction);
        actionDist+=dist;
        if (actionDist >= DISTANCE_ACTION) {
          actionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist,previousAction,ls));
          actionPoints.add(null);
          prevFinishPoint=i;
          previousAction=null;
          actionDist=0;
        }
 else {
          actionPoints.add(ls);
          previousAction=ls;
        }
      }
    }
 else {
      if (visible) {
        if (previousAction == null) {
          int ind=actionPoints.size();
          Location lprevious=ls;
          double dist=0;
          for (int k=i - 1; k >= -1; k--) {
            Location l=k == -1 ? lastProjection : routeNodes.get(k);
            float loc=lprevious.distanceTo(l);
            if (prevFinishPoint == k) {
              if (ind >= 2) {
                actionPoints.remove(ind - 2);
                actionPoints.remove(ind - 2);
              }
              prevFinishPoint=-2;
              break;
            }
            dist+=loc;
            if (dist >= DISTANCE_ACTION) {
              if (loc > 1) {
                actionPoints.add(ind,calculateProjection(1 - (dist - DISTANCE_ACTION) / loc,lprevious,l));
              }
              break;
            }
 else {
              actionPoints.add(ind,l);
              lprevious=l;
            }
          }
        }
        actionPoints.add(ls);
        previousAction=ls;
        actionDist=0;
      }
    }
  }
  if (previousAction != null) {
    actionPoints.add(null);
  }
}
