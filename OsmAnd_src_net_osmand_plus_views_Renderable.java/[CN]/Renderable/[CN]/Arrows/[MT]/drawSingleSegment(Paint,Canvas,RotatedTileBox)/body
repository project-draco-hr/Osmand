{
  if (culled != null && !culled.isEmpty() && zoom > 14 && QuadRect.trivialOverlap(tileBox.getLatLonBounds(),trackBounds)) {
    canvas.rotate(-tileBox.getRotate(),tileBox.getCenterPixelX(),tileBox.getCenterPixelY());
    float stroke=p.getStrokeWidth();
    float arrowSize=(float)Math.pow(2.0,zoom - 18) * 128;
    int pCol=p.getColor();
    p.setColor(Color.RED);
    float lastx=0;
    float lasty=0;
    boolean broken=true;
    int intp=conveyor;
    float clipL=-arrowSize;
    float clipB=-arrowSize;
    float clipT=canvas.getHeight() + arrowSize;
    float clipR=canvas.getWidth() + arrowSize;
    for (    GPXUtilities.WptPt pt : culled) {
      intp--;
      float x=tileBox.getPixXFromLatLon(pt.lat,pt.lon);
      float y=tileBox.getPixYFromLatLon(pt.lat,pt.lon);
      boolean nextBroken=true;
      if (Math.min(x,lastx) < clipR && Math.max(x,lastx) > clipL && Math.min(y,lasty) < clipT && Math.max(y,lasty) > clipB) {
        int segment=intp & 15;
        if (segment < 6) {
          p.setStrokeWidth(stroke * (3.25f - segment / 2f));
          if (!broken) {
            canvas.drawLine(lastx,lasty,x,y,p);
          }
          nextBroken=false;
          if (zoom > 15 && segment == 0) {
            double angle=Math.atan2(lasty - y,lastx - x);
            float newx1=x + (float)Math.cos(angle - 0.4) * arrowSize;
            float newy1=y + (float)Math.sin(angle - 0.4) * arrowSize;
            float newx2=x + (float)Math.cos(angle + 0.4) * arrowSize;
            float newy2=y + (float)Math.sin(angle + 0.4) * arrowSize;
            canvas.drawLine(newx1,newy1,x,y,p);
            canvas.drawLine(newx2,newy2,x,y,p);
          }
        }
      }
      broken=nextBroken;
      lastx=x;
      lasty=y;
    }
    canvas.rotate(tileBox.getRotate(),tileBox.getCenterPixelX(),tileBox.getCenterPixelY());
    p.setColor(pCol);
    p.setStrokeWidth(stroke);
  }
}
