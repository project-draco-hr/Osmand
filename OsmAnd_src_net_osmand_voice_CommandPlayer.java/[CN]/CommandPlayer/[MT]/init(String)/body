{
  prologSystem.clearTheory();
  voiceDir=null;
  if (voiceProvider != null) {
    File parent=new File(Environment.getExternalStorageDirectory(),ResourceManager.VOICE_PATH);
    voiceDir=new File(parent,voiceProvider);
    if (!voiceDir.exists()) {
      voiceDir=null;
      return ctx.getString(R.string.voice_data_unavailable);
    }
  }
  if (voiceDir != null) {
    long time=System.currentTimeMillis();
    boolean wrong=false;
    try {
      InputStream config;
      config=new FileInputStream(new File(voiceDir,"_config.p"));
      if (!wrong) {
        prologSystem.setTheory(new Theory(config));
      }
    }
 catch (    InvalidTheoryException e) {
      log.error("Loading voice config exception " + voiceProvider,e);
      wrong=true;
    }
catch (    IOException e) {
      log.error("Loading voice config exception " + voiceProvider,e);
      wrong=true;
    }
    if (wrong) {
      return ctx.getString(R.string.voice_data_corrupted);
    }
 else {
      boolean versionSupported=false;
      Var v=new Var("VERSION");
      SolveInfo s=prologSystem.solve(new Struct(P_VERSION,v));
      if (s.isSuccess()) {
        prologSystem.solveEnd();
        try {
          Term val=s.getVarValue(v.getName());
          if (val instanceof Number) {
            versionSupported=((Number)val).intValue() == IndexConstants.VOICE_VERSION;
          }
        }
 catch (        NoSolutionException e) {
        }
      }
      if (!versionSupported) {
        return ctx.getString(R.string.voice_data_not_supported);
      }
    }
    if (log.isInfoEnabled()) {
      log.info("Initializing voice subsystem  " + voiceProvider + " : "+ (System.currentTimeMillis() - time));
    }
  }
  return null;
}
