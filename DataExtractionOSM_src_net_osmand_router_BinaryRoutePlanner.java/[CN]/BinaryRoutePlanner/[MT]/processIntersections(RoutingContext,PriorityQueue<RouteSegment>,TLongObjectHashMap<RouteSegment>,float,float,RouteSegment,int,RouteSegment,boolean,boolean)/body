{
  byte searchDirection=reverseWaySearch ? (byte)-1 : (byte)1;
  boolean thereAreRestrictions=proccessRestrictions(ctx,segment.road,inputNext,reverseWaySearch);
  Iterator<RouteSegment> nextIterator=null;
  if (thereAreRestrictions) {
    nextIterator=ctx.segmentsToVisitPrescripted.iterator();
  }
  RouteSegment next=inputNext;
  boolean hasNext=nextIterator == null || nextIterator.hasNext();
  while (hasNext) {
    if (nextIterator != null) {
      next=nextIterator.next();
    }
    boolean nextPlusNotAllowed=(next.getSegmentStart() == next.road.getPointsLength() - 1) || visitedSegments.containsKey(calculateRoutePointId(next.road,next.getSegmentStart(),true));
    boolean nextMinusNotAllowed=(next.getSegmentStart() == 0) || visitedSegments.containsKey(calculateRoutePointId(next.road,next.getSegmentStart() - 1,false));
    boolean sameRoadFutureDirection=next.road.id == segment.road.id && next.getSegmentStart() == segmentEnd;
    boolean alreadyVisited=nextPlusNotAllowed && nextMinusNotAllowed;
    boolean skipRoad=sameRoadFutureDirection && !addSameRoadFutureDirection;
    if (!alreadyVisited && !skipRoad) {
      float distanceToEnd=h(ctx,distToFinalPoint,next);
      if (next.getDirectionAssigned() == -searchDirection) {
        next=new RouteSegment(next.getRoad(),next.getSegmentStart());
      }
      if (next.getParentRoute() == null || ctx.roadPriorityComparator(next.distanceFromStart,next.distanceToEnd,distFromStart,distanceToEnd) > 0) {
        if (next.getParentRoute() != null) {
          if (!graphSegments.remove(next)) {
            throw new IllegalStateException("Should be handled by direction flag");
          }
        }
        next.assignDirection(searchDirection);
        next.distanceFromStart=distFromStart;
        next.distanceToEnd=distanceToEnd;
        if (sameRoadFutureDirection) {
          next.setAllowedDirection((byte)(segment.getSegmentStart() < next.getSegmentStart() ? 1 : -1));
        }
        next.setParentRoute(segment);
        next.setParentSegmentEnd(segmentEnd);
        graphSegments.add(next);
      }
      if (ctx.visitor != null) {
        ctx.visitor.visitSegment(next,false);
      }
    }
 else     if (!sameRoadFutureDirection) {
      if (next.getDirectionAssigned() == searchDirection && distFromStart < next.distanceFromStart && next.road.id != segment.road.id) {
        if (ctx.config.heuristicCoefficient <= 1) {
          throw new IllegalStateException("distance from start " + distFromStart + " < "+ next.distanceFromStart);
        }
        next.distanceFromStart=distFromStart;
        next.setParentRoute(segment);
        next.setParentSegmentEnd(segmentEnd);
        if (ctx.visitor != null) {
          ctx.visitor.visitSegment(next,false);
        }
      }
    }
    if (nextIterator == null) {
      next=next.next;
      hasNext=next != null;
    }
 else {
      hasNext=nextIterator.hasNext();
    }
  }
}
