{
  byte direction=reverseWay ? (byte)-1 : (byte)1;
  boolean thereAreRestrictions=proccessRestrictions(ctx,segment.road,inputNext,reverseWay);
  Iterator<RouteSegment> nextIterator=null;
  if (thereAreRestrictions) {
    nextIterator=ctx.segmentsToVisitPrescripted.iterator();
  }
  RouteSegment next=inputNext;
  boolean hasNext=nextIterator == null || nextIterator.hasNext();
  while (hasNext) {
    if (nextIterator != null) {
      next=nextIterator.next();
    }
    boolean nextPlusNotAllowed=(next.segmentStart == next.road.getPointsLength() - 1) || visitedSegments.containsKey(calculateRoutePointId(next.road,next.segmentStart,true));
    boolean nextMinusNotAllowed=(next.segmentStart == 0) || visitedSegments.containsKey(calculateRoutePointId(next.road,next.segmentStart - 1,false));
    boolean alreadyVisited=nextPlusNotAllowed && nextMinusNotAllowed;
    if (!alreadyVisited) {
      double distanceToEnd=h(ctx,distToFinalPoint,next);
      if (next.directionAssigned == -direction) {
        next=new RouteSegment(next.getRoad(),next.segmentStart);
      }
      if (next.parentRoute == null || ctx.roadPriorityComparator(next.distanceFromStart,next.distanceToEnd,distFromStart,distanceToEnd) > 0) {
        if (next.parentRoute != null) {
          if (!graphSegments.remove(next)) {
            throw new IllegalStateException("Should handled by direction flag");
          }
        }
        next.directionAssigned=direction;
        next.distanceFromStart=distFromStart;
        next.distanceToEnd=distanceToEnd;
        next.parentRoute=segment;
        next.parentSegmentEnd=segmentEnd;
        graphSegments.add(next);
      }
      if (ctx.visitor != null) {
        ctx.visitor.visitSegment(next,false);
      }
    }
 else {
      if (next.directionAssigned == direction && distFromStart < next.distanceFromStart && next.road.id != segment.road.id) {
        next.distanceFromStart=distFromStart;
        next.parentRoute=segment;
        next.parentSegmentEnd=segmentEnd;
        if (ctx.visitor != null) {
          ctx.visitor.visitSegment(next,false);
        }
      }
    }
    if (nextIterator == null) {
      next=next.next;
      hasNext=next != null;
    }
 else {
      hasNext=nextIterator.hasNext();
    }
  }
}
