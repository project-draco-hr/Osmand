{
  ctx.timeToLoad=0;
  ctx.visitedSegments=0;
  ctx.timeToCalculate=System.nanoTime();
  Comparator<RouteSegment> segmentsComparator=new Comparator<RouteSegment>(){
    @Override public int compare(    RouteSegment o1,    RouteSegment o2){
      return ctx.roadPriorityComparator(o1.distanceFromStart,o1.distanceToEnd,o2.distanceFromStart,o2.distanceToEnd);
    }
  }
;
  Comparator<RouteSegment> nonHeuristicSegmentsComparator=new Comparator<RouteSegment>(){
    @Override public int compare(    RouteSegment o1,    RouteSegment o2){
      return roadPriorityComparator(o1.distanceFromStart,o1.distanceToEnd,o2.distanceFromStart,o2.distanceToEnd,0.5);
    }
  }
;
  PriorityQueue<RouteSegment> graphDirectSegments=new PriorityQueue<RouteSegment>(50,segmentsComparator);
  PriorityQueue<RouteSegment> graphReverseSegments=new PriorityQueue<RouteSegment>(50,segmentsComparator);
  TLongObjectHashMap<RouteSegment> visitedDirectSegments=new TLongObjectHashMap<RouteSegment>();
  TLongObjectHashMap<RouteSegment> visitedOppositeSegments=new TLongObjectHashMap<RouteSegment>();
  int targetEndX=end.road.getPoint31XTile(end.segmentStart);
  int targetEndY=end.road.getPoint31YTile(end.segmentStart);
  int startX=start.road.getPoint31XTile(start.segmentStart);
  int startY=start.road.getPoint31YTile(start.segmentStart);
  float estimatedDistance=(float)h(ctx,targetEndX,targetEndY,startX,startY);
  end.distanceToEnd=start.distanceToEnd=estimatedDistance;
  graphDirectSegments.add(start);
  graphReverseSegments.add(end);
  boolean inverse=false;
  boolean init=false;
  PriorityQueue<RouteSegment> graphSegments;
  if (inverse) {
    graphSegments=graphReverseSegments;
  }
 else {
    graphSegments=graphDirectSegments;
  }
  while (!graphSegments.isEmpty()) {
    RouteSegment segment=graphSegments.poll();
    ctx.visitedSegments++;
    if (ctx.visitor != null) {
      ctx.visitor.visitSegment(segment,true);
    }
    boolean routeFound=false;
    if (!inverse) {
      routeFound=processRouteSegment(ctx,false,graphDirectSegments,visitedDirectSegments,targetEndX,targetEndY,segment,visitedOppositeSegments);
    }
 else {
      routeFound=processRouteSegment(ctx,true,graphReverseSegments,visitedOppositeSegments,startX,startY,segment,visitedDirectSegments);
    }
    if (graphReverseSegments.isEmpty() || graphDirectSegments.isEmpty() || routeFound) {
      break;
    }
    if (!init) {
      inverse=!inverse;
      init=true;
    }
 else     if (ctx.planRouteIn2Directions()) {
      inverse=nonHeuristicSegmentsComparator.compare(graphDirectSegments.peek(),graphReverseSegments.peek()) > 0;
      if (graphDirectSegments.size() * 1.3 > graphReverseSegments.size()) {
        inverse=true;
      }
 else       if (graphDirectSegments.size() < 1.3 * graphReverseSegments.size()) {
        inverse=false;
      }
    }
 else {
      inverse=!ctx.getPlanRoadDirection().booleanValue();
    }
    if (inverse) {
      graphSegments=graphReverseSegments;
    }
 else {
      graphSegments=graphDirectSegments;
    }
    if (ctx.runTilesGC()) {
      unloadUnusedTiles(ctx,ctx.NUMBER_OF_DESIRABLE_TILES_IN_MEMORY);
    }
    if (ctx.runRelaxingStrategy()) {
      relaxNotNeededSegments(ctx,graphDirectSegments,true);
      relaxNotNeededSegments(ctx,graphReverseSegments,false);
    }
  }
  printDebugMemoryInformation(ctx,graphDirectSegments,graphReverseSegments,visitedDirectSegments,visitedOppositeSegments);
  return prepareResult(ctx,start,end);
}
