{
  final RouteDataObject road=segment.road;
  boolean initDirectionAllowed=checkIfInitialMovementAllowedOnSegment(ctx,reverseWaySearch,visitedSegments,segment,direction,road);
  boolean directionAllowed=initDirectionAllowed;
  float obstaclesTime=0;
  if (segment.getParentRoute() != null && directionAllowed) {
    obstaclesTime=(float)ctx.getRouter().calculateTurnTime(segment,direction ? segment.getRoad().getPointsLength() - 1 : 0,segment.getParentRoute(),segment.getParentSegmentEnd());
  }
  if (ctx.firstRoadId == calculateRoutePointId(road,segment.getSegmentStart(),true)) {
    if (direction && ctx.firstRoadDirection < 0) {
      obstaclesTime+=500;
    }
 else     if (!direction && ctx.firstRoadDirection > 0) {
      obstaclesTime+=500;
    }
  }
  float segmentDist=0;
  int segmentEnd=segment.getSegmentStart();
  while (directionAllowed) {
    int prevInd=segmentEnd;
    if (direction) {
      segmentEnd++;
    }
 else {
      segmentEnd--;
    }
    if (segmentEnd < 0 || segmentEnd >= road.getPointsLength()) {
      directionAllowed=false;
      continue;
    }
    final int intervalId=direction ? segmentEnd - 1 : segmentEnd;
    visitedSegments.put(calculateRoutePointId(road,intervalId,direction),segment);
    final int x=road.getPoint31XTile(segmentEnd);
    final int y=road.getPoint31YTile(segmentEnd);
    final int prevx=road.getPoint31XTile(prevInd);
    final int prevy=road.getPoint31YTile(prevInd);
    if (x == prevx && y == prevy) {
      continue;
    }
    if (RoutingContext.USE_BORDER_LINES) {
      int st=ctx.searchBorderLineIndex(y);
      int tt=ctx.searchBorderLineIndex(prevy);
      if (st != tt) {
        for (int i=Math.min(st,tt); i < Math.max(st,tt) & i < ctx.borderLines.length; i++) {
          Iterator<RouteDataBorderLinePoint> pnts=ctx.borderLines[i].borderPoints.iterator();
          boolean changed=false;
          while (pnts.hasNext()) {
            RouteDataBorderLinePoint o=pnts.next();
            if (o.id == road.id) {
              pnts.remove();
              changed=true;
            }
          }
          if (changed) {
            ctx.updateDistanceForBorderPoints(ctx.startX,ctx.startY,true);
            ctx.updateDistanceForBorderPoints(ctx.targetX,ctx.targetY,false);
          }
        }
      }
    }
    segmentDist+=squareRootDist(x,y,prevx,prevy);
    double obstacle=ctx.getRouter().defineRoutingObstacle(road,segmentEnd);
    if (obstacle < 0) {
      directionAllowed=false;
      continue;
    }
    obstaclesTime+=obstacle;
    boolean alreadyVisited=checkIfOppositieSegmentWasVisited(ctx,reverseWaySearch,graphSegments,segment,oppositeSegments,road,segmentEnd,direction,intervalId,segmentDist,obstaclesTime);
    if (alreadyVisited) {
      directionAllowed=false;
      continue;
    }
    final RouteSegment roadNext=ctx.loadRouteSegment(x,y,ctx.config.memoryLimitation - ctx.memoryOverhead);
    if (roadNext != null && !((roadNext == segment || roadNext.road.id == road.id) && roadNext.next == null)) {
      boolean outgoingConnections=false;
      RouteSegment r=roadNext;
      while (r != null && !outgoingConnections) {
        if (r.road.id != road.id || r.getSegmentStart() != 0 || r.road.getOneway() != 1) {
          outgoingConnections=true;
        }
        r=r.next;
      }
      if (outgoingConnections) {
        directionAllowed=false;
      }
      float distStartObstacles=segment.distanceFromStart + calculateTimeWithObstacles(ctx,road,segmentDist,obstaclesTime);
      processIntersections(ctx,graphSegments,visitedSegments,distStartObstacles,segment,segmentEnd,targetEndX,targetEndY,roadNext,reverseWaySearch,outgoingConnections);
    }
  }
  if (initDirectionAllowed && ctx.visitor != null) {
    ctx.visitor.visitSegment(segment,segmentEnd,true);
  }
}
