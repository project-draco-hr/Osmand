{
  if (i == 0) {
    return TurnType.valueOf(TurnType.C,false);
  }
  RouteSegmentResult prev=result.get(i - 1);
  if (prev.getObject().roundabout()) {
    return null;
  }
  RouteSegmentResult rr=result.get(i);
  if (rr.getObject().roundabout()) {
    int exit=1;
    RouteSegmentResult last=rr;
    for (int j=i; j < result.size(); j++) {
      RouteSegmentResult rnext=result.get(j);
      if (rnext.getObject().roundabout()) {
        last=rnext;
        boolean plus=rnext.getStartPointIndex() < rnext.getEndPointIndex();
        int k=rnext.getStartPointIndex();
        if (j == i) {
          k=plus ? k + 1 : k - 1;
        }
        while (k != rnext.getEndPointIndex()) {
          if (rnext.getAttachedRoutes(k).size() > 0) {
            exit++;
          }
          k=plus ? k + 1 : k - 1;
        }
      }
 else {
        break;
      }
    }
    TurnType t=TurnType.valueOf("EXIT" + exit,leftSide);
    t.setTurnAngle((float)MapUtils.degreesDiff(last.getBearingBegin(),prev.getBearingEnd()));
    return t;
  }
  TurnType t=null;
  if (prev != null) {
    double mpi=MapUtils.degreesDiff(prev.getBearingEnd(),rr.getBearingBegin());
    int[] lanes=null;
    if (mpi >= 50) {
      if (mpi < 60) {
        t=TurnType.valueOf(TurnType.TSLL,leftSide);
      }
 else       if (mpi < 120) {
        t=TurnType.valueOf(TurnType.TL,leftSide);
      }
 else       if (mpi < 135) {
        t=TurnType.valueOf(TurnType.TSHL,leftSide);
      }
 else {
        t=TurnType.valueOf(TurnType.TU,leftSide);
      }
    }
 else     if (mpi < -50) {
      if (mpi > -60) {
        t=TurnType.valueOf(TurnType.TSLR,leftSide);
      }
 else       if (mpi > -120) {
        t=TurnType.valueOf(TurnType.TR,leftSide);
      }
 else       if (mpi > -135) {
        t=TurnType.valueOf(TurnType.TSHR,leftSide);
      }
 else {
        t=TurnType.valueOf(TurnType.TU,leftSide);
      }
    }
 else {
      boolean kl=false;
      boolean kr=false;
      List<RouteSegmentResult> attachedRoutes=rr.getAttachedRoutes(rr.getStartPointIndex());
      int ls=prev.getObject().getLanes();
      int left=0;
      int right=0;
      boolean speak=highwayLowEnd(prev.getObject().getHighway()) || highwayLowEnd(rr.getObject().getHighway());
      if (attachedRoutes != null) {
        for (        RouteSegmentResult rs : attachedRoutes) {
          double ex=MapUtils.degreesDiff(rs.getBearingBegin(),rr.getBearingBegin());
          if (ex < 45 && ex >= 0) {
            kl=true;
            int lns=rs.getObject().getLanes();
            if (lns > 0) {
              right+=lns;
            }
            speak=speak || !highwayLowEnd(rs.getObject().getHighway());
          }
 else           if (ex > -45 && ex <= 0) {
            kr=true;
            int lns=rs.getObject().getLanes();
            if (lns > 0) {
              left+=lns;
            }
            speak=speak || !highwayLowEnd(rs.getObject().getHighway());
          }
        }
      }
      if (kr && left == 0) {
        left=1;
      }
 else       if (kl && right == 0) {
        right=1;
      }
      int current=rr.getObject().getLanes();
      if (current <= 0) {
        current=1;
      }
      if (ls >= 0) {
        lanes=new int[current + left + right];
        ls=current + left + right;
        for (int it=0; it < ls; it++) {
          if (it < left || it >= left + current) {
            lanes[it]=0;
          }
 else {
            lanes[it]=1;
          }
        }
      }
      if (kl) {
        t=TurnType.valueOf(TurnType.KL,leftSide);
        t.setSkipToSpeak(!speak);
      }
 else       if (kr) {
        t=TurnType.valueOf(TurnType.KR,leftSide);
        t.setSkipToSpeak(!speak);
      }
    }
    if (t != null) {
      t.setTurnAngle((float)-mpi);
      if (lanes != null) {
        t.setLanes(lanes);
      }
    }
  }
  return t;
}
