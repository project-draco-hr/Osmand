{
  final RouteDataObject road=segment.road;
  final int middle=segment.getSegmentStart();
  float obstaclePlusTime=0;
  float obstacleMinusTime=0;
  int oneway=ctx.getRouter().isOneWay(road);
  boolean minusAllowed;
  boolean plusAllowed;
  if (ctx.firstRoadId == calculateRoutePointId(road,middle,true)) {
    minusAllowed=ctx.firstRoadDirection <= 0;
    plusAllowed=ctx.firstRoadDirection >= 0;
  }
 else   if (!reverseWaySearch) {
    minusAllowed=oneway <= 0;
    plusAllowed=oneway >= 0;
  }
 else {
    minusAllowed=oneway >= 0;
    plusAllowed=oneway <= 0;
  }
  if (middle == road.getPointsLength() - 1 || visitedSegments.containsKey(calculateRoutePointId(road,middle,true)) || segment.getAllowedDirection() == -1) {
    plusAllowed=false;
  }
  if (middle == 0 || visitedSegments.containsKey(calculateRoutePointId(road,middle - 1,false)) || segment.getAllowedDirection() == 1) {
    minusAllowed=false;
  }
  int d=plusAllowed ? 1 : -1;
  if (segment.getParentRoute() != null) {
    if (plusAllowed && middle < segment.getRoad().getPointsLength() - 1) {
      obstaclePlusTime=(float)ctx.getRouter().calculateTurnTime(segment,segment.getRoad().getPointsLength() - 1,segment.getParentRoute(),segment.getParentSegmentEnd());
    }
    if (minusAllowed && middle > 0) {
      obstacleMinusTime=(float)ctx.getRouter().calculateTurnTime(segment,0,segment.getParentRoute(),segment.getParentSegmentEnd());
    }
  }
  float posSegmentDist=0;
  float negSegmentDist=0;
  while (minusAllowed || plusAllowed) {
    int segmentEnd=middle + d;
    boolean positive=d > 0;
    if (!minusAllowed && d > 0) {
      d++;
    }
 else     if (!plusAllowed && d < 0) {
      d--;
    }
 else {
      if (d <= 0) {
        d=-d + 1;
      }
 else {
        d=-d;
      }
    }
    if (segmentEnd < 0) {
      minusAllowed=false;
      continue;
    }
    if (segmentEnd >= road.getPointsLength()) {
      plusAllowed=false;
      continue;
    }
    int intervalId=positive ? segmentEnd - 1 : segmentEnd;
    long nds=calculateRoutePointId(road,intervalId,positive);
    visitedSegments.put(nds,segment);
    RouteSegment opposite=null;
    long opp=calculateRoutePointId(road,intervalId,!positive);
    if (oppositeSegments.containsKey(opp)) {
      opposite=oppositeSegments.get(opp);
      if (opposite.getSegmentStart() != segmentEnd) {
        opposite=null;
      }
    }
    int x=road.getPoint31XTile(segmentEnd);
    int y=road.getPoint31YTile(segmentEnd);
    if (positive) {
      posSegmentDist+=squareRootDist(x,y,road.getPoint31XTile(segmentEnd - 1),road.getPoint31YTile(segmentEnd - 1));
    }
 else {
      negSegmentDist+=squareRootDist(x,y,road.getPoint31XTile(segmentEnd + 1),road.getPoint31YTile(segmentEnd + 1));
    }
    if (positive) {
      double obstacle=ctx.getRouter().defineRoutingObstacle(road,segmentEnd);
      if (obstacle < 0) {
        plusAllowed=false;
        continue;
      }
      obstaclePlusTime+=obstacle;
    }
 else {
      double obstacle=ctx.getRouter().defineRoutingObstacle(road,segmentEnd);
      if (obstacle < 0) {
        minusAllowed=false;
        continue;
      }
      obstacleMinusTime+=obstacle;
    }
    RouteSegment next=ctx.loadRouteSegment(x,y,ctx.config.memoryLimitation - ctx.memoryOverhead);
    if (next != null || opposite != null) {
      float priority=(float)ctx.getRouter().defineSpeedPriority(road);
      float speed=(float)(ctx.getRouter().defineSpeed(road) * priority);
      if (speed == 0) {
        speed=(float)(ctx.getRouter().getMinDefaultSpeed() * priority);
      }
      float distOnRoadToPass=positive ? posSegmentDist : negSegmentDist;
      float distStartObstacles=segment.distanceFromStart + (positive ? obstaclePlusTime : obstacleMinusTime) + distOnRoadToPass / speed;
      if (opposite != null) {
        FinalRouteSegment frs=new FinalRouteSegment(road,segment.getSegmentStart());
        frs.setParentRoute(segment.getParentRoute());
        frs.setParentSegmentEnd(segment.getParentSegmentEnd());
        frs.reverseWaySearch=reverseWaySearch;
        frs.distanceFromStart=opposite.distanceFromStart + distStartObstacles;
        frs.distanceToEnd=0;
        frs.opposite=opposite;
        graphSegments.add(frs);
        if (positive) {
          plusAllowed=false;
        }
 else {
          minusAllowed=false;
        }
        continue;
      }
      if (next == null) {
        continue;
      }
      if ((next == segment || next.road.id == road.id) && next.next == null) {
        continue;
      }
      boolean outgoingConnections=false;
      RouteSegment r=next;
      while (r != null && !outgoingConnections) {
        if (r.road.id != road.id || r.getSegmentStart() != 0 || r.road.getOneway() != 1) {
          outgoingConnections=true;
        }
        r=r.next;
      }
      if (outgoingConnections) {
        if (positive) {
          plusAllowed=false;
        }
 else {
          minusAllowed=false;
        }
      }
      float distToFinalPoint=(float)squareRootDist(x,y,targetEndX,targetEndY);
      processIntersections(ctx,graphSegments,visitedSegments,distStartObstacles,distToFinalPoint,segment,segmentEnd,next,reverseWaySearch,outgoingConnections);
    }
  }
}
