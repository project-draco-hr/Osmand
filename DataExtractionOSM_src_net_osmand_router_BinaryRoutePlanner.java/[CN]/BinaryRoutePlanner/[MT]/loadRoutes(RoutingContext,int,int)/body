{
  int tileC=(tileX << ctx.getZoomToLoadTileWithRoads()) + tileY;
  if (ctx.loadedTiles.contains(tileC)) {
    return;
  }
  long now=System.nanoTime();
  int zoomToLoad=31 - ctx.getZoomToLoadTileWithRoads();
  SearchRequest<BinaryMapDataObject> request=BinaryMapIndexReader.buildSearchRequest(tileX << zoomToLoad,(tileX + 1) << zoomToLoad,tileY << zoomToLoad,(tileY + 1) << zoomToLoad,15);
  request.setSearchFilter(new BinaryMapIndexReader.SearchFilter(){
    @Override public boolean accept(    TIntArrayList types,    MapIndex index){
      for (int j=0; j < types.size(); j++) {
        int wholeType=types.get(j);
        TagValuePair pair=index.decodeType(wholeType);
        if (pair != null) {
          int t=wholeType & 3;
          if (t == MapRenderingTypes.POINT_TYPE) {
            if (ctx.getRouter().acceptPoint(pair)) {
              return true;
            }
          }
 else           if (t == MapRenderingTypes.POLYLINE_TYPE) {
            if (ctx.getRouter().acceptLine(pair)) {
              return true;
            }
          }
        }
      }
      return false;
    }
  }
);
  for (  BinaryMapIndexReader r : map) {
    r.searchMapIndex(request);
    for (    BinaryMapDataObject o : request.getSearchResults()) {
      BinaryMapDataObject old=ctx.idObjects.get(o.getId());
      if (old != null && old.getPointsLength() >= o.getPointsLength()) {
        continue;
      }
      ctx.idObjects.put(o.getId(),o);
      for (int j=0; j < o.getPointsLength(); j++) {
        long l=(((long)o.getPoint31XTile(j)) << 31) + (long)o.getPoint31YTile(j);
        RouteSegment segment=new RouteSegment();
        segment.road=o;
        segment.segmentEnd=segment.segmentStart=j;
        if (ctx.routes.get(l) != null) {
          segment.next=ctx.routes.get(l);
        }
        ctx.routes.put(l,segment);
      }
    }
    ctx.loadedTiles.add(tileC);
    ctx.timeToLoad+=(System.nanoTime() - now);
  }
}
