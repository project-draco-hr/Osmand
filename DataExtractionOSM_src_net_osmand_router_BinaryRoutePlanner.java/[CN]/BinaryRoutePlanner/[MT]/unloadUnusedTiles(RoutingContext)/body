{
  float desirableSize=ctx.config.memoryLimitation * 0.7f;
  List<RoutingTile> list=new ArrayList<RoutingContext.RoutingTile>();
  TIntObjectIterator<RoutingTile> it=ctx.tiles.iterator();
  int loaded=0;
  while (it.hasNext()) {
    it.advance();
    RoutingTile t=it.value();
    if (t.isLoaded()) {
      list.add(t);
      loaded++;
    }
  }
  ctx.maxLoadedTiles=Math.max(ctx.maxLoadedTiles,ctx.getCurrentlyLoadedTiles());
  Collections.sort(list,new Comparator<RoutingTile>(){
    private int pow(    int base,    int pw){
      int r=1;
      for (int i=0; i < pw; i++) {
        r*=base;
      }
      return r;
    }
    @Override public int compare(    RoutingTile o1,    RoutingTile o2){
      int v1=(o1.access + 1) * pow(10,o1.getUnloadCont() - 1);
      int v2=(o2.access + 1) * pow(10,o2.getUnloadCont() - 1);
      return v1 < v2 ? -1 : (v1 == v2 ? 0 : 1);
    }
  }
);
  while (ctx.getCurrentEstimatedSize() >= desirableSize && list.size() > loaded / 5) {
    RoutingTile unload=list.remove(0);
    unload.access=0;
    ctx.unloadTile(unload,true);
  }
}
