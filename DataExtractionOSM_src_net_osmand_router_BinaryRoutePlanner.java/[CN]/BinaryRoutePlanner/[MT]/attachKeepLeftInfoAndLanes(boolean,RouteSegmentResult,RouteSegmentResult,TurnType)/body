{
  int[] lanes=null;
  boolean kl=false;
  boolean kr=false;
  List<RouteSegmentResult> attachedRoutes=rr.getAttachedRoutes(rr.getStartPointIndex());
  int ls=prev.getObject().getLanes();
  int left=0;
  int right=0;
  boolean speak=highwayLowEnd(prev.getObject().getHighway()) || highwayLowEnd(rr.getObject().getHighway());
  if (attachedRoutes != null) {
    for (    RouteSegmentResult rs : attachedRoutes) {
      double ex=MapUtils.degreesDiff(rs.getBearingBegin(),rr.getBearingBegin());
      double mpi=Math.abs(MapUtils.degreesDiff(prev.getBearingEnd(),rs.getBearingBegin()));
      if ((ex < TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex >= 0) {
        kl=true;
        int lns=rs.getObject().getLanes();
        if (lns > 0) {
          right+=lns;
        }
        speak=speak || !highwayLowEnd(rs.getObject().getHighway());
      }
 else       if ((ex > -TURN_DEGREE_MIN || mpi < TURN_DEGREE_MIN) && ex <= 0) {
        kr=true;
        int lns=rs.getObject().getLanes();
        if (lns > 0) {
          left+=lns;
        }
        speak=speak || !highwayLowEnd(rs.getObject().getHighway());
      }
    }
  }
  if (kr && left == 0) {
    left=1;
  }
 else   if (kl && right == 0) {
    right=1;
  }
  int current=rr.getObject().getLanes();
  if (current <= 0) {
    current=1;
  }
  if (ls >= 0) {
    lanes=new int[current + left + right];
    ls=current + left + right;
    for (int it=0; it < ls; it++) {
      if (it < left || it >= left + current) {
        lanes[it]=0;
      }
 else {
        lanes[it]=1;
      }
    }
  }
  if (kl) {
    t=TurnType.valueOf(TurnType.KL,leftSide);
    t.setSkipToSpeak(!speak);
  }
 else   if (kr) {
    t=TurnType.valueOf(TurnType.KR,leftSide);
    t.setSkipToSpeak(!speak);
  }
  if (t != null && lanes != null) {
    t.setLanes(lanes);
  }
  return t;
}
