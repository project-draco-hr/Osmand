{
  ArrayList<RouteSegment> segmentsToVisitPrescripted=new ArrayList<RouteSegment>(5);
  ArrayList<RouteSegment> segmentsToVisitNotForbidden=new ArrayList<RouteSegment>(5);
  double obstaclesTime=0;
  boolean exclusiveRestriction=false;
  if (firstOfSegment) {
    RouteSegment possibleObstacle=inputNext;
    while (possibleObstacle != null) {
      obstaclesTime+=ctx.getRouter().defineObstacle(possibleObstacle.road,possibleObstacle.segmentStart);
      possibleObstacle=possibleObstacle.next;
    }
  }
  RouteSegment next=inputNext;
  while (next != null) {
    long nts=(next.road.getId() << 8l) + next.segmentStart;
    boolean oppositeConnectionFound=oppositeSegments.containsKey(nts) && oppositeSegments.get(nts) != null;
    boolean processRoad=true;
    if (ctx.isUseStrategyOfIncreasingRoadPriorities()) {
      double roadPriority=ctx.getRouter().getRoadPriorityHeuristicToIncrease(segment.road);
      double nextRoadPriority=ctx.getRouter().getRoadPriorityHeuristicToIncrease(segment.road);
      if (nextRoadPriority < roadPriority) {
        processRoad=false;
      }
    }
    boolean alreadyVisited=visitedSegments.contains(nts);
    if ((!alreadyVisited && processRoad) || oppositeConnectionFound) {
      int type=-1;
      if (!reverseWay) {
        for (int i=0; i < road.getRestrictionCount(); i++) {
          if (road.getRestriction(i) == next.road.getId()) {
            type=road.getRestrictionType(i);
            break;
          }
        }
      }
 else {
        for (int i=0; i < next.road.getRestrictionCount(); i++) {
          if (next.road.getRestriction(i) == road.getId()) {
            type=next.road.getRestrictionType(i);
            break;
          }
          if (next.road.getRestrictionType(i) == MapRenderingTypes.RESTRICTION_ONLY_RIGHT_TURN || next.road.getRestrictionType(i) == MapRenderingTypes.RESTRICTION_ONLY_LEFT_TURN || next.road.getRestrictionType(i) == MapRenderingTypes.RESTRICTION_ONLY_STRAIGHT_ON) {
            RouteSegment foundNext=inputNext;
            while (foundNext != null && foundNext.getRoad().getId() != next.road.getRestriction(i)) {
              foundNext=foundNext.next;
            }
            if (foundNext != null) {
              type=REVERSE_WAY_RESTRICTION_ONLY;
            }
          }
        }
      }
      if (type == REVERSE_WAY_RESTRICTION_ONLY) {
      }
 else       if (type == -1 && exclusiveRestriction) {
      }
 else       if (type == MapRenderingTypes.RESTRICTION_NO_LEFT_TURN || type == MapRenderingTypes.RESTRICTION_NO_RIGHT_TURN || type == MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON || type == MapRenderingTypes.RESTRICTION_NO_U_TURN) {
      }
 else {
        if (oppositeConnectionFound) {
          RouteSegment oppSegment=oppositeSegments.get(nts);
          oppSegment.segmentEnd=next.segmentStart;
          return oppSegment;
        }
        double distanceToEnd=h(ctx,distToFinalPoint,segment,next);
        double speed=ctx.getRouter().defineSpeed(road);
        if (speed == 0) {
          speed=ctx.getRouter().getMinDefaultSpeed();
        }
        double distanceFromStart=g(ctx,distOnRoadToPass,segment,segmentEnd,obstaclesTime,next,speed);
        if (next.parentRoute == null || ctx.roadPriorityComparator(next.distanceFromStart,next.distanceToEnd,distanceFromStart,distanceToEnd) > 0) {
          next.distanceFromStart=distanceFromStart;
          next.distanceToEnd=distanceToEnd;
          if (next.parentRoute != null) {
            graphSegments.remove(next);
          }
          next.parentRoute=segment;
          next.parentSegmentEnd=segmentEnd;
          if (type == -1) {
            segmentsToVisitNotForbidden.add(next);
          }
 else {
            if (!reverseWay) {
              exclusiveRestriction=true;
              segmentsToVisitNotForbidden.clear();
              segmentsToVisitPrescripted.add(next);
            }
 else {
              segmentsToVisitNotForbidden.add(next);
            }
          }
        }
      }
    }
 else     if (alreadyVisited) {
      if (segment.distanceFromStart < next.distanceFromStart) {
        double speed=ctx.getRouter().defineSpeed(road);
        if (speed == 0) {
          speed=ctx.getRouter().getMinDefaultSpeed();
        }
        next.distanceFromStart=g(ctx,distOnRoadToPass,segment,segmentEnd,obstaclesTime,next,speed);
        RouteSegment findAndReplace=next.parentRoute;
        int theend=next.parentSegmentEnd;
        next.parentRoute=segment;
        next.parentSegmentEnd=segment.road.getPointsLength() - 1;
        for (        Object s : visitedSegments.values()) {
          RouteSegment updateSegment=(RouteSegment)s;
          if (s != null && updateSegment.parentRoute == findAndReplace && updateSegment.parentSegmentEnd == theend && s != segment) {
            updateSegment.parentRoute=segment;
            updateSegment.parentSegmentEnd=segment.road.getPointsLength() - 1;
          }
        }
      }
    }
    next=next.next;
  }
  for (  RouteSegment s : segmentsToVisitNotForbidden) {
    graphSegments.add(s);
  }
  for (  RouteSegment s : segmentsToVisitPrescripted) {
    graphSegments.add(s);
  }
  return null;
}
