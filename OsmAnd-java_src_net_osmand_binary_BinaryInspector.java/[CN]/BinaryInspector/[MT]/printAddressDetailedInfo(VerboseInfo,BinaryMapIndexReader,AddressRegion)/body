{
  String[] cityType_String=new String[]{"Cities/Towns section","Villages section","Postcodes section"};
  int[] cityType=new int[]{BinaryMapAddressReaderAdapter.CITY_TOWN_TYPE,BinaryMapAddressReaderAdapter.VILLAGES_TYPE,BinaryMapAddressReaderAdapter.POSTCODES_TYPE};
  for (int j=0; j < cityType.length; j++) {
    int type=cityType[j];
    final List<City> cities=index.getCities(region,null,type);
    print(MessageFormat.format("\t{0}, {1,number,#} group(s)",new Object[]{cityType_String[j],Integer.valueOf(cities.size())}));
    if (BinaryMapAddressReaderAdapter.CITY_TOWN_TYPE == type) {
      if (!verbose.vstreetgroups && !verbose.vcities) {
        println("");
        continue;
      }
    }
 else     if (!verbose.vstreetgroups) {
      println("");
      continue;
    }
    println(":");
    for (    City c : cities) {
      int size=index.preloadStreets(c,null);
      List<Street> streets=new ArrayList<Street>(c.getStreets());
      print(MessageFormat.format("\t\t''{0}'' [{1,number,#}], {2,number,#} street(s) size {3,number,#} bytes",new Object[]{c.getEnName(),Long.valueOf(c.getId()),Integer.valueOf(streets.size()),Integer.valueOf(size)}));
      if (!verbose.vstreets) {
        println("");
        continue;
      }
      println(":");
      if (!verbose.contains(c))       continue;
      for (      Street t : streets) {
        if (!verbose.contains(t))         continue;
        index.preloadBuildings(t,null);
        final List<Building> buildings=t.getBuildings();
        final List<Street> intersections=t.getIntersectedStreets();
        println(MessageFormat.format("\t\t\t''{0}'' [{1,number,#}], {2,number,#} building(s), {3,number,#} intersections(s)",new Object[]{t.getEnName(),Long.valueOf(t.getId()),Integer.valueOf(buildings.size()),Integer.valueOf(intersections.size())}));
        if (buildings != null && !buildings.isEmpty() && verbose.vbuildings) {
          println("\t\t\t\tBuildings:");
          for (          Building b : buildings) {
            println(MessageFormat.format("\t\t\t\t{0} [{1,number,#}]",new Object[]{b.getName(true),Long.valueOf(b.getId())}));
          }
        }
        if (intersections != null && !intersections.isEmpty() && verbose.vintersections) {
          print("\t\t\t\tIntersects with:");
          for (          Street s : intersections) {
            println("\t\t\t\t\t" + s.getEnName());
          }
        }
      }
    }
  }
}
