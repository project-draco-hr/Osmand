{
  concurrencyLevel=builder.concurrencyLevel;
  capacity=new AtomicLong(Math.min(builder.capacity,MAXIMUM_CAPACITY));
  data=new ConcurrentHashMapV8<K,Node<K,V>>(builder.initialCapacity,0.75f,concurrencyLevel);
  weigher=builder.weigher;
  evictionLock=new ReentrantLock();
  weightedSize=new AtomicLong();
  evictionDeque=new LinkedDeque<Node<K,V>>();
  writeBuffer=new ConcurrentLinkedQueue<Runnable>();
  drainStatus=new AtomicReference<DrainStatus>(IDLE);
  readBufferReadCount=new long[NUMBER_OF_READ_BUFFERS];
  readBufferWriteCount=new AtomicLong[NUMBER_OF_READ_BUFFERS];
  readBufferDrainAtWriteCount=new AtomicLong[NUMBER_OF_READ_BUFFERS];
  readBuffers=new AtomicReference[NUMBER_OF_READ_BUFFERS][READ_BUFFER_SIZE];
  for (int i=0; i < NUMBER_OF_READ_BUFFERS; i++) {
    readBufferWriteCount[i]=new AtomicLong();
    readBufferDrainAtWriteCount[i]=new AtomicLong();
    readBuffers[i]=new AtomicReference[READ_BUFFER_SIZE];
    for (int j=0; j < READ_BUFFER_SIZE; j++) {
      readBuffers[i][j]=new AtomicReference<Node<K,V>>();
    }
  }
  listener=builder.listener;
  pendingNotifications=(listener == DiscardingListener.INSTANCE) ? (Queue<Node<K,V>>)DISCARDING_QUEUE : new ConcurrentLinkedQueue<Node<K,V>>();
}
