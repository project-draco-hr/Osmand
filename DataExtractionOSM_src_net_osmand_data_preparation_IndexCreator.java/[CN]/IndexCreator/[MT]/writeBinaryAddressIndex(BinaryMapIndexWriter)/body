{
  writer.startWriteAddressIndex(getRegionName());
  DataIndexReader reader=new DataIndexReader();
  List<City> cities=reader.readCities(addressConnection);
  List<Street> streets=new ArrayList<Street>();
  Collections.sort(cities,new Comparator<City>(){
    @Override public int compare(    City o1,    City o2){
      if (o1.getType() != o2.getType()) {
        return -(o1.getType().ordinal() - o2.getType().ordinal());
      }
      return Collator.getInstance().compare(o1.getName(),o2.getName());
    }
  }
);
  PreparedStatement streetstat=reader.getStreetsBuildingPreparedStatement(addressConnection);
  Map<String,List<Street>> postcodes=new TreeMap<String,List<Street>>();
  boolean writeCities=true;
  writer.startCityIndexes(false);
  for (int i=0; i < cities.size(); i++) {
    City c=cities.get(i);
    if (writeCities && c.getType() != CityType.CITY && c.getType() != CityType.TOWN) {
      writer.endCityIndexes(false);
      writer.startCityIndexes(true);
      writeCities=false;
    }
    streets.clear();
    reader.readStreetsBuildings(streetstat,c,streets);
    writer.writeCityIndex(c,streets);
    for (    Street s : streets) {
      for (      Building b : s.getBuildings()) {
        if (b.getPostcode() != null) {
          if (!postcodes.containsKey(b.getPostcode())) {
            postcodes.put(b.getPostcode(),new ArrayList<Street>(3));
          }
          postcodes.get(b.getPostcode()).add(s);
        }
      }
    }
  }
  writer.endCityIndexes(!writeCities);
  writer.startPostcodes();
  for (  String s : postcodes.keySet()) {
    writer.writePostcode(s,postcodes.get(s));
  }
  writer.endPostcodes();
  writer.endWriteAddressIndex();
}
