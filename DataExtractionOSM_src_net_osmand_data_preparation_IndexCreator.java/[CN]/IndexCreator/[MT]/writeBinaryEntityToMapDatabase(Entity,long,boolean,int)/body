{
  int type=MapRenderingTypes.encodeEntityWithType(e,MAP_ZOOMS[MAP_ZOOMS.length - level - 1],false,typeUse);
  Map<Long,Set<Integer>> multiPolygonsWays=this.multiPolygonsWays[level];
  boolean hasMulti=e instanceof Way && multiPolygonsWays.containsKey(e.getId());
  if (hasMulti) {
    Set<Integer> set=multiPolygonsWays.get(e.getId());
    boolean first=true;
    for (    Integer i : set) {
      if (first && type == 0) {
        type=i;
        first=false;
      }
 else {
        int k=i & 0x7fff;
        int ks=k | MapRenderingTypes.POLYGON_TYPE;
        if (ks == type) {
          type=i;
        }
 else {
          int ind=typeUse.indexOf(ks);
          if (ind == -1) {
            typeUse.add(i);
          }
 else {
            typeUse.set(ind,i);
          }
        }
      }
    }
  }
  if (type == 0) {
    return;
  }
  restrictionsUse.clear();
  if (MapRenderingTypes.isHighwayType(type)) {
    if (level == 0 && highwayRestrictions.containsKey(baseId)) {
      restrictionsUse.addAll(highwayRestrictions.get(baseId));
    }
  }
  boolean point=(type & 3) == MapRenderingTypes.POINT_TYPE;
  RTree rtree=null;
  int zoom;
  long id=(baseId << 3) | ((level & 3) << 1);
  rtree=mapTree[level];
  zoom=MAP_ZOOMS[MAP_ZOOMS.length - level - 1] - 2;
  boolean skip=false;
  if (e instanceof Way) {
    id|=1;
    if (level > 0) {
      List<Node> nodes=((Way)e).getNodes();
      Way way=new Way(id);
      for (      String t : e.getTagKeySet()) {
        way.putTag(t,e.getTag(t));
      }
      int prevX=0;
      int prevY=0;
      boolean cycle=((Way)e).getNodeIds().get(0).longValue() == ((Way)e).getNodeIds().get(nodes.size() - 1).longValue();
      boolean addLast=hasMulti || cycle;
      int minX=Integer.MAX_VALUE;
      int maxX=Integer.MIN_VALUE;
      int minY=Integer.MAX_VALUE;
      int maxY=Integer.MIN_VALUE;
      for (int i=0; i < nodes.size(); i++) {
        int r=i == nodes.size() - 1 ? 1 : 3;
        if (nodes.get(i) != null) {
          int x=(int)(MapUtils.getTileNumberX(zoom,nodes.get(i).getLongitude()) * 256d);
          int y=(int)(MapUtils.getTileNumberY(zoom,nodes.get(i).getLatitude()) * 256d);
          int dy=Math.abs(y - prevY);
          int dx=Math.abs(x - prevX);
          if (dx > r || dy > r || (addLast && i == nodes.size() - 1)) {
            way.addNode(nodes.get(i));
            prevX=x;
            prevY=y;
          }
          minX=Math.min(minX,x);
          maxX=Math.max(maxX,x);
          minY=Math.min(minY,y);
          maxY=Math.max(maxY,y);
        }
      }
      e=way;
      skip=way.getNodes().size() < 2;
      if ((maxX - minX) <= 4 && (maxY - minY) <= 4) {
        skip=true;
      }
      if (!cycle && hasMulti) {
        skip=false;
      }
    }
  }
  if (!skip) {
    int highwayAttributes=0;
    if (MapRenderingTypes.isHighwayType(type)) {
      highwayAttributes=MapRenderingTypes.getHighwayAttributes(e);
    }
    String eName=MapRenderingTypes.getEntityName(e,type);
    if (eName == null) {
      eName=multiPolygonsNames.get(baseId);
    }
    DataIndexWriter.insertBinaryMapRenderObjectIndex(pStatements,mapBinaryStat,rtree,e,eName,id,type,typeUse,highwayAttributes,restrictionsUse,inverse,point,BATCH_SIZE);
  }
}
