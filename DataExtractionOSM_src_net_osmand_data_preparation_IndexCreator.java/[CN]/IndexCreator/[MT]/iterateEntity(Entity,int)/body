{
  if (step == STEP_MAIN) {
    if (indexPOI && Amenity.isAmenity(e)) {
      loadEntityData(e,false);
      if (poiPreparedStatement != null) {
        Amenity a=new Amenity(e);
        if (a.getLocation() != null) {
          convertEnglishName(a);
          DataIndexWriter.insertAmenityIntoPoi(poiPreparedStatement,pStatements,a,BATCH_SIZE);
        }
      }
    }
    if (indexTransport) {
      if (e instanceof Relation && e.getTag(OSMTagKey.ROUTE) != null) {
        loadEntityData(e,true);
        TransportRoute route=indexTransportRoute((Relation)e);
        if (route != null) {
          DataIndexWriter.insertTransportIntoIndex(transRouteStat,transRouteStopsStat,transStopsStat,visitedStops,route,pStatements,BATCH_SIZE);
        }
      }
    }
    if (indexMap && (e instanceof Way || e instanceof Node)) {
      loadEntityData(e,true);
      boolean inverse="-1".equals(e.getTag(OSMTagKey.ONEWAY));
      writeBinaryEntityToMapDatabase(e,e.getId(),inverse,0);
      writeBinaryEntityToMapDatabase(e,e.getId(),false,1);
      writeBinaryEntityToMapDatabase(e,e.getId(),false,2);
    }
    if (indexAddress) {
      if (e.getTag(OSMTagKey.ADDR_HOUSE_NUMBER) != null && e.getTag(OSMTagKey.ADDR_STREET) != null) {
        boolean exist=false;
        if (loadInMemory) {
          exist=addressBuildingLocalSet.contains(e.getId());
        }
 else {
          addressSearchBuildingStat.setLong(1,e.getId());
          ResultSet rs=addressSearchBuildingStat.executeQuery();
          exist=rs.next();
          rs.close();
        }
        if (!exist) {
          loadEntityData(e,false);
          LatLon l=e.getLatLon();
          City city=getClosestCity(l);
          Long idStreet=getStreetInCity(city,e.getTag(OSMTagKey.ADDR_STREET),l,e.getId());
          if (idStreet != null) {
            Building building=new Building(e);
            building.setName(e.getTag(OSMTagKey.ADDR_HOUSE_NUMBER));
            convertEnglishName(building);
            DataIndexWriter.writeBuilding(addressBuildingStat,pStatements,idStreet,building,BATCH_SIZE);
          }
        }
      }
      if (e instanceof Way && e.getTag(OSMTagKey.HIGHWAY) != null && e.getTag(OSMTagKey.NAME) != null) {
        boolean exist=false;
        if (loadInMemory) {
          exist=addressStreetNodeLocalSet.contains(e.getId());
        }
 else {
          addressSearchStreetNodeStat.setLong(1,e.getId());
          ResultSet rs=addressSearchStreetNodeStat.executeQuery();
          exist=rs.next();
          rs.close();
        }
        if (!exist) {
          loadEntityData(e,false);
          LatLon l=e.getLatLon();
          City city=getClosestCity(l);
          Long idStreet=getStreetInCity(city,e.getTag(OSMTagKey.NAME),l,e.getId());
          if (idStreet != null && saveAddressWays) {
            DataIndexWriter.writeStreetWayNodes(addressStreetNodeStat,pStatements,idStreet,(Way)e,BATCH_SIZE);
          }
        }
      }
      if (e instanceof Relation) {
        if (e.getTag(OSMTagKey.POSTAL_CODE) != null) {
          loadEntityData(e,false);
          postalCodeRelations.add((Relation)e);
        }
      }
    }
  }
 else   if (step == STEP_ADDRESS_RELATIONS_AND_MULTYPOLYGONS) {
    if (indexAddress) {
      if (e instanceof Relation && "address".equals(e.getTag(OSMTagKey.TYPE))) {
        indexAddressRelation((Relation)e);
      }
    }
    if (indexMap && e instanceof Relation && "restriction".equals(e.getTag(OSMTagKey.TYPE))) {
      String val=e.getTag("restriction");
      if (val != null) {
        byte type=-1;
        if ("no_right_turn".equalsIgnoreCase(val)) {
          type=MapRenderingTypes.RESTRICTION_NO_RIGHT_TURN;
        }
 else         if ("no_left_turn".equalsIgnoreCase(val)) {
          type=MapRenderingTypes.RESTRICTION_NO_LEFT_TURN;
        }
 else         if ("no_u_turn".equalsIgnoreCase(val)) {
          type=MapRenderingTypes.RESTRICTION_NO_U_TURN;
        }
 else         if ("no_straight_on".equalsIgnoreCase(val)) {
          type=MapRenderingTypes.RESTRICTION_NO_STRAIGHT_ON;
        }
 else         if ("only_right_turn".equalsIgnoreCase(val)) {
          type=MapRenderingTypes.RESTRICTION_ONLY_RIGHT_TURN;
        }
 else         if ("only_left_turn".equalsIgnoreCase(val)) {
          type=MapRenderingTypes.RESTRICTION_ONLY_LEFT_TURN;
        }
 else         if ("only_straight_on".equalsIgnoreCase(val)) {
          type=MapRenderingTypes.RESTRICTION_ONLY_STRAIGHT_ON;
        }
        if (type != -1) {
          Collection<EntityId> fromL=((Relation)e).getMemberIds("from");
          Collection<EntityId> toL=((Relation)e).getMemberIds("to");
          if (!fromL.isEmpty() && !toL.isEmpty()) {
            EntityId from=fromL.iterator().next();
            EntityId to=toL.iterator().next();
            if (from.getType() == EntityType.WAY) {
              if (!highwayRestrictions.containsKey(from.getId())) {
                highwayRestrictions.put(from.getId(),new ArrayList<Long>(4));
              }
              highwayRestrictions.get(from.getId()).add((to.getId() << 3) | (long)type);
            }
          }
        }
      }
    }
    if (indexMap && e instanceof Relation && "multipolygon".equals(e.getTag(OSMTagKey.TYPE))) {
      loadEntityData(e,true);
      Map<Entity,String> entities=((Relation)e).getMemberEntities();
      for (      Entity es : entities.keySet()) {
        if (es instanceof Way) {
          boolean inner="inner".equals(entities.get(es));
          if (!inner) {
            for (            String t : es.getTagKeySet()) {
              e.putTag(t,es.getTag(t));
            }
            break;
          }
        }
      }
      int mtType=findMultiPolygonType(e,0);
      if (mtType != 0) {
        int mtType1=findMultiPolygonType(e,1);
        int mtType2=findMultiPolygonType(e,2);
        String name=MapRenderingTypes.getEntityName(e,mtType);
        List<List<Way>> completedRings=new ArrayList<List<Way>>();
        List<List<Way>> incompletedRings=new ArrayList<List<Way>>();
        for (        Entity es : entities.keySet()) {
          if (es instanceof Way) {
            if (!((Way)es).getNodeIds().isEmpty()) {
              combineMultiPolygons((Way)es,completedRings,incompletedRings);
            }
          }
        }
        if (!incompletedRings.isEmpty()) {
          return;
        }
        for (        List<Way> l : completedRings) {
          boolean innerType="inner".equals(entities.get(l.get(0)));
          boolean clockwise=isClockwiseWay(l);
          boolean inverse=clockwise != !innerType;
          for (          Way es : l) {
            boolean inner="inner".equals(entities.get(es));
            if (innerType != inner) {
              throw new IllegalStateException();
            }
            if (!inner && name != null) {
              multiPolygonsNames.put(es.getId(),name);
            }
            putMultipolygonType(multiPolygonsWays0,es.getId(),mtType,inverse);
            putMultipolygonType(multiPolygonsWays1,es.getId(),mtType1,inverse);
            putMultipolygonType(multiPolygonsWays2,es.getId(),mtType2,inverse);
          }
        }
      }
    }
  }
 else   if (step == STEP_CITY_NODES) {
    registerCityIfNeeded(e);
  }
}
