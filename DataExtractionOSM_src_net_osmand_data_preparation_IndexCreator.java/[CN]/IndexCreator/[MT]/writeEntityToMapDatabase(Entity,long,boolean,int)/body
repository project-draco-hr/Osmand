{
  int type=MapRenderingTypes.encodeEntityWithType(e,level,false,typeUse);
  Map<Long,Set<Integer>> multiPolygonsWays;
  if (level == 0) {
    multiPolygonsWays=multiPolygonsWays0;
  }
 else   if (level == 1) {
    multiPolygonsWays=multiPolygonsWays1;
  }
 else   if (level == 2) {
    multiPolygonsWays=multiPolygonsWays2;
  }
 else {
    multiPolygonsWays=Collections.emptyMap();
  }
  boolean hasMulti=e instanceof Way && multiPolygonsWays.containsKey(e.getId());
  if (type == 0) {
    if (hasMulti) {
      Set<Integer> set=multiPolygonsWays.get(e.getId());
      boolean first=true;
      for (      Integer i : set) {
        if (first) {
          type=i << 1;
          first=false;
        }
 else {
          typeUse.add(i);
        }
      }
    }
 else {
      return;
    }
  }
 else   if (hasMulti) {
    Set<Integer> set=multiPolygonsWays.get(e.getId());
    for (    Integer i : set) {
      int k=i & 0x7fff;
      int ks=k | MapRenderingTypes.POLYGON_TYPE;
      if (ks == ((type >> 1) & 0xffff)) {
        type=((type >> 16) << 16) | (i << 1);
      }
 else       if (ks == type >> 16) {
        type=(type & 0xffff) | (i << 16);
      }
 else {
        int ind=typeUse.indexOf(ks);
        if (ind == -1) {
          typeUse.add(i);
        }
 else {
          typeUse.set(ind,i);
        }
      }
    }
  }
  if (!typeUse.isEmpty()) {
    type|=1;
  }
  boolean useRestrictions=false;
  restrictionsUse.clear();
  if (MapRenderingTypes.isHighwayType(type >> 1)) {
    useRestrictions=true;
    if (level == 0 && highwayRestrictions.containsKey(baseId)) {
      restrictionsUse.addAll(highwayRestrictions.get(baseId));
    }
  }
  boolean point=((type >> 1) & 3) == MapRenderingTypes.POINT_TYPE;
  PreparedStatement mapLocations;
  int zoom;
  long id=baseId << 3;
  if (level == 1) {
    id|=2;
    mapLocations=mapLocsStatLevel1;
    zoom=14;
  }
 else   if (level == 2) {
    id|=4;
    zoom=9;
    mapLocations=mapLocsStatLevel2;
  }
 else {
    zoom=18;
    mapLocations=mapLocsStatLevel0;
  }
  boolean skip=false;
  if (e instanceof Way) {
    id|=1;
    if (level > 0) {
      List<Node> nodes=((Way)e).getNodes();
      Way way=new Way(id);
      for (      String t : e.getTagKeySet()) {
        way.putTag(t,e.getTag(t));
      }
      int prevX=0;
      int prevY=0;
      for (int i=0; i < nodes.size(); i++) {
        int r=i < nodes.size() - 1 ? 4 : 0;
        int x=(int)(MapUtils.getTileNumberX(zoom,nodes.get(i).getLongitude()) * 256d);
        int y=(int)(MapUtils.getTileNumberY(zoom,nodes.get(i).getLatitude()) * 256d);
        if (Math.abs(x - prevX) > r || Math.abs(y - prevY) > r) {
          way.addNode(nodes.get(i));
          prevX=x;
          prevY=y;
        }
      }
      e=way;
      skip=way.getNodes().size() < 2;
    }
  }
  if (!skip) {
    String eName=MapRenderingTypes.getEntityName(e,type);
    if (eName == null) {
      eName=multiPolygonsNames.get(baseId);
    }
    DataIndexWriter.insertMapRenderObjectIndex(pStatements,mapObjStat,mapLocations,e,eName,id,type,typeUse,restrictionsUse,useRestrictions,inverse,point,BATCH_SIZE);
  }
}
