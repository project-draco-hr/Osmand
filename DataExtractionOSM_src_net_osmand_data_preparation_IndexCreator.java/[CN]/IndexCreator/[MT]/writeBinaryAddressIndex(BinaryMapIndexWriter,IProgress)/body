{
  boolean readWayNodes=saveAddressWays;
  writer.startWriteAddressIndex(getRegionName());
  DataIndexReader reader=new DataIndexReader();
  List<City> cities=reader.readCities(mapConnection);
  List<Street> streets=new ArrayList<Street>();
  Collections.sort(cities,new Comparator<City>(){
    @Override public int compare(    City o1,    City o2){
      if (o1.getType() != o2.getType()) {
        return (o1.getType().ordinal() - o2.getType().ordinal());
      }
      return Collator.getInstance().compare(o1.getName(),o2.getName());
    }
  }
);
  PreparedStatement streetstat=reader.getStreetsBuildingPreparedStatement(mapConnection);
  PreparedStatement waynodesStat=null;
  if (readWayNodes) {
    waynodesStat=reader.getStreetsWayNodesPreparedStatement(mapConnection);
  }
  int j=0;
  for (; j < cities.size(); j++) {
    City c=cities.get(j);
    if (c.getType() != CityType.CITY && c.getType() != CityType.TOWN) {
      break;
    }
  }
  progress.startTask(Messages.getString("IndexCreator.SERIALIZING_ADRESS"),j + ((cities.size() - j) / 100 + 1));
  Map<String,Set<Street>> postcodes=new TreeMap<String,Set<Street>>();
  boolean writeCities=true;
  writer.startCityIndexes(false);
  for (int i=0; i < cities.size(); i++) {
    City c=cities.get(i);
    if (writeCities) {
      progress.progress(1);
    }
 else     if ((cities.size() - i) % 100 == 0) {
      progress.progress(1);
    }
    if (writeCities && c.getType() != CityType.CITY && c.getType() != CityType.TOWN) {
      writer.endCityIndexes(false);
      writer.startCityIndexes(true);
      writeCities=false;
    }
    streets.clear();
    Map<Street,List<Node>> streetNodes=null;
    if (readWayNodes) {
      streetNodes=new LinkedHashMap<Street,List<Node>>();
    }
    long time=System.currentTimeMillis();
    reader.readStreetsBuildings(streetstat,c,streets,waynodesStat,streetNodes);
    long f=System.currentTimeMillis() - time;
    writer.writeCityIndex(c,streets,streetNodes);
    int bCount=0;
    for (    Street s : streets) {
      bCount++;
      for (      Building b : s.getBuildings()) {
        bCount++;
        if (b.getPostcode() != null) {
          if (!postcodes.containsKey(b.getPostcode())) {
            postcodes.put(b.getPostcode(),new LinkedHashSet<Street>(3));
          }
          postcodes.get(b.getPostcode()).add(s);
        }
      }
    }
    if (f > 500) {
      System.out.println("! " + c.getName() + " ! "+ f+ " "+ bCount+ " streets "+ streets.size());
    }
  }
  writer.endCityIndexes(!writeCities);
  writer.startPostcodes();
  for (  String s : postcodes.keySet()) {
    writer.writePostcode(s,postcodes.get(s));
  }
  writer.endPostcodes();
  progress.finishTask();
  writer.endWriteAddressIndex();
  writer.flush();
  streetstat.close();
  if (readWayNodes) {
    waynodesStat.close();
  }
}
