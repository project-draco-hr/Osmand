{
  List<Location> res=new ArrayList<Location>();
  List<RouteDirectionInfo> directions=null;
  StringBuilder uri=new StringBuilder();
  uri.append("http://routes.cloudmade.com/A6421860EBB04234AB5EF2D049F2CD8F/api/0.3/");
  uri.append(start.getLatitude() + "").append(",");
  uri.append(start.getLongitude() + "").append(",");
  uri.append(end.getLatitude() + "").append(",");
  uri.append(end.getLongitude() + "").append("/");
  if (ApplicationMode.PEDESTRIAN == mode) {
    uri.append("foot.gpx");
  }
 else   if (ApplicationMode.BICYCLE == mode) {
    uri.append("bicycle.gpx");
  }
 else {
    if (fast) {
      uri.append("car.gpx");
    }
 else {
      uri.append("car/shortest.gpx");
    }
  }
  uri.append("?lang=").append(Locale.getDefault().getLanguage());
  URL url=new URL(uri.toString());
  URLConnection connection=url.openConnection();
  DocumentBuilder dom=DocumentBuilderFactory.newInstance().newDocumentBuilder();
  Document doc=dom.parse(new InputSource(new InputStreamReader(connection.getInputStream())));
  NodeList list=doc.getElementsByTagName("wpt");
  for (int i=0; i < list.getLength(); i++) {
    Element item=(Element)list.item(i);
    try {
      Location l=new Location("router");
      l.setLatitude(Double.parseDouble(item.getAttribute("lat")));
      l.setLongitude(Double.parseDouble(item.getAttribute("lon")));
      res.add(l);
    }
 catch (    NumberFormatException e) {
    }
  }
  list=doc.getElementsByTagName("rtept");
  if (list.getLength() > 0) {
    directions=new ArrayList<RouteDirectionInfo>();
  }
  RouteDirectionInfo previous=null;
  for (int i=0; i < list.getLength(); i++) {
    Element item=(Element)list.item(i);
    try {
      RouteDirectionInfo dirInfo=new RouteDirectionInfo();
      dirInfo.descriptionRoute=getContentFromNode(item,"desc");
      String stime=getContentFromNode(item,"time");
      if (stime != null) {
        dirInfo.expectedTime=Integer.parseInt(stime);
      }
      String stype=getContentFromNode(item,"turn");
      if (stype != null) {
        dirInfo.turnType=TurnType.valueOf(stype.toUpperCase());
      }
 else {
        dirInfo.turnType=TurnType.valueOf(TurnType.C);
      }
      String sturn=getContentFromNode(item,"turn-angle");
      if (sturn != null) {
        dirInfo.turnType.setTurnAngle((float)Double.parseDouble(sturn));
      }
      int offset=Integer.parseInt(getContentFromNode(item,"offset"));
      dirInfo.routePointOffset=offset;
      if (previous != null && previous.turnType != null && !TurnType.C.equals(previous.turnType.getValue())) {
        if (previous.routePointOffset > 0) {
          float paz=res.get(previous.routePointOffset - 1).bearingTo(res.get(previous.routePointOffset));
          float caz;
          if (previous.turnType.isRoundAbout() && dirInfo.routePointOffset < res.size() - 1) {
            caz=res.get(dirInfo.routePointOffset).bearingTo(res.get(dirInfo.routePointOffset + 1));
          }
 else {
            caz=res.get(dirInfo.routePointOffset - 1).bearingTo(res.get(dirInfo.routePointOffset));
          }
          float angle=caz - paz;
          if (angle < 0) {
            angle+=360;
          }
 else           if (angle > 360) {
            angle-=360;
          }
          angle+=75;
          if (previous.turnType.getTurnAngle() < 0.5f) {
            previous.turnType.setTurnAngle(angle);
          }
        }
      }
      directions.add(dirInfo);
      previous=dirInfo;
    }
 catch (    NumberFormatException e) {
      log.info("Exception",e);
    }
catch (    IllegalArgumentException e) {
      log.info("Exception",e);
    }
  }
  if (previous != null && previous.turnType != null && !TurnType.C.equals(previous.turnType.getValue())) {
    if (previous.routePointOffset > 0 && previous.routePointOffset < res.size() - 1) {
      float paz=res.get(previous.routePointOffset - 1).bearingTo(res.get(previous.routePointOffset));
      float caz=res.get(previous.routePointOffset).bearingTo(res.get(res.size() - 1));
      float angle=caz - paz;
      if (angle < 0) {
        angle+=360;
      }
      if (previous.turnType.getTurnAngle() < 0.5f) {
        previous.turnType.setTurnAngle(angle);
      }
    }
  }
  return new RouteCalculationResult(res,directions,start,end,null);
}
