{
  String fileName=this.fileName;
  File parent=type.getDownloadFolder(ctx,this);
  boolean preventMediaIndexing=type.preventMediaIndexing(ctx,this);
  if (parent != null) {
    parent.mkdirs();
    if (preventMediaIndexing) {
      try {
        new File(parent,".nomedia").createNewFile();
      }
 catch (      IOException e) {
        log.error("IOException",e);
      }
    }
  }
  final DownloadEntry entry;
  if (parent == null || !parent.exists()) {
    ctx.showToastMessage(R.string.sd_dir_not_accessible);
  }
 else {
    entry=new DownloadEntry(this);
    entry.type=type;
    entry.baseName=getBasename();
    entry.urlToDownload=entry.type.getBaseUrl(ctx,fileName) + entry.type.getUrlSuffix(ctx);
    entry.zipStream=type.isZipStream(ctx,this);
    entry.unzipFolder=type.isZipFolder(ctx,this);
    entry.dateModified=timestamp;
    entry.sizeMB=contentSize / (1024f * 1024f);
    String extension=type.getUnzipExtension(ctx,this);
    entry.targetFile=new File(parent,entry.baseName + extension);
    File backup=new File(ctx.getAppPath(IndexConstants.BACKUP_INDEX_DIR),entry.targetFile.getName());
    if (backup.exists()) {
      entry.existingBackupFile=backup;
    }
    if (attachedItem != null) {
      ArrayList<DownloadEntry> sz=new ArrayList<DownloadEntry>();
      attachedItem.createDownloadEntry(ctx,type,sz);
      if (sz.size() > 0) {
        entry.attachedEntry=sz.get(0);
      }
    }
    downloadEntries.add(entry);
  }
  return downloadEntries;
}
