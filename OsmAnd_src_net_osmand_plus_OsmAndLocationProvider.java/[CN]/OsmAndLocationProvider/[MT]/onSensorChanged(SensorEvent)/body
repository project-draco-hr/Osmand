{
  float val=0;
switch (event.sensor.getType()) {
case Sensor.TYPE_ACCELEROMETER:
    if (mGravs == null) {
      mGravs=new float[3];
    }
  System.arraycopy(event.values,0,mGravs,0,3);
break;
case Sensor.TYPE_MAGNETIC_FIELD:
if (mGeoMags == null) {
mGeoMags=new float[3];
}
System.arraycopy(event.values,0,mGeoMags,0,3);
break;
case Sensor.TYPE_ORIENTATION:
val=event.values[0];
if (mGravs != null && mGeoMags != null) {
return;
}
break;
default :
return;
}
if (mGravs != null && mGeoMags != null) {
float[] mRotationM=new float[9];
boolean success=SensorManager.getRotationMatrix(mRotationM,null,mGravs,mGeoMags);
if (!success) {
return;
}
float[] orientation=SensorManager.getOrientation(mRotationM,new float[3]);
val=(float)Math.toDegrees(orientation[0]);
}
 else if (event.sensor.getType() != Sensor.TYPE_ORIENTATION) {
return;
}
if (currentScreenOrientation == 1) {
val+=90;
}
 else if (currentScreenOrientation == 2) {
val+=180;
}
 else if (currentScreenOrientation == 3) {
val-=90;
}
if (previousCorrectionValue == 360 && getLastKnownLocation() != null) {
net.osmand.Location l=getLastKnownLocation();
GeomagneticField gf=new GeomagneticField((float)l.getLatitude(),(float)l.getLongitude(),(float)l.getAltitude(),System.currentTimeMillis());
previousCorrectionValue=gf.getDeclination();
}
if (previousCorrectionValue != 360) {
val+=previousCorrectionValue;
}
float valRad=(float)(val / 180f * Math.PI);
float valSin=(float)Math.sin(valRad);
float valCos=(float)Math.cos(valRad);
if (heading == null && previousCompassIndA == 0) {
Arrays.fill(previousCompassValuesA,valSin);
Arrays.fill(previousCompassValuesB,valCos);
avgValSin=valSin;
avgValCos=valCos;
}
 else {
if (USE_KALMAN_FILTER) {
avgValSin=KALMAN_COEFFICIENT * valSin + avgValSin * (1 - KALMAN_COEFFICIENT);
avgValCos=KALMAN_COEFFICIENT * valCos + avgValCos * (1 - KALMAN_COEFFICIENT);
}
 else {
int l=previousCompassValuesA.length;
previousCompassIndA=(previousCompassIndA + 1) % l;
previousCompassIndB=(previousCompassIndB + 1) % l;
avgValSin=avgValSin + (-previousCompassValuesA[previousCompassIndA] + valSin) / l;
previousCompassValuesA[previousCompassIndA]=valSin;
avgValCos=avgValCos + (-previousCompassValuesB[previousCompassIndB] + valCos) / l;
previousCompassValuesB[previousCompassIndB]=valCos;
}
}
heading=(float)getAngle(avgValSin,avgValCos);
updateCompassValue(heading.floatValue());
}
