{
  currentThread=Thread.currentThread();
  try {
    boolean conditionToCountinue=true;
    while (!stopped && conditionToCountinue) {
      long sleep=0;
      if (animateDrag) {
        sleep=80;
      }
 else {
        sleep=80;
      }
      Thread.sleep(sleep);
      long curT=System.currentTimeMillis();
      int dt=(int)(curT - time);
      float newX=animateDrag && vx > 0 ? curX + dirX * vx * dt : curX;
      float newY=animateDrag && vy > 0 ? curY + dirY * vy * dt : curY;
      float newZ=curZ;
      if (!animateDrag) {
        if (phaseOfMoving == 0 || phaseOfMoving == 2) {
          byte dir=phaseOfMoving == 2 ? dirZ : dirIntZ;
          int time=phaseOfMoving == 2 ? timeZEnd : timeZInt;
          float end=phaseOfMoving == 2 ? endZ : intZ;
          if (time > 0) {
            newZ=newZ + dir * (float)dt / time;
          }
          if (dir > 0 == newZ > end) {
            newZ=end;
          }
        }
 else {
          if (timeMove > 0) {
            newX=newX + moveX * (float)dt / timeMove;
            newY=newY + moveY * (float)dt / timeMove;
            if (moveX > 0 == newX > moveX) {
              newX=moveX;
            }
            if (moveY > 0 == newY > moveY) {
              newY=moveY;
            }
          }
        }
      }
      if (!stopped && callback != null) {
        if (animateDrag || phaseOfMoving == 1) {
          callback.dragTo(curX,curY,newX,newY,notifyListener);
        }
 else {
          callback.zoomTo(newZ,notifyListener);
        }
      }
      time=curT;
      if (animateDrag) {
        vx-=ax * dt;
        vy-=ay * dt;
        curX=newX;
        curY=newY;
        conditionToCountinue=vx > 0.5 || vy > 0.5;
      }
 else {
        if (phaseOfMoving == 0) {
          curZ=newZ;
          if (curZ == intZ) {
            curX=0;
            curY=0;
            phaseOfMoving++;
          }
        }
 else         if (phaseOfMoving == 2) {
          curZ=newZ;
          conditionToCountinue=curZ != endZ;
        }
 else {
          curX=newX;
          curY=newY;
          if (curX == moveX && curY == moveY) {
            phaseOfMoving++;
            callback.setLatLon(moveLat,moveLon,notifyListener);
          }
        }
      }
      if (!conditionToCountinue) {
        float rotationDiff=targetRotate - callback.getRotate();
        if (Math.abs((rotationDiff + 360) % 360) < Math.abs((rotationDiff - 360) % 360)) {
          rotationDiff=(rotationDiff + 360) % 360;
        }
 else {
          rotationDiff=(rotationDiff - 360) % 360;
        }
        float absDiff=Math.abs(rotationDiff);
        if (absDiff > 0) {
          if (absDiff < 2) {
            callback.rotateTo(targetRotate);
          }
 else {
            conditionToCountinue=true;
            callback.rotateTo(((absDiff / 10) * Math.signum(rotationDiff) + callback.getRotate()) % 360);
          }
        }
      }
    }
    if (curZ != ((int)Math.round(curZ))) {
      if (Math.abs(curZ - endZ) > 3) {
        callback.zoomTo(Math.round(curZ),notifyListener);
      }
 else {
        callback.zoomTo(endZ,notifyListener);
      }
    }
  }
 catch (  InterruptedException e) {
  }
  currentThread=null;
}
