{
  BinaryParser parser=new BinaryParser(){
    public void updateProgress(    int count){
      progressEntity+=count;
      if (progress != null && progressEntity > moduleProgress && !progress.isIndeterminate()) {
        try {
          progressEntity=0;
          progress.remaining(stream.available());
        }
 catch (        IOException e) {
          progress.startWork(-1);
        }
      }
    }
    public void registerEntity(    EntityType type,    Entity e,    EntityInfo info){
      EntityId entityId=new EntityId(type,e.getId());
      if (acceptEntityToLoad(entityId,e)) {
        Entity oldEntity=entities.put(entityId,e);
        if (info != null) {
          OsmBaseStorage.this.entityInfo.put(entityId,info);
        }
        if (!supressWarnings && oldEntity != null) {
          throw new UnsupportedOperationException("Entity with id=" + oldEntity.getId() + " is duplicated in osm map");
        }
      }
    }
    @Override protected void parse(    HeaderBlock header){
    }
    private DateFormat format=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
    @Override protected void parseDense(    DenseNodes n){
      EntityInfo info=null;
      long changeset=0;
      long timestamp=0;
      int uid=0;
      int user=0;
      long id=0;
      long lat=0;
      long lon=0;
      int keyInd=0;
      boolean tagsEmpty=n.getKeysValsCount() == 0;
      for (int i=0; i < n.getIdCount(); i++) {
        id+=n.getId(i);
        lat+=n.getLat(i);
        lon+=n.getLon(i);
        Node node=new Node(parseLat(lat),parseLon(lon),id);
        if (entityInfo && n.getDenseinfo() != null) {
          info=new EntityInfo();
          changeset+=n.getDenseinfo().getChangeset(i);
          timestamp+=n.getDenseinfo().getTimestamp(i);
          uid+=n.getDenseinfo().getUid(i);
          user+=n.getDenseinfo().getUserSid(i);
          info.setChangeset((changeset) + "");
          info.setTimestamp(format.format(new Date(date_granularity * (timestamp))));
          info.setUser(getStringById(user));
          info.setUid(uid + "");
          info.setVersion(n.getDenseinfo().getVersion(i) + "");
          info.setVisible("true");
        }
        if (!tagsEmpty) {
          while (n.getKeysVals(keyInd) != 0) {
            String key=getStringById(n.getKeysVals(keyInd));
            String val=getStringById(n.getKeysVals(keyInd + 1));
            node.putTag(key,val);
            keyInd+=2;
          }
          keyInd++;
        }
        registerEntity(EntityType.NODE,node,info);
      }
      updateProgress(n.getIdCount());
    }
    protected EntityInfo parseEntityInfo(    Info i){
      EntityInfo info=new EntityInfo();
      info.setChangeset(i.getChangeset() + "");
      info.setTimestamp(format.format(getDate(i)));
      info.setUser(getStringById(i.getUserSid()));
      info.setUid(i.getUid() + "");
      info.setVersion(i.getVersion() + "");
      info.setVisible("true");
      return info;
    }
    @Override protected void parseNodes(    List<crosby.binary.Osmformat.Node> n){
      EntityInfo info=null;
      for (int i=0; i < n.size(); i++) {
        crosby.binary.Osmformat.Node nod=n.get(i);
        Node e=new Node(parseLat(nod.getLat()),parseLon(nod.getLon()),nod.getId());
        for (int j=0; j < nod.getKeysCount(); j++) {
          String key=getStringById(nod.getKeys(j));
          String val=getStringById(nod.getVals(j));
          e.putTag(key,val);
        }
        if (entityInfo) {
          info=parseEntityInfo(nod.getInfo());
        }
        registerEntity(EntityType.NODE,e,info);
      }
      updateProgress(n.size());
    }
    @Override protected void parseRelations(    List<crosby.binary.Osmformat.Relation> r){
      EntityInfo info=null;
      for (int i=0; i < r.size(); i++) {
        crosby.binary.Osmformat.Relation rel=r.get(i);
        Relation e=new Relation(rel.getId());
        long id=0;
        for (int j=0; j < rel.getMemidsCount(); j++) {
          id+=rel.getMemids(j);
          String role=getStringById(rel.getRolesSid(j));
          MemberType t=rel.getTypes(j);
          EntityType ts=EntityType.NODE;
switch (t) {
case NODE:
            ts=EntityType.NODE;
          break;
case WAY:
        ts=EntityType.WAY;
      break;
case RELATION:
    ts=EntityType.RELATION;
  break;
}
e.addMember(id,ts,role);
}
for (int j=0; j < rel.getKeysCount(); j++) {
String key=getStringById(rel.getKeys(j));
String val=getStringById(rel.getVals(j));
e.putTag(key,val);
}
if (entityInfo) {
info=parseEntityInfo(rel.getInfo());
}
registerEntity(EntityType.RELATION,e,info);
}
updateProgress(r.size());
}
@Override protected void parseWays(List<crosby.binary.Osmformat.Way> w){
EntityInfo info=null;
for (int i=0; i < w.size(); i++) {
crosby.binary.Osmformat.Way way=w.get(i);
Way e=new Way(way.getId());
long id=0;
for (int j=0; j < way.getRefsCount(); j++) {
id+=way.getRefs(j);
e.addNode(id);
}
for (int j=0; j < way.getKeysCount(); j++) {
String key=getStringById(way.getKeys(j));
String val=getStringById(way.getVals(j));
e.putTag(key,val);
}
if (entityInfo) {
info=parseEntityInfo(way.getInfo());
}
registerEntity(EntityType.WAY,e,info);
}
updateProgress(w.size());
}
@Override public void complete(){
}
}
;
this.progressEntity=0;
this.entities.clear();
this.entityInfo.clear();
if (progress != null) {
progress.startWork(stream.available());
}
BlockInputStream bis=new BlockInputStream(stream,parser);
bis.process();
if (progress != null) {
progress.finishTask();
}
completeReading();
}
