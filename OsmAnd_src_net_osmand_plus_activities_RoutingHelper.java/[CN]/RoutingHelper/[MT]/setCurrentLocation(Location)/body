{
  if (finalLocation == null || currentLocation == null) {
    return;
  }
  boolean calculateRoute=false;
synchronized (this) {
    if (routeNodes.isEmpty() || routeNodes.size() <= currentRoute) {
      calculateRoute=true;
    }
 else {
      float dist=currentLocation.distanceTo(routeNodes.get(currentRoute));
      while (currentRoute + 1 < routeNodes.size()) {
        float newDist=currentLocation.distanceTo(routeNodes.get(currentRoute + 1));
        boolean proccesed=false;
        if (newDist < dist) {
          if (newDist > 150) {
            if (currentRoute > 0) {
              float bearing=routeNodes.get(currentRoute - 1).bearingTo(routeNodes.get(currentRoute));
              float bearingMovement=currentLocation.bearingTo(routeNodes.get(currentRoute));
              float d=Math.abs(currentLocation.distanceTo(routeNodes.get(currentRoute)) * FloatMath.sin((bearingMovement - bearing) * 3.14f / 180f));
              if (d > 50) {
                proccesed=true;
              }
            }
 else {
              proccesed=true;
            }
            if (proccesed && log.isDebugEnabled()) {
              log.debug("Processed distance : " + newDist + " "+ dist);
            }
          }
 else {
            if (currentLocation.hasBearing() || lastFixedLocation != null) {
              float bearingToPoint=currentLocation.bearingTo(routeNodes.get(currentRoute));
              float bearingBetweenPoints=routeNodes.get(currentRoute).bearingTo(routeNodes.get(currentRoute + 1));
              float bearing=currentLocation.hasBearing() ? currentLocation.getBearing() : lastFixedLocation.bearingTo(currentLocation);
              if (Math.abs(bearing - bearingToPoint) > Math.abs(bearing - bearingBetweenPoints)) {
                if (log.isDebugEnabled()) {
                  log.debug("Processed point bearing : " + Math.abs(currentLocation.getBearing() - bearingToPoint) + " "+ Math.abs(currentLocation.getBearing() - bearingBetweenPoints));
                }
                proccesed=true;
              }
            }
          }
        }
        if (proccesed) {
          updateCurrentRoute(currentRoute + 1);
          dist=newDist;
        }
 else {
          break;
        }
      }
      if (finishAtLocation(currentLocation)) {
        return;
      }
      if (currentRoute + 1 < routeNodes.size()) {
        float bearing=routeNodes.get(currentRoute).bearingTo(routeNodes.get(currentRoute + 1));
        float bearingMovement=currentLocation.bearingTo(routeNodes.get(currentRoute));
        if (Math.abs(bearing - bearingMovement) > 140 && Math.abs(bearing - bearingMovement) < 220) {
          if (log.isDebugEnabled()) {
            log.debug("Processed point movement bearing  : " + bearingMovement + " bearing "+ bearing);
          }
          updateCurrentRoute(currentRoute + 1);
        }
      }
      if (currentRoute + 2 < routeNodes.size()) {
        float bearing=routeNodes.get(currentRoute + 1).bearingTo(routeNodes.get(currentRoute + 2));
        float bearingMovement=currentLocation.bearingTo(routeNodes.get(currentRoute + 1));
        if (Math.abs(bearing - bearingMovement) > 165 && Math.abs(bearing - bearingMovement) < 195) {
          if (log.isDebugEnabled()) {
            log.debug("Processed point movement bearing 2 : " + bearingMovement + " bearing "+ bearing);
          }
          updateCurrentRoute(currentRoute + 2);
        }
      }
      if (currentRoute > 0) {
        float bearing=routeNodes.get(currentRoute - 1).bearingTo(routeNodes.get(currentRoute));
        float bearingMovement=currentLocation.bearingTo(routeNodes.get(currentRoute));
        float d=Math.abs(currentLocation.distanceTo(routeNodes.get(currentRoute)) * FloatMath.sin((bearingMovement - bearing) * 3.14f / 180f));
        if (d > 50) {
          log.info("Recalculate route, because correlation  : " + d);
          calculateRoute=true;
        }
      }
      if (!calculateRoute) {
        float d=currentLocation.distanceTo(routeNodes.get(currentRoute));
        if (d > 80) {
          if (currentRoute > 0) {
            float f1=currentLocation.distanceTo(routeNodes.get(currentRoute - 1)) + d;
            float c=routeNodes.get(currentRoute - 1).distanceTo(routeNodes.get(currentRoute));
            if (c * 2 < d + f1) {
              log.info("Recalculate route, because too far from points : " + d + " "+ f1+ " >> "+ c);
              calculateRoute=true;
            }
          }
 else {
            log.info("Recalculate route, because too far from start : " + d);
            calculateRoute=true;
          }
        }
      }
    }
  }
  voiceRouter.updateStatus(currentLocation);
  lastFixedLocation=currentLocation;
  if (calculateRoute) {
    recalculateRouteInBackground(lastFixedLocation,finalLocation,currentGPXRoute);
  }
}
