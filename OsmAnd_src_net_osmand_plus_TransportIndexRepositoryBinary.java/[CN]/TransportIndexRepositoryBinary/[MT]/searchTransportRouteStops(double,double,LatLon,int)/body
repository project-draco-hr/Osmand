{
  long now=System.currentTimeMillis();
  final LatLon loc=new LatLon(latitude,longitude);
  double tileNumberX=MapUtils.getTileNumberX(zoom,longitude);
  double tileNumberY=MapUtils.getTileNumberY(zoom,latitude);
  double topLatitude=MapUtils.getLatitudeFromTile(zoom,tileNumberY - 0.5);
  double bottomLatitude=MapUtils.getLatitudeFromTile(zoom,tileNumberY + 0.5);
  double leftLongitude=MapUtils.getLongitudeFromTile(zoom,tileNumberX - 0.5);
  double rightLongitude=MapUtils.getLongitudeFromTile(zoom,tileNumberX + 0.5);
  SearchRequest<TransportStop> req=BinaryMapIndexReader.buildSearchTransportRequest(MapUtils.get31TileNumberX(leftLongitude),MapUtils.get31TileNumberX(rightLongitude),MapUtils.get31TileNumberY(topLatitude),MapUtils.get31TileNumberY(bottomLatitude),-1,null);
  List<RouteInfoLocation> listRoutes=new ArrayList<RouteInfoLocation>();
  try {
    List<TransportStop> stops=file.searchTransportIndex(req);
    Map<Long,RouteInfoLocation> registeredRoutes=new LinkedHashMap<Long,RouteInfoLocation>();
    for (    TransportStop s : stops) {
      for (      int ref : s.getReferencesToRoutes()) {
        TransportRoute route=file.getTransportRoute(ref);
        for (int i=0; i < 2; i++) {
          boolean direction=i == 0;
          List<TransportStop> stps=direction ? route.getForwardStops() : route.getBackwardStops();
          while (!stps.isEmpty() && (stps.get(0).getId().longValue() != s.getId().longValue())) {
            stps.remove(0);
          }
          if (!stps.isEmpty()) {
            long idToPut=route.getId() << 1 + (direction ? 1 : 0);
            if (registeredRoutes.containsKey(idToPut)) {
              TransportStop st=registeredRoutes.get(idToPut).getStart();
              if (MapUtils.getDistance(loc,st.getLocation()) < MapUtils.getDistance(loc,s.getLocation())) {
                continue;
              }
            }
            RouteInfoLocation r=new RouteInfoLocation();
            r.setRoute(route);
            r.setStart(stps.get(0));
            r.setDirection(direction);
            if (locationToGo != null) {
              int distToLoc=Integer.MAX_VALUE;
              for (              TransportStop st : stps) {
                double ndist=MapUtils.getDistance(locationToGo,st.getLocation());
                if (ndist < distToLoc) {
                  distToLoc=(int)ndist;
                  r.setStop(st);
                  r.setDistToLocation(distToLoc);
                }
              }
            }
            registeredRoutes.put(idToPut,r);
          }
        }
      }
    }
    if (log.isDebugEnabled()) {
      log.debug(String.format("Search for routes done in %s ms found %s.",System.currentTimeMillis() - now,registeredRoutes.size()));
    }
    listRoutes=new ArrayList<RouteInfoLocation>(registeredRoutes.values());
    if (locationToGo != null) {
      Collections.sort(listRoutes,new Comparator<RouteInfoLocation>(){
        @Override public int compare(        RouteInfoLocation object1,        RouteInfoLocation object2){
          int x=(int)(MapUtils.getDistance(loc,object1.getStart().getLocation()) + object1.getDistToLocation());
          int y=(int)(MapUtils.getDistance(loc,object2.getStart().getLocation()) + object2.getDistToLocation());
          return x - y;
        }
      }
);
    }
 else {
      Collections.sort(listRoutes,new Comparator<RouteInfoLocation>(){
        @Override public int compare(        RouteInfoLocation object1,        RouteInfoLocation object2){
          return Double.compare(MapUtils.getDistance(loc,object1.getStart().getLocation()),MapUtils.getDistance(loc,object2.getStart().getLocation()));
        }
      }
);
    }
  }
 catch (  IOException e) {
    log.error("Disk error",e);
  }
  return listRoutes;
}
