{
  progress.startTask("Reading transport...",-1);
  Map<String,List<TransportRoute>> routes=country.getTransportRoutes();
  Map<Long,TransportStop> routeStops=new LinkedHashMap<Long,TransportStop>();
  for (  Relation rel : transport) {
    String ref=rel.getTag(OSMTagKey.REF);
    String route=rel.getTag(OSMTagKey.ROUTE);
    String operator=rel.getTag(OSMTagKey.OPERATOR);
    if (route == null || ref == null) {
      continue;
    }
    if (!acceptedRoutes.contains(route)) {
      continue;
    }
    TransportRoute r=new TransportRoute(rel,ref);
    r.setOperator(operator);
    r.setType(route);
    if (operator != null) {
      route=operator + " : " + route;
    }
    if (!routes.containsKey(route)) {
      routes.put(route,new ArrayList<TransportRoute>());
    }
    final Map<TransportStop,Integer> forwardStops=new LinkedHashMap<TransportStop,Integer>();
    final Map<TransportStop,Integer> backwardStops=new LinkedHashMap<TransportStop,Integer>();
    int currentStop=0;
    int forwardStop=0;
    int backwardStop=0;
    for (    Entry<Entity,String> e : rel.getMemberEntities().entrySet()) {
      if (e.getValue().contains("stop")) {
        if (e.getKey() instanceof Node) {
          if (!routeStops.containsKey(e.getKey().getId())) {
            routeStops.put(e.getKey().getId(),new TransportStop(e.getKey()));
          }
          TransportStop stop=routeStops.get(e.getKey().getId());
          boolean forward=e.getValue().contains("forward");
          boolean backward=e.getValue().contains("backward");
          currentStop++;
          if (forward || !backward) {
            forwardStop++;
          }
          if (backward) {
            backwardStop++;
          }
          boolean common=!forward && !backward;
          int index=-1;
          int i=e.getValue().length() - 1;
          int accum=1;
          while (i >= 0 && Character.isDigit(e.getValue().charAt(i))) {
            if (index < 0) {
              index=0;
            }
            index=accum * Character.getNumericValue(e.getValue().charAt(i)) + index;
            accum*=10;
            i--;
          }
          if (index < 0) {
            index=forward ? forwardStop : (backward ? backwardStop : currentStop);
          }
          if (forward || common) {
            forwardStops.put(stop,index);
            r.getForwardStops().add(stop);
          }
          if (backward || common) {
            if (common) {
              backwardStops.put(stop,-index);
            }
 else {
              backwardStops.put(stop,index);
            }
            r.getBackwardStops().add(stop);
          }
        }
      }
 else       if (e.getKey() instanceof Way) {
        r.addWay((Way)e.getKey());
      }
    }
    if (forwardStops.isEmpty() && backwardStops.isEmpty()) {
      continue;
    }
    Collections.sort(r.getForwardStops(),new Comparator<TransportStop>(){
      @Override public int compare(      TransportStop o1,      TransportStop o2){
        return forwardStops.get(o1) - forwardStops.get(o2);
      }
    }
);
    for (    TransportStop s : new ArrayList<TransportStop>(backwardStops.keySet())) {
      if (backwardStops.get(s) < 0) {
        backwardStops.put(s,backwardStops.size() + backwardStops.get(s) - 1);
      }
    }
    Collections.sort(r.getBackwardStops(),new Comparator<TransportStop>(){
      @Override public int compare(      TransportStop o1,      TransportStop o2){
        return backwardStops.get(o1) - backwardStops.get(o2);
      }
    }
);
    routes.get(route).add(r);
  }
  progress.finishTask();
}
