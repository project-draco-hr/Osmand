{
  if (render == null || pair == null) {
    return;
  }
  int length=obj.getPointsLength();
  if (length < 2) {
    return;
  }
  render.setInitialTagValueZoom(pair.tag,pair.value,rc.zoom);
  render.setIntFilter(render.ALL.R_LAYER,layer);
  boolean rendered=render.search(RenderingRulesStorage.LINE_RULES);
  if (!rendered || !updatePaint(render,paint,0,false)) {
    return;
  }
  boolean oneway=false;
  if (rc.zoom >= 16 && "highway".equals(pair.tag) && MapRenderingTypes.isOneWayWay(obj.getHighwayAttributes())) {
    oneway=true;
  }
  rc.visible++;
  Path path=null;
  float pathRotate=0;
  float roadLength=0;
  boolean inverse=false;
  float xPrev=0;
  float yPrev=0;
  float xMid=0;
  float yMid=0;
  PointF middlePoint=new PointF();
  int middle=obj.getPointsLength() / 2;
  for (int i=0; i < length; i++) {
    PointF p=calcPoint(obj,i,rc);
    if (i == 0 || i == length - 1) {
      xMid+=p.x;
      yMid+=p.y;
    }
    if (path == null) {
      path=new Path();
      path.moveTo(p.x,p.y);
    }
 else {
      roadLength+=Math.sqrt((p.x - xPrev) * (p.x - xPrev) + (p.y - yPrev) * (p.y - yPrev));
      if (i == middle) {
        middlePoint.set(p.x,p.y);
        double rot=-Math.atan2(p.x - xPrev,p.y - yPrev) * 180 / Math.PI;
        if (rot < 0) {
          rot+=360;
        }
        if (rot < 180) {
          rot+=180;
          inverse=true;
        }
        pathRotate=(float)rot;
      }
      path.lineTo(p.x,p.y);
    }
    xPrev=p.x;
    yPrev=p.y;
  }
  if (path != null) {
    canvas.drawPath(path,paint);
    if (updatePaint(render,paint,1,false)) {
      canvas.drawPath(path,paint);
      if (updatePaint(render,paint,2,false)) {
        canvas.drawPath(path,paint);
      }
    }
    if (oneway) {
      Paint[] paints=getOneWayPaints();
      for (int i=0; i < paints.length; i++) {
        canvas.drawPath(path,paints[i]);
      }
    }
    if (obj.getName() != null && obj.getName().length() > 0) {
      String name=obj.getName();
      String ref=null;
      if (name.charAt(0) == MapRenderingTypes.REF_CHAR) {
        ref=name.substring(1);
        name="";
        for (int k=0; k < ref.length(); k++) {
          if (ref.charAt(k) == MapRenderingTypes.REF_CHAR) {
            if (k < ref.length() - 1) {
              name=ref.substring(k + 1);
            }
            ref=ref.substring(0,k);
            break;
          }
        }
      }
      if (ref != null && ref.trim().length() > 0) {
        render.setInitialTagValueZoom(pair.tag,pair.value,rc.zoom);
        render.setIntFilter(render.ALL.R_TEXT_LENGTH,ref.length());
        render.setBooleanFilter(render.ALL.R_REF,true);
        if (render.search(RenderingRulesStorage.TEXT_RULES)) {
          if (render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0) {
            TextDrawInfo text=new TextDrawInfo(ref);
            text.fillProperties(render,middlePoint.x,middlePoint.y);
            text.pathRotate=pathRotate;
            rc.textToDraw.add(text);
          }
        }
      }
      if (name != null && name.trim().length() > 0) {
        render.setInitialTagValueZoom(pair.tag,pair.value,rc.zoom);
        render.setIntFilter(render.ALL.R_TEXT_LENGTH,name.length());
        render.setBooleanFilter(render.ALL.R_REF,false);
        if (render.search(RenderingRulesStorage.TEXT_RULES) && render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0) {
          TextDrawInfo text=new TextDrawInfo(name);
          if (render.getIntPropertyValue(render.ALL.R_TEXT_ON_PATH,0) == 0) {
            text.fillProperties(render,middlePoint.x,middlePoint.y);
            rc.textToDraw.add(text);
          }
 else {
            paintText.setTextSize(text.textSize);
            if (paintText.measureText(obj.getName()) < roadLength) {
              if (inverse) {
                path.rewind();
                boolean st=true;
                for (int i=obj.getPointsLength() - 1; i >= 0; i--) {
                  PointF p=calcPoint(obj,i,rc);
                  if (st) {
                    st=false;
                    path.moveTo(p.x,p.y);
                  }
 else {
                    path.lineTo(p.x,p.y);
                  }
                }
              }
              text.fillProperties(render,xMid / 2,yMid / 2);
              text.pathRotate=pathRotate;
              text.drawOnPath=path;
              float strokeWidth=render.getFloatPropertyValue(render.ALL.R_STROKE_WIDTH);
              text.vOffset=strokeWidth / 2 - 1;
              rc.textToDraw.add(text);
            }
          }
        }
      }
    }
  }
}
