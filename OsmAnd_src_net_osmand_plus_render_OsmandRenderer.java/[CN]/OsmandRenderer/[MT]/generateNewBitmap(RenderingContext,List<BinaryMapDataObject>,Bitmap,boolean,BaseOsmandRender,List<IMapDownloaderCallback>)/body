{
  long now=System.currentTimeMillis();
  Canvas cv=new Canvas(bmp);
  if (renderer != null) {
    int dc=renderer.getDefaultColor();
    if (dc != 0) {
      paintFillEmpty.setColor(dc);
    }
  }
  cv.drawRect(0,0,bmp.getWidth(),bmp.getHeight(),paintFillEmpty);
  int sz=objects.size();
  int init=sz / 4;
  TFloatObjectHashMap<TIntArrayList> orderMap=new TFloatObjectHashMap<TIntArrayList>();
  if (renderer != null) {
    for (int i=0; i < sz; i++) {
      BinaryMapDataObject o=objects.get(i);
      int sh=i << 8;
      if (o instanceof MultyPolygon) {
        int mask=MapRenderingTypes.MULTY_POLYGON_TYPE;
        int layer=((MultyPolygon)o).getLayer();
        put(orderMap,renderer.getObjectOrder(((MultyPolygon)o).getTag(),((MultyPolygon)o).getValue(),mask,layer),sh,init);
      }
 else {
        for (int j=0; j < o.getTypes().length; j++) {
          int wholeType=o.getTypes()[j];
          int mask=wholeType & 3;
          int layer=0;
          if (mask != 1) {
            layer=MapRenderingTypes.getNegativeWayLayer(wholeType);
          }
          TagValuePair pair=o.getMapIndex().decodeType(MapRenderingTypes.getMainObjectType(wholeType),MapRenderingTypes.getObjectSubType(wholeType));
          if (pair != null) {
            put(orderMap,renderer.getObjectOrder(pair.tag,pair.value,mask,layer),sh + j,init);
          }
        }
      }
      if (rc.interrupted) {
        return null;
      }
    }
  }
  if (objects != null && !objects.isEmpty() && rc.width > 0 && rc.height > 0) {
    rc.tileDivisor=(int)(1 << (31 - rc.zoom));
    rc.cosRotateTileSize=FloatMath.cos((float)Math.toRadians(rc.rotate)) * TILE_SIZE;
    rc.sinRotateTileSize=FloatMath.sin((float)Math.toRadians(rc.rotate)) * TILE_SIZE;
    float[] keys=orderMap.keys();
    Arrays.sort(keys);
    int objCount=0;
    for (int k=0; k < keys.length; k++) {
      TIntArrayList list=orderMap.get(keys[k]);
      for (int j=0; j < list.size(); j++) {
        int i=list.get(j);
        int ind=i >> 8;
        int l=i & 0xff;
        BinaryMapDataObject obj=objects.get(ind);
        drawObj(obj,renderer,cv,rc,l,l == 0);
        objCount++;
      }
      if (objCount > 25) {
        notifyListeners(notifyList);
        objCount=0;
      }
      if (rc.interrupted) {
        return null;
      }
    }
    notifyListeners(notifyList);
    int skewConstant=(int)(16 * dm.density);
    int iconsW=rc.width / skewConstant;
    int iconsH=rc.height / skewConstant;
    int[] alreadyDrawnIcons=new int[iconsW * iconsH / 32];
    for (    IconDrawInfo icon : rc.iconsToDraw) {
      if (icon.resId != 0) {
        if (cachedIcons.get(icon.resId) == null) {
          cachedIcons.put(icon.resId,UnscaledBitmapLoader.loadFromResource(context.getResources(),icon.resId,null,dm));
        }
        Bitmap ico=cachedIcons.get(icon.resId);
        if (ico != null) {
          if (icon.y >= 0 && icon.y < rc.height && icon.x >= 0 && icon.x < rc.width) {
            int z=(((int)icon.x / skewConstant) + ((int)icon.y / skewConstant) * iconsW);
            int i=z / 32;
            if (i >= alreadyDrawnIcons.length) {
              continue;
            }
            int ind=alreadyDrawnIcons[i];
            int b=z % 32;
            if (((ind >> b) & 1) == 0) {
              alreadyDrawnIcons[i]=ind | (1 << b);
              cv.drawBitmap(ico,icon.x - ico.getWidth() / 2,icon.y - ico.getHeight() / 2,paintIcon);
            }
          }
        }
      }
      if (rc.interrupted) {
        return null;
      }
    }
    notifyListeners(notifyList);
    drawTextOverCanvas(rc,cv,useEnglishNames);
    long time=System.currentTimeMillis() - now;
    rc.renderingDebugInfo=String.format("Rendering has been done in %s ms. (%s points, %s points inside, %s visile from %s)",time,rc.pointCount,rc.pointInsideCount,rc.visible,rc.allObjects);
    log.info(rc.renderingDebugInfo);
  }
  return bmp;
}
