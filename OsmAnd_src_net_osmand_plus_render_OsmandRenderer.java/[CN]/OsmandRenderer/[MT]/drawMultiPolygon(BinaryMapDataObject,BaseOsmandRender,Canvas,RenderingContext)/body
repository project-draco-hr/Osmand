{
  String tag=((MultyPolygon)obj).getTag();
  String value=((MultyPolygon)obj).getValue();
  if (render == null || tag == null) {
    return;
  }
  rc.main.emptyArea();
  rc.second.emptyLine();
  rc.main.color=Color.rgb(245,245,245);
  boolean rendered=render.renderPolygon(tag,value,rc.zoom,rc,this);
  if (!rendered) {
    return;
  }
  rc.visible++;
  Path path=new Path();
  for (int i=0; i < ((MultyPolygon)obj).getBoundsCount(); i++) {
    int cnt=((MultyPolygon)obj).getBoundPointsCount(i);
    float xText=0;
    float yText=0;
    for (int j=0; j < cnt; j++) {
      PointF p=calcMultiPolygonPoint((MultyPolygon)obj,j,i,rc);
      xText+=p.x;
      yText+=p.y;
      if (j == 0) {
        path.moveTo(p.x,p.y);
      }
 else {
        path.lineTo(p.x,p.y);
      }
    }
    if (cnt > 0) {
      String name=((MultyPolygon)obj).getName(i);
      if (name != null) {
        rc.clearText();
        name=render.renderObjectText(name,tag,value,rc,false);
        if (rc.textSize > 0 && name != null) {
          TextDrawInfo info=new TextDrawInfo(name);
          info.fillProperties(rc,xText / cnt,yText / cnt);
          rc.textToDraw.add(info);
        }
      }
    }
  }
  rc.main.updatePaint(paint);
  canvas.drawPath(path,paint);
  if (rc.second.strokeWidth != 0) {
    rc.second.updatePaint(paint);
    canvas.drawPath(path,paint);
  }
}
