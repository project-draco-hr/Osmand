{
  boolean horizontalWayDisplay=(text.pathRotate > 45 && text.pathRotate < 135) || (text.pathRotate > 225 && text.pathRotate < 315);
  float textWidth=paintText.measureText(text.text) + (!horizontalWayDisplay ? 0 : text.minDistance);
  int ascent=(int)Math.ceil(-paintText.ascent());
  int descent=(int)Math.ceil(paintText.descent());
  float textHeight=ascent + descent + (horizontalWayDisplay ? 0 : text.minDistance)+ getDensityValue(rc,5);
  RectF bounds=new RectF();
  if (text.drawOnPath == null || horizontalWayDisplay) {
    bounds.set(text.centerX - textWidth / 2,text.centerY - textHeight / 2,text.centerX + textWidth / 2,text.centerY + textHeight / 2);
  }
 else {
    bounds.set(text.centerX - textHeight / 2,text.centerY - textWidth / 2,text.centerX + textHeight / 2,text.centerY + textWidth / 2);
  }
  List<RectF> boundsIntersect=text.drawOnPath == null || findAllTextIntersections ? boundsNotPathIntersect : boundsPathIntersect;
  if (boundsIntersect.isEmpty()) {
    boundsIntersect.add(bounds);
  }
 else {
    final int diff=(int)(getDensityValue(rc,3));
    final int diff2=(int)(getDensityValue(rc,15));
    int index=Collections.binarySearch(boundsIntersect,bounds,c);
    if (index < 0) {
      index=-(index + 1);
    }
    int e=index;
    while (e < boundsIntersect.size()) {
      if (boundsIntersect.get(e).left < bounds.right) {
        e++;
      }
 else {
        break;
      }
    }
    int st=index - 1;
    while (st >= 0) {
      if (boundsIntersect.get(st).right > bounds.left) {
        st--;
      }
 else {
        break;
      }
    }
    if (st < 0) {
      st=0;
    }
    for (int j=st; j < e; j++) {
      RectF b=boundsIntersect.get(j);
      float x=Math.min(bounds.right,b.right) - Math.max(b.left,bounds.left);
      float y=Math.min(bounds.bottom,b.bottom) - Math.max(b.top,bounds.top);
      if ((x > diff && y > diff2) || (x > diff2 && y > diff)) {
        return true;
      }
    }
    boundsIntersect.add(index,bounds);
  }
  return false;
}
