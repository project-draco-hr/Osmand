{
  streetDAO.close();
  closePreparedStatements(addressCityStat);
  mapConnection.commit();
  boolean readWayNodes=saveAddressWays;
  writer.startWriteAddressIndex(regionName);
  List<City> cities=readCities(mapConnection);
  Collections.sort(cities,new Comparator<City>(){
    @Override public int compare(    City o1,    City o2){
      if (o1.getType() != o2.getType()) {
        return (o1.getType().ordinal() - o2.getType().ordinal());
      }
      return Collator.getInstance().compare(o1.getName(),o2.getName());
    }
  }
);
  PreparedStatement streetstat=mapConnection.prepareStatement("SELECT A.id, A.name, A.name_en, A.latitude, A.longitude, " + "B.id, B.name, B.name_en, B.latitude, B.longitude, B.postcode, A.cityPart " + "FROM street A left JOIN building B ON B.street = A.id JOIN city C ON A.city = C.id "+ "WHERE A.city = ? ORDER BY C.name == A.cityPart DESC");
  PreparedStatement waynodesStat=null;
  if (readWayNodes) {
    waynodesStat=mapConnection.prepareStatement("SELECT A.id, A.latitude, A.longitude FROM street_node A WHERE A.street = ? ");
  }
  int j=0;
  int csize=cities.size();
  for (; j < csize; j++) {
    City c=cities.get(j);
    if (c.getType() != CityType.CITY && c.getType() != CityType.TOWN) {
      break;
    }
  }
  progress.startTask(Messages.getString("IndexCreator.SERIALIZING_ADRESS"),j + ((csize - j) / 100 + 1));
  Map<String,Set<Street>> postcodes=new TreeMap<String,Set<Street>>();
  boolean writeCities=true;
  List<City> suburbs=new ArrayList<City>();
  for (  City s : cities) {
    if (s.getType() == CityType.SUBURB && s.getIsInValue() != null) {
      suburbs.add(s);
    }
  }
  writer.startCityIndexes(false);
  for (int i=0; i < csize; i++) {
    City c=cities.get(i);
    List<City> listSuburbs=null;
    for (    City suburb : suburbs) {
      if (suburb.getIsInValue().contains(c.getName().toLowerCase())) {
        if (listSuburbs == null) {
          listSuburbs=new ArrayList<City>();
        }
        listSuburbs.add(suburb);
      }
    }
    if (writeCities) {
      progress.progress(1);
    }
 else     if ((csize - i) % 100 == 0) {
      progress.progress(1);
    }
    if (writeCities && c.getType() != CityType.CITY && c.getType() != CityType.TOWN) {
      writer.endCityIndexes(false);
      writer.startCityIndexes(true);
      writeCities=false;
    }
    Map<Street,List<Node>> streetNodes=null;
    if (readWayNodes) {
      streetNodes=new LinkedHashMap<Street,List<Node>>();
    }
    long time=System.currentTimeMillis();
    List<Street> streets=readStreetsBuildings(streetstat,c,waynodesStat,streetNodes,listSuburbs);
    long f=System.currentTimeMillis() - time;
    writer.writeCityIndex(c,streets,streetNodes);
    int bCount=0;
    for (    Street s : streets) {
      bCount++;
      for (      Building b : s.getBuildings()) {
        bCount++;
        if (b.getPostcode() != null) {
          if (!postcodes.containsKey(b.getPostcode())) {
            postcodes.put(b.getPostcode(),new LinkedHashSet<Street>(3));
          }
          postcodes.get(b.getPostcode()).add(s);
        }
      }
    }
    if (f > 500) {
      System.out.println("! " + c.getName() + " ! "+ f+ " "+ bCount+ " streets "+ streets.size());
    }
  }
  writer.endCityIndexes(!writeCities);
  writer.startPostcodes();
  for (  String s : postcodes.keySet()) {
    writer.writePostcode(s,postcodes.get(s));
  }
  writer.endPostcodes();
  progress.finishTask();
  writer.endWriteAddressIndex();
  writer.flush();
  streetstat.close();
  if (readWayNodes) {
    waynodesStat.close();
  }
}
