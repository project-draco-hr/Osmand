{
  List<Way> res=new ArrayList<Way>();
  long time=System.currentTimeMillis();
  List<File> files=new ArrayList<File>();
  for (  File f : new File(DataExtractionSettings.getSettings().getBinaryFilesDir()).listFiles()) {
    if (f.getName().endsWith(".obf")) {
      files.add(f);
    }
  }
  final boolean animateRoutingCalculation=DataExtractionSettings.getSettings().isAnimateRouting();
  if (animateRoutingCalculation) {
    nextTurn.setVisible(true);
    playPauseButton.setVisible(true);
    stopButton.setVisible(true);
    pause=true;
    playPauseButton.setText("Play");
  }
  stop=false;
  if (files == null) {
    JOptionPane.showMessageDialog(OsmExtractionUI.MAIN_APP.getFrame(),"Please specify obf file in settings","Obf file not found",JOptionPane.ERROR_MESSAGE);
    return null;
  }
  System.out.println("Self made route from " + start + " to "+ end);
  if (start != null && end != null) {
    try {
      BinaryMapIndexReader[] rs=new BinaryMapIndexReader[files.size()];
      int it=0;
      for (      File f : files) {
        RandomAccessFile raf=new RandomAccessFile(f,"r");
        rs[it++]=new BinaryMapIndexReader(raf,false);
      }
      BinaryRoutePlanner router=new BinaryRoutePlanner(rs);
      RoutingContext ctx=new RoutingContext();
      ctx.setRouter(this.routerMode);
      ctx.setPlanRoadDirection(true);
      RouteSegment st=router.findRouteSegment(start.getLatitude(),start.getLongitude(),ctx);
      if (st == null) {
        throw new RuntimeException("Start point to calculate route was not found");
      }
      System.out.println("ROAD TO START " + st.getRoad().getHighway() + " "+ st.getRoad().id);
      RouteSegment e=router.findRouteSegment(end.getLatitude(),end.getLongitude(),ctx);
      if (e == null) {
        throw new RuntimeException("End point to calculate route was not found");
      }
      System.out.println("ROAD TO END " + e.getRoad().getHighway() + " "+ e.getRoad().id);
      final DataTileManager<Way> points=new DataTileManager<Way>();
      points.setZoom(11);
      map.setPoints(points);
      ctx.setVisitor(new RouteSegmentVisitor(){
        private List<RouteSegment> cache=new ArrayList<RouteSegment>();
        private List<RouteSegment> pollCache=new ArrayList<RouteSegment>();
        @Override public void visitSegment(        RouteSegment s,        boolean poll){
          if (stop) {
            throw new RuntimeException("Interrupted");
          }
          if (!animateRoutingCalculation) {
            return;
          }
          if (!poll && pause) {
            pollCache.add(s);
            return;
          }
          cache.add(s);
          if (cache.size() < steps) {
            return;
          }
          if (pause) {
            registerObjects(points,poll,pollCache);
            pollCache.clear();
          }
          registerObjects(points,!poll,cache);
          cache.clear();
          redraw();
          if (pause) {
            waitNextPress();
          }
        }
        private void redraw(){
          try {
            SwingUtilities.invokeAndWait(new Runnable(){
              @Override public void run(){
                map.prepareImage();
              }
            }
);
          }
 catch (          InterruptedException e1) {
          }
catch (          InvocationTargetException e) {
            e.printStackTrace();
          }
        }
        private void registerObjects(        final DataTileManager<Way> points,        boolean white,        List<RouteSegment> registerCache){
          for (          RouteSegment segment : registerCache) {
            Way way=new Way(-1);
            way.putTag(OSMTagKey.NAME.getValue(),segment.getTestName());
            if (white) {
              way.putTag("color","white");
            }
            for (int i=0; i < segment.getRoad().getPointsLength(); i++) {
              net.osmand.osm.Node n=new net.osmand.osm.Node(MapUtils.get31LatitudeY(segment.getRoad().getPoint31YTile(i)),MapUtils.get31LongitudeX(segment.getRoad().getPoint31XTile(i)),-1);
              way.addNode(n);
            }
            LatLon n=way.getLatLon();
            points.registerObject(n.getLatitude(),n.getLongitude(),way);
          }
        }
      }
);
      List<RouteSegmentResult> searchRoute=router.searchRoute(ctx,st,e);
      if (pause) {
        nextTurn.setText("FINISH");
        waitNextPress();
        nextTurn.setText(">>");
      }
      net.osmand.osm.Node prevWayNode=null;
      for (      RouteSegmentResult s : searchRoute) {
        Way way=new Way(-1);
        boolean plus=s.startPointIndex < s.endPointIndex;
        int i=s.startPointIndex;
        while (true) {
          net.osmand.osm.Node n=new net.osmand.osm.Node(MapUtils.get31LatitudeY(s.object.getPoint31YTile(i)),MapUtils.get31LongitudeX(s.object.getPoint31XTile(i)),-1);
          if (prevWayNode != null) {
            if (MapUtils.getDistance(prevWayNode,n) > 0) {
              System.out.println("Warning not connected road " + " " + s.object.getHighway() + " dist "+ MapUtils.getDistance(prevWayNode,n));
            }
            prevWayNode=null;
          }
          way.addNode(n);
          if (i == s.endPointIndex) {
            break;
          }
          if (plus) {
            i++;
          }
 else {
            i--;
          }
        }
        if (way.getNodes().size() > 0) {
          prevWayNode=way.getNodes().get(way.getNodes().size() - 1);
        }
        res.add(way);
      }
    }
 catch (    IOException e) {
      ExceptionHandler.handle(e);
    }
 finally {
      playPauseButton.setVisible(false);
      nextTurn.setVisible(false);
      stopButton.setVisible(false);
      map.getPoints().clear();
    }
    System.out.println("Finding self routes " + res.size() + " "+ (System.currentTimeMillis() - time)+ " ms");
  }
  return res;
}
