{
  List<Way> res=new ArrayList<Way>();
  long time=System.currentTimeMillis();
  List<File> files=new ArrayList<File>();
  for (  File f : new File(DataExtractionSettings.getSettings().getBinaryFilesDir()).listFiles()) {
    if (f.getName().endsWith(".obf")) {
      files.add(f);
    }
  }
  String xmlPath=DataExtractionSettings.getSettings().getRoutingXmlPath();
  Builder builder;
  if (xmlPath.equals("routing.xml")) {
    builder=RoutingConfiguration.getDefault();
  }
 else {
    try {
      builder=RoutingConfiguration.parseFromInputStream(new FileInputStream(xmlPath));
    }
 catch (    IOException e) {
      throw new IllegalArgumentException("Error parsing routing.xml file",e);
    }
catch (    SAXException e) {
      throw new IllegalArgumentException("Error parsing routing.xml file",e);
    }
  }
  final boolean animateRoutingCalculation=DataExtractionSettings.getSettings().isAnimateRouting();
  if (animateRoutingCalculation) {
    nextTurn.setVisible(true);
    playPauseButton.setVisible(true);
    stopButton.setVisible(true);
    pause=true;
    playPauseButton.setText("Play");
  }
  stop=false;
  if (files.isEmpty()) {
    JOptionPane.showMessageDialog(OsmExtractionUI.MAIN_APP.getFrame(),"Please specify obf file in settings","Obf file not found",JOptionPane.ERROR_MESSAGE);
    return null;
  }
  System.out.println("Self made route from " + start + " to "+ end);
  if (start != null && end != null) {
    try {
      BinaryMapIndexReader[] rs=new BinaryMapIndexReader[files.size()];
      int it=0;
      for (      File f : files) {
        RandomAccessFile raf=new RandomAccessFile(f,"r");
        rs[it++]=new BinaryMapIndexReader(raf);
      }
      String m=DataExtractionSettings.getSettings().getRouteMode();
      String[] props=m.split("\\,");
      RoutePlannerFrontEnd router=new RoutePlannerFrontEnd(true);
      RoutingConfiguration config=builder.build(props[0],RoutingConfiguration.DEFAULT_MEMORY_LIMIT,props);
      final RoutingContext ctx=new RoutingContext(config,NativeSwingRendering.getDefaultFromSettings(),rs,useBasemap);
      ctx.previouslyCalculatedRoute=previousRoute;
      log.info("Use " + config.routerName + "mode for routing");
      final DataTileManager<Entity> points=new DataTileManager<Entity>(11);
      map.setPoints(points);
      ctx.setVisitor(createSegmentVisitor(animateRoutingCalculation,points));
      long nt=System.nanoTime();
      new Thread(){
        @Override public void run(){
          while (!ctx.calculationProgress.isCancelled) {
            float p=ctx.calculationProgress.distanceFromBegin + ctx.calculationProgress.distanceFromEnd;
            float all=ctx.calculationProgress.totalEstimatedDistance;
            if (all > 0) {
              int t=(int)(p * p / (all * all) * 100f);
              System.out.println("Progress " + t + " % "+ ctx.calculationProgress.distanceFromBegin+ " "+ ctx.calculationProgress.distanceFromEnd+ " "+ all);
            }
            try {
              sleep(100);
            }
 catch (            InterruptedException e) {
              e.printStackTrace();
            }
          }
        }
      }
.start();
      try {
        List<RouteSegmentResult> searchRoute=router.searchRoute(ctx,start,end,intermediates,false);
        if (searchRoute == null) {
          String reason="unknown";
          if (ctx.calculationProgress.segmentNotFound >= 0) {
            if (ctx.calculationProgress.segmentNotFound == 0) {
              reason=" start point is too far from road";
            }
 else {
              reason=" target point " + ctx.calculationProgress.segmentNotFound + " is too far from road";
            }
          }
 else           if (ctx.calculationProgress.directSegmentQueueSize == 0) {
            reason=" route can not be found from start point (" + ctx.calculationProgress.distanceFromBegin / 1000f + " km)";
          }
 else           if (ctx.calculationProgress.reverseSegmentQueueSize == 0) {
            reason=" route can not be found from end point (" + ctx.calculationProgress.distanceFromEnd / 1000f + " km)";
          }
          throw new RuntimeException("Route not found : " + reason);
        }
        System.out.println("External native time " + (System.nanoTime() - nt) / 1e9f);
        if (animateRoutingCalculation) {
          playPauseButton.setVisible(false);
          nextTurn.setText("FINISH");
          waitNextPress();
          nextTurn.setText(">>");
        }
        calculateResult(res,searchRoute);
      }
  finally {
        ctx.calculationProgress.isCancelled=true;
      }
    }
 catch (    Exception e) {
      ExceptionHandler.handle(e);
    }
 finally {
      playPauseButton.setVisible(false);
      nextTurn.setVisible(false);
      stopButton.setVisible(false);
      if (map.getPoints() != null) {
        map.getPoints().clear();
      }
    }
    System.out.println("Finding self routes " + res.size() + " "+ (System.currentTimeMillis() - time)+ " ms");
  }
  return res;
}
