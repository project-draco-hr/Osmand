{
  if (!res.isCalculated()) {
    return;
  }
  float speed=1.5f;
  int minDistanceForTurn=5;
  if (mode == ApplicationMode.CAR) {
    speed=15.3f;
    minDistanceForTurn=35;
  }
 else   if (mode == ApplicationMode.BICYCLE) {
    speed=5.5f;
    minDistanceForTurn=12;
  }
  List<RouteDirectionInfo> directions=new ArrayList<RouteDirectionInfo>();
  int[] listDistance=res.getListDistance();
  List<Location> locations=res.getLocations();
  int previousLocation=0;
  int prevBearingLocation=0;
  RouteDirectionInfo previousInfo=new RouteDirectionInfo(speed,TurnType.valueOf(TurnType.C,leftSide));
  previousInfo.routePointOffset=0;
  previousInfo.descriptionRoute=getString(ctx,R.string.route_head);
  directions.add(previousInfo);
  int distForTurn=0;
  float previousBearing=0;
  int startTurnPoint=0;
  for (int i=1; i < locations.size() - 1; i++) {
    Location next=locations.get(i + 1);
    Location current=locations.get(i);
    float bearing=current.bearingTo(next);
    while (prevBearingLocation < i - 1) {
      if (locations.get(prevBearingLocation + 1).distanceTo(current) > 70) {
        prevBearingLocation++;
      }
 else {
        break;
      }
    }
    if (distForTurn == 0) {
      previousBearing=locations.get(prevBearingLocation).bearingTo(current);
      startTurnPoint=i;
    }
    TurnType type=null;
    String description=null;
    float delta=previousBearing - bearing;
    while (delta < 0) {
      delta+=360;
    }
    while (delta > 360) {
      delta-=360;
    }
    distForTurn+=locations.get(i).distanceTo(locations.get(i + 1));
    if (i < locations.size() - 1 && distForTurn < minDistanceForTurn) {
      continue;
    }
    if (delta > 45 && delta < 315) {
      if (delta < 60) {
        type=TurnType.valueOf(TurnType.TSLL,leftSide);
        description=getString(ctx,R.string.route_tsll);
      }
 else       if (delta < 120) {
        type=TurnType.valueOf(TurnType.TL,leftSide);
        description=getString(ctx,R.string.route_tl);
      }
 else       if (delta < 150) {
        type=TurnType.valueOf(TurnType.TSHL,leftSide);
        description=getString(ctx,R.string.route_tshl);
      }
 else       if (delta < 210) {
        type=TurnType.valueOf(TurnType.TU,leftSide);
        description=getString(ctx,R.string.route_tu);
      }
 else       if (delta < 240) {
        description=getString(ctx,R.string.route_tshr);
        type=TurnType.valueOf(TurnType.TSHR,leftSide);
      }
 else       if (delta < 300) {
        description=getString(ctx,R.string.route_tr);
        type=TurnType.valueOf(TurnType.TR,leftSide);
      }
 else {
        description=getString(ctx,R.string.route_tslr);
        type=TurnType.valueOf(TurnType.TSLR,leftSide);
      }
      previousInfo.distance=listDistance[previousLocation] - listDistance[i];
      previousInfo.descriptionRoute+=" " + OsmAndFormatter.getFormattedDistance(previousInfo.distance,ctx);
      type.setTurnAngle(360 - delta);
      previousInfo=new RouteDirectionInfo(speed,type);
      previousInfo.descriptionRoute=description;
      previousInfo.routePointOffset=startTurnPoint;
      directions.add(previousInfo);
      previousLocation=startTurnPoint;
      prevBearingLocation=i;
    }
    distForTurn=0;
  }
  previousInfo.distance=listDistance[previousLocation];
  previousInfo.descriptionRoute+=" " + OsmAndFormatter.getFormattedDistance(previousInfo.distance,ctx);
  if (previousInfo.distance > 80) {
    RouteDirectionInfo info=new RouteDirectionInfo(speed,TurnType.valueOf(TurnType.C,leftSide));
    info.distance=0;
    info.descriptionRoute="";
    info.routePointOffset=locations.size() - 1;
    directions.add(info);
  }
  if (res.directions == null || res.directions.isEmpty()) {
    res.setDirections(new ArrayList<RouteDirectionInfo>(directions));
  }
 else {
    int currentDirection=0;
    for (int i=0; i <= res.directions.size() && currentDirection < directions.size(); i++) {
      while (currentDirection < directions.size()) {
        int distanceAfter=0;
        if (i < res.directions.size()) {
          RouteDirectionInfo resInfo=res.directions.get(i);
          int r1=directions.get(currentDirection).routePointOffset;
          int r2=resInfo.routePointOffset;
          distanceAfter=listDistance[resInfo.routePointOffset];
          float dist=locations.get(r1).distanceTo(locations.get(r2));
          if (dist < 100) {
            currentDirection++;
            continue;
          }
 else           if (directions.get(currentDirection).routePointOffset > resInfo.routePointOffset) {
            break;
          }
        }
        RouteDirectionInfo toAdd=directions.get(currentDirection);
        if (i > 0) {
          RouteDirectionInfo previous=res.directions.get(i - 1);
          toAdd.setAverageSpeed(previous.getAverageSpeed());
        }
        toAdd.distance=listDistance[toAdd.routePointOffset] - distanceAfter;
        if (i < res.directions.size()) {
          res.directions.add(i,toAdd);
        }
 else {
          res.directions.add(toAdd);
        }
        i++;
        currentDirection++;
      }
    }
  }
  int sum=0;
  for (int i=res.directions.size() - 1; i >= 0; i--) {
    res.directions.get(i).afterLeftTime=sum;
    sum+=res.directions.get(i).getExpectedTime();
  }
}
