{
  BinaryMapIndexReader[] files=app.getResourceManager().getRoutingMapFiles();
  BinaryRoutePlanner router=new BinaryRoutePlanner(NativeOsmandLibrary.getLoadedLibrary(),files);
  File routingXml=app.getSettings().extendOsmandPath(ResourceManager.ROUTING_XML);
  RoutingConfiguration.Builder config;
  if (routingXml.exists() && routingXml.canRead()) {
    try {
      config=RoutingConfiguration.parseFromInputStream(new FileInputStream(routingXml));
    }
 catch (    SAXException e) {
      throw new IllegalStateException(e);
    }
  }
 else {
    config=RoutingConfiguration.getDefault();
  }
  GeneralRouterProfile p;
  if (mode == ApplicationMode.BICYCLE) {
    p=GeneralRouterProfile.BICYCLE;
  }
 else   if (mode == ApplicationMode.PEDESTRIAN) {
    p=GeneralRouterProfile.PEDESTRIAN;
  }
 else {
    p=GeneralRouterProfile.CAR;
  }
  List<String> specs=new ArrayList<String>();
  if (!app.getSettings().FAST_ROUTE_MODE.get()) {
    specs.add(GeneralRouter.USE_SHORTEST_WAY);
  }
  if (app.getSettings().AVOID_FERRIES.get()) {
    specs.add(GeneralRouter.AVOID_FERRIES);
  }
  if (app.getSettings().AVOID_TOLL_ROADS.get()) {
    specs.add(GeneralRouter.AVOID_TOLL);
  }
  if (app.getSettings().AVOID_MOTORWAY.get()) {
    specs.add(GeneralRouter.AVOID_MOTORWAY);
  }
  if (app.getSettings().AVOID_UNPAVED_ROADS.get()) {
    specs.add(GeneralRouter.AVOID_UNPAVED);
  }
  String[] specialization=specs.toArray(new String[specs.size()]);
  RoutingContext ctx=new RoutingContext(config.build(p.name().toLowerCase(),start.hasBearing() ? start.getBearing() / 180d * Math.PI : null,specialization));
  ctx.interruptable=interruptable;
  ctx.previouslyCalculatedRoute=previousRoute;
  RouteSegment st=router.findRouteSegment(start.getLatitude(),start.getLongitude(),ctx);
  if (st == null) {
    return new RouteCalculationResult(app.getString(R.string.starting_point_too_far));
  }
  RouteSegment en=router.findRouteSegment(end.getLatitude(),end.getLongitude(),ctx);
  if (en == null) {
    return new RouteCalculationResult("End point is far from allowed road.");
  }
  try {
    List<RouteSegmentResult> result=router.searchRoute(ctx,st,en,leftSide);
    return new RouteCalculationResult(result,start,end,app,leftSide);
  }
 catch (  OutOfMemoryError e) {
    ActivityManager activityManager=(ActivityManager)app.getSystemService(Context.ACTIVITY_SERVICE);
    ActivityManager.MemoryInfo memoryInfo=new ActivityManager.MemoryInfo();
    activityManager.getMemoryInfo(memoryInfo);
    return new RouteCalculationResult("Not enough process memory " + "(" + memoryInfo.availMem / 1048576L + " MB available) ");
  }
}
