{
  ctx.timeToLoad=0;
  ctx.visitedSegments=0;
  ctx.memoryOverhead=1000;
  ctx.timeToCalculate=System.nanoTime();
  if (ctx.config.initialDirection != null) {
    ctx.firstRoadId=calculateRoutePointId(start.getRoad(),start.getSegmentStart(),true);
    double plusDir=start.getRoad().directionRoute(start.getSegmentStart(),true);
    double diff=plusDir - ctx.config.initialDirection;
    if (Math.abs(MapUtils.alignAngleDifference(diff)) <= Math.PI / 3) {
      ctx.firstRoadDirection=1;
    }
 else     if (Math.abs(MapUtils.alignAngleDifference(diff - Math.PI)) <= Math.PI / 3) {
      ctx.firstRoadDirection=-1;
    }
  }
  if (ctx.precalculatedRouteDirection != null) {
    ctx.precalculatedRouteDirection.prereg(ctx.startX,ctx.startY);
    ctx.precalculatedRouteDirection.prereg(ctx.targetX,ctx.targetY);
  }
  Comparator<RouteSegment> nonHeuristicSegmentsComparator=new NonHeuristicSegmentsComparator();
  PriorityQueue<RouteSegment> graphDirectSegments=new PriorityQueue<RouteSegment>(50,new SegmentsComparator(ctx));
  PriorityQueue<RouteSegment> graphReverseSegments=new PriorityQueue<RouteSegment>(50,new SegmentsComparator(ctx));
  TLongObjectHashMap<RouteSegment> visitedDirectSegments=new TLongObjectHashMap<RouteSegment>();
  TLongObjectHashMap<RouteSegment> visitedOppositeSegments=new TLongObjectHashMap<RouteSegment>();
  RouteSegment recalcEndSegment=smartRecalculationEnabled(ctx,visitedOppositeSegments);
  boolean runRecalculation=false;
  if (recalcEndSegment != null) {
    runRecalculation=true;
    end=recalcEndSegment;
  }
  float estimatedDistance=(float)estimatedDistance(ctx,ctx.targetX,ctx.targetY,ctx.startX,ctx.startY);
  end.distanceToEnd=start.distanceToEnd=estimatedDistance;
  graphDirectSegments.add(start);
  graphReverseSegments.add(end);
  boolean inverse=false;
  boolean init=false;
  PriorityQueue<RouteSegment> graphSegments;
  if (inverse) {
    graphSegments=graphReverseSegments;
  }
 else {
    graphSegments=graphDirectSegments;
  }
  ctx.loadBorderPoints();
  FinalRouteSegment finalSegment=null;
  while (!graphSegments.isEmpty()) {
    RouteSegment segment=graphSegments.poll();
    ctx.memoryOverhead=(visitedDirectSegments.size() + visitedOppositeSegments.size()) * STANDARD_ROAD_VISITED_OVERHEAD + (graphDirectSegments.size() + graphReverseSegments.size()) * STANDARD_ROAD_IN_QUEUE_OVERHEAD;
    if (TRACE_ROUTING) {
      printRoad(">",segment);
    }
    if (segment instanceof FinalRouteSegment) {
      if (RoutingContext.SHOW_GC_SIZE) {
        log.warn("Estimated overhead " + (ctx.memoryOverhead / (1 << 20)) + " mb");
        printMemoryConsumption("Memory occupied after calculation : ");
      }
      finalSegment=(FinalRouteSegment)segment;
      break;
    }
    if (ctx.memoryOverhead > ctx.config.memoryLimitation * 0.95 && RoutingContext.SHOW_GC_SIZE) {
      printMemoryConsumption("Memory occupied before exception : ");
    }
    if (ctx.memoryOverhead > ctx.config.memoryLimitation * 0.95) {
      throw new IllegalStateException("There is no enough memory " + ctx.config.memoryLimitation / (1 << 20) + " Mb");
    }
    ctx.visitedSegments++;
    if (!inverse) {
      processRouteSegment(ctx,false,graphDirectSegments,visitedDirectSegments,segment,visitedOppositeSegments,true);
      processRouteSegment(ctx,false,graphDirectSegments,visitedDirectSegments,segment,visitedOppositeSegments,false);
    }
 else {
      processRouteSegment(ctx,true,graphReverseSegments,visitedOppositeSegments,segment,visitedDirectSegments,true);
      processRouteSegment(ctx,true,graphReverseSegments,visitedOppositeSegments,segment,visitedDirectSegments,false);
    }
    updateCalculationProgress(ctx,graphDirectSegments,graphReverseSegments);
    if (graphReverseSegments.isEmpty()) {
      throw new IllegalArgumentException("Route is not found to selected target point.");
    }
    if (graphDirectSegments.isEmpty()) {
      throw new IllegalArgumentException("Route is not found from selected start point.");
    }
    if (runRecalculation) {
      inverse=false;
    }
 else     if (!init) {
      inverse=!inverse;
      init=true;
    }
 else     if (ctx.planRouteIn2Directions()) {
      inverse=nonHeuristicSegmentsComparator.compare(graphDirectSegments.peek(),graphReverseSegments.peek()) > 0;
      if (graphDirectSegments.size() * 1.3 > graphReverseSegments.size()) {
        inverse=true;
      }
 else       if (graphDirectSegments.size() < 1.3 * graphReverseSegments.size()) {
        inverse=false;
      }
    }
 else {
      inverse=ctx.getPlanRoadDirection() < 0;
    }
    if (inverse) {
      graphSegments=graphReverseSegments;
    }
 else {
      graphSegments=graphDirectSegments;
    }
    if (ctx.calculationProgress != null && ctx.calculationProgress.isCancelled) {
      throw new InterruptedException("Route calculation interrupted");
    }
  }
  printDebugMemoryInformation(ctx,graphDirectSegments,graphReverseSegments,visitedDirectSegments,visitedOppositeSegments);
  return finalSegment;
}
