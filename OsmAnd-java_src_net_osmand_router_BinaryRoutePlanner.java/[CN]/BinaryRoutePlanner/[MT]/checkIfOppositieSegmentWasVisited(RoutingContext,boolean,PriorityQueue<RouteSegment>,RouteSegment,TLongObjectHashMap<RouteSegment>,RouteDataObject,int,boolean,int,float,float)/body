{
  long opp=calculateRoutePointId(road,intervalId,!positive);
  if (oppositeSegments.containsKey(opp)) {
    RouteSegment opposite=oppositeSegments.get(opp);
    if (opposite.getSegmentStart() == segmentEnd) {
      FinalRouteSegment frs=new FinalRouteSegment(road,segment.getSegmentStart());
      float distStartObstacles=segment.distanceFromStart + calculateTimeWithObstacles(ctx,road,segmentDist,obstaclesTime);
      frs.setParentRoute(segment.getParentRoute());
      frs.setParentSegmentEnd(segment.getParentSegmentEnd());
      frs.reverseWaySearch=reverseWaySearch;
      frs.distanceFromStart=opposite.distanceFromStart + distStartObstacles;
      frs.distanceToEnd=0;
      frs.opposite=opposite;
      graphSegments.add(frs);
      return true;
    }
  }
  return false;
}
