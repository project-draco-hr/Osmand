{
  Element[] e=parent.getAllElements();
  RouteDataBlock.Builder dataBlock=null;
  BinaryFileReference ref=bounds.get(parent.getNodeIndex());
  TLongArrayList wayMapIds=new TLongArrayList();
  TLongArrayList pointMapIds=new TLongArrayList();
  for (int i=0; i < parent.getTotalElements(); i++) {
    if (e[i].getElementType() == rtree.Node.LEAF_NODE) {
      long id=((LeafElement)e[i]).getPtr();
      selectData.setLong(1,id);
      ResultSet rs=selectData.executeQuery();
      if (rs.next()) {
        if (dataBlock == null) {
          dataBlock=RouteDataBlock.newBuilder();
          tempStringTable.clear();
          wayMapIds.clear();
          pointMapIds.clear();
        }
        int cid=registerId(wayMapIds,id);
        tempNames.clear();
        decodeNames(rs.getString(5),tempNames);
        byte[] types=rs.getBytes(1);
        int[] typeUse=new int[types.length / 2];
        for (int j=0; j < types.length; j+=2) {
          int ids=Algoritms.parseSmallIntFromBytes(types,j);
          typeUse[j / 2]=routeTypes.getTypeByInternalId(ids).getTargetId();
        }
        byte[] pointTypes=rs.getBytes(2);
        byte[] pointIds=rs.getBytes(3);
        byte[] pointCoordinates=rs.getBytes(4);
        int typeInd=0;
        RoutePointToWrite[] points=new RoutePointToWrite[pointCoordinates.length / 8];
        TLongArrayList restrictions=highwayRestrictions.get(id);
        if (restrictions != null) {
          for (int li=0; li < restrictions.size(); li++) {
            Builder restriction=RestrictionData.newBuilder();
            restriction.setFrom(cid);
            int toId=registerId(wayMapIds,restrictions.get(li) >> 3);
            restriction.setTo(toId);
            restriction.setType((int)(restrictions.get(li) & 0x7));
            dataBlock.addRestrictions(restriction.build());
          }
        }
        for (int j=0; j < points.length; j++) {
          points[j]=new RoutePointToWrite();
          points[j].x=Algoritms.parseIntFromBytes(pointCoordinates,j * 8);
          points[j].y=Algoritms.parseIntFromBytes(pointCoordinates,j * 8 + 4);
          if (WRITE_POINT_ID) {
            points[j].id=registerId(pointMapIds,Algoritms.parseLongFromBytes(pointIds,j * 8));
          }
          int type=0;
          do {
            type=Algoritms.parseSmallIntFromBytes(pointTypes,typeInd);
            typeInd+=2;
            if (type != 0) {
              points[j].types.add(routeTypes.getTypeByInternalId(type).getTargetId());
            }
          }
 while (type != 0);
        }
        RouteData routeData=writer.writeRouteData(cid,parentBounds.getMinX(),parentBounds.getMinY(),typeUse,points,names,tempStringTable,dataBlock,true,WRITE_POINT_ID);
        if (routeData != null) {
          dataBlock.addDataObjects(routeData);
        }
      }
 else {
        logMapDataWarn.error("Something goes wrong with id = " + id);
      }
    }
  }
  if (dataBlock != null) {
    IdTable.Builder idTable=IdTable.newBuilder();
    long prev=0;
    for (int i=0; i < wayMapIds.size(); i++) {
      idTable.addRouteId(wayMapIds.getQuick(i) - prev);
      prev=wayMapIds.getQuick(i);
    }
    if (WRITE_POINT_ID) {
      prev=0;
      for (int i=0; i < pointMapIds.size(); i++) {
        prev=pointMapIds.getQuick(i);
      }
    }
    dataBlock.setIdTable(idTable.build());
    writer.writeRouteDataBlock(dataBlock,tempStringTable,ref);
  }
  for (int i=0; i < parent.getTotalElements(); i++) {
    if (e[i].getElementType() != rtree.Node.LEAF_NODE) {
      long ptr=((NonLeafElement)e[i]).getPtr();
      rtree.Node ns=r.getReadNode(ptr);
      writeBinaryMapBlock(ns,e[i].getRect(),r,writer,selectData,bounds,tempStringTable,tempNames);
    }
  }
}
